<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 程序设计语言 简体中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 程序设计语言 简体中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">前言</a></li><li class="affix"><a href="ch00-00-introduction.html">介绍</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 入门指南</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 猜猜看游戏教程</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 通用编程概念</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 变量与可变性</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 数据类型</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 函数如何工作</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 注释</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 认识所有权</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 什么是所有权？</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 引用与借用</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 使用结构体来组织相关联的数据</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 定义并实例化结构体</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 一个使用结构体的示例程序</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 方法语法</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 枚举与模式匹配</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 定义枚举</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 控制流运算符</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let 简洁控制流</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 模块</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod 与文件系统</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> 使用 pub 控制可见性</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 在不同的模块中引用命名</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 通用集合类型</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> vector</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 字符串</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 哈希 map</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 错误处理</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! 与不可恢复的错误</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result 与可恢复的错误</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! 还是不 panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 泛型、trait 与生命周期</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 泛型数据类型</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> trait：定义共享的行为</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 生命周期与引用有效性</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 测试</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 编写测试</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 运行测试</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 测试的组织结构</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 一个 I/O 项目：构建命令行程序</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 接受命令行参数</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 读取文件</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 重构以改进模块化与错误处理</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 采用测试驱动开发完善库的功能</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 处理环境变量</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 将错误信息输出到标准错误而不是标准输出</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Rust 中的函数式语言功能：迭代器与闭包</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 闭包：可以捕获其环境的匿名函数</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 使用迭代器处理元素序列</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 改进之前的 I/O 项目</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 性能比较：循环对迭代器</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 更多关于 Cargo 和 Crates.io 的内容</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 采用发布配置自定义构建</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 将 crate 发布到 Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 工作空间</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 使用 cargo install 从 Crates.io 安装二进制文件</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo 自定义扩展命令</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 智能指针</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> 指向堆上数据，并且可确定大小</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 通过 Deref trait 将智能指针当作常规引用处理</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Trait 运行清理代码</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T> 引用计数智能指针</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> 与内部可变性模式</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 引用循环与内存泄漏是安全的</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 无畏并发</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 线程</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 消息传递</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 共享状态</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 可扩展的并发：Sync 与 Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust 的面向对象编程特性</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 面向对象语言的特点</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 为使用不同类型的值而设计的 trait 对象</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 面向对象设计模式的实现</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 模式用来匹配值的结构</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 所有可能会用到模式的位置</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability：何时模式可能会匹配失败</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 模式的全部语法</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高级特征</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 不安全的 Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 高级生命周期</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 高级 trait</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 高级类型</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 高级函数与闭包</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最后的项目: 构建多线程 web server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 单线程 web server</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 将单线程 server 变为多线程 server</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 优雅停机与清理</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 附录</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 关键字</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 运算符与符号</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 可派生的 trait</a></li><li><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 宏</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 本书翻译</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 最新功能</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust 是如何开发的与 “Nightly Rust”</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 程序设计语言 简体中文版</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#a前言" id="a前言"><h1>前言</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/foreword.md">foreword.md</a>
<br>
commit 5e085bd1add34aec03416e891751552b439dde52</p>
</blockquote>
<p>虽然不是那么明显，但 Rust 程序设计语言的本质在于 <strong>赋能</strong>（<em>empowerment</em>）：无论你现在编写的是何种代码，Rust 能让你在更为广泛的编程领域走得更远，写出自信。</p>
<p>比如，“系统层面”（“systems-level”）的工作，涉及内存管理、数据表示和并发等底层细节。从传统角度来看，这是一个神秘的编程领域，只为浸淫多年的极少数人所触及，也只有他们能避开那些臭名昭著的陷阱。即使谨慎的实践者，亦唯恐代码出现漏洞、崩溃或损坏。</p>
<p>Rust 破除了这些障碍，其消除了旧的陷阱并提供了伴你一路同行的友好、精良的工具。想要 “深入” 底层控制的程序员可以使用 Rust，无需冒着常见的崩溃或安全漏洞的风险，也无需学习时常改变的工具链的最新知识。其语言本身更是被设计为自然而然的引导你编写出在运行速度和内存使用上都十分高效的可靠代码。</p>
<p>已经在从事编写底层代码的程序员可以使用 Rust 来提升抱负。例如，在 Rust 中引入并行是相对低风险的操作：编译器会为你捕获经典的错误。同时你可以自信的采取更为积极的优化，而不会意外引入崩溃或漏洞。</p>
<p>但 Rust 并不局限于底层系统编程。其表现力和工效足以令人愉悦的编写出 CLI 应用、web server 和很多其他类型的代码 —— 在本书中你会看到两个简单示例。使用 Rust 能将你在一个领域中学习的技能延伸到另一个领域；你可以学习 Rust 来编写 web 应用，接着将同样的技能应用到你的 Raspberry Pi（树莓派）上。</p>
<p>本书全面介绍了 Rust 为用户赋予的能力。其内容平易近人，致力于帮助你提升 Rust 的知识，并且提升你作为程序员整体的理解与自信。那么让我们准备深入学习 Rust 吧（打开新世界的大门 :)） —— 欢迎加入 Rust 社区！</p>
<p>— Nicholas Matsakis 和 Aaron Turon</p>
<a class="header" href="print.html#a介绍" id="a介绍"><h1>介绍</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch00-00-introduction.md">ch00-00-introduction.md</a>
<br>
commit 7480e811ab5ad8d53a5b854d9b0c7a5a4f58499f</p>
</blockquote>
<blockquote>
<p>注意：本书的版本与出版的 <a href="https://nostarch.com/rust">The Rust Programming Language</a>
和电子版的 <a href="https://nostarch.com/">No Starch Press</a> 一致</p>
</blockquote>
<p>欢迎阅读 “Rust 程序设计语言”，一本介绍 Rust 的书。</p>
<p>Rust 程序设计语言能帮你编写出更快、更可靠的软件。在其他编程语言设计中，高层工程学和底层控制往往不能兼得；Rust 则试图挑战该现象。通过权衡强大的技术能力与优秀的开发体验，Rust 允许你控制底层细节（比如内存使用），并免受过去做此类控制所经历的烦恼。</p>
<a class="header" href="print.html#a谁会使用-rust" id="a谁会使用-rust"><h2>谁会使用 Rust</h2></a>
<p>Rust 因多种原因适用于很多开发者。让我们讨论几个最重要的群体。</p>
<a class="header" href="print.html#a开发者团队" id="a开发者团队"><h3>开发者团队</h3></a>
<p>Rust 被证明是可用于大型的、拥有不同层次系统编程知识的开发者团队间协作的高效工具。底层代码中容易出现大量隐晦的 bug，在其他编程语言中，只能通过大量的测试和经验丰富的开发者细心的代码评审来捕获。在 Rust 中，编译器充当了守门员的角色，它拒绝编译存在隐晦 bug 的代码，包括并发 bug。通过与编译器合作，团队将更多的时间聚焦在程序逻辑上，而不是追踪 bug。</p>
<p>Rust 也将当前的开发工具带到了系统编程世界：</p>
<ul>
<li>Cargo，内置的依赖管理器和构建工具，它能轻松增加、编译和管理依赖，并在 Rust 生态系统中保持一致。</li>
<li>Rustfmt 确保开发者遵循一致的代码风格。</li>
<li>Rust Language Server 为集成开发环境（IDE）提供了强大的代码补全和内联错误信息功能。</li>
</ul>
<p>通过使用 Rust 生态系统中的这些和其他工具，开发者可以在编写系统层面代码时保持高生产力。</p>
<a class="header" href="print.html#a学生" id="a学生"><h3>学生</h3></a>
<p>Rust 适用于学生或任何对操作系统概念感兴趣的人。通过 Rust，很多人已经了解操作系统开发这样的主题。社区非常欢迎并乐于解答学生们的问题。通过类似于本书这样的努力，Rust 团队希望更多人了解操作系统的概念，特别是编程新手。</p>
<a class="header" href="print.html#a公司" id="a公司"><h3>公司</h3></a>
<p>数以百计的公司，无论规模大小，正将 Rust 用于生产环境中的多种任务。这些任务包括命令行工具、web 服务、DevOps 工具、嵌入式设备、音视频分析与转码、数字货币（cryptocurrencies）、生物信息学（bioinformatics）、搜索引擎、物联网（internet of things, IOT）程序、机器学习，甚至还包括 Firefox 浏览器的大部分内容。</p>
<a class="header" href="print.html#a开源开发者" id="a开源开发者"><h3>开源开发者</h3></a>
<p>Rust 适用于希望构建 Rust 编程语言、社区、开发工具和库的开发者。我们期望你为 Rust 语言做贡献。</p>
<a class="header" href="print.html#a重视速度和稳定性的开发者" id="a重视速度和稳定性的开发者"><h3>重视速度和稳定性的开发者</h3></a>
<p>Rust 适用于追求编程语言的速度与稳定性的开发者。所谓速度，我们指你用 Rust 开发出的程序运行速度，以及 Rust 提供的程序开发速度。Rust 的编译器检查确保了增加功能和重构代码时的稳定性。这与缺少这些检查的语言形成鲜明对比，开发者通常害怕修改那些脆弱的遗留代码。通过力求零开销抽象（zero-cost abstractions），高层级的特性被编译为底层代码，与手写的一样快，Rust 致力于使安全的代码也同样快速。</p>
<p>Rust 语言希望能支持更多用户，这里提及的只是最大的利益相关者。总的来讲，Rust 最重要的目标是消除数十年来程序员不得不做的权衡：安全 <strong>与</strong> 生产力、速度 <strong>与</strong> 工程学。请尝试 Rust，看看它的选择是否适合你。</p>
<a class="header" href="print.html#a谁会阅读本书" id="a谁会阅读本书"><h2>谁会阅读本书</h2></a>
<p>本书假设你已经使用其他编程语言编写过代码，但并不假设你使用的是何种语言。我们尝试使这些材料能广泛的适用于来自很多不同编程背景的开发者。我们不会花费很多时间讨论编程 <strong>是</strong> 什么或者如何理解它。如果编程对于你来说是完全陌生的，你最好先阅读专门介绍编程的书籍。</p>
<a class="header" href="print.html#a如何阅读本书" id="a如何阅读本书"><h2>如何阅读本书</h2></a>
<p>总体来说，本书假设你会从头到尾顺序阅读。稍后的章节建立在之前章节概念的基础上，同时之前的章节可能不会深入讨论一个主题的细节；通常稍后的章节会重新讨论这些主题。</p>
<p>你会在本书中发现两类章节：概念章节和项目章节。在概念章节中，我们学习 Rust 的某个方面。在项目章节中，我们应用目前所学的知识一同构建小的程序。第二、十二和二十章是项目章节；其余都是概念章节。</p>
<p>第一章介绍如何安装 Rust，如何编写 Hello world 程序，以及如何使用 Rust 的包管理器和构建工具 Cargo。第二章是 Rust 语言的实战介绍。我们会介绍一些高层级的概念，在稍后章节会详细介绍。如果你希望立刻就动手实践一下，第二章正好适合你。开始阅读时，你甚至可能希望略过第三章，它介绍了 Rust 中类似其他编程语言中的功能，并直接阅读第四章学习 Rust 的所有权系统。然而，如果你是特别重视细节的学习者，并倾向于在继续之前学习每一个细节，你可能希望略过第二章并直接阅读第三章，并在想要构建项目来实践这些细节时再回来阅读第二章。</p>
<p>第五章讨论结构体和方法，第六章介绍枚举、<code>match</code> 表达式和 <code>if let</code> 控制流结构。在 Rust 中，你将使用结构体和枚举创建自定义类型。</p>
<p>第七章，你会学习 Rust 的模块系统和私有性规则来组织代码和公有应用程序设计接口（Application Programming Interface, API）。第八章讨论了一些标准库提供的通用集合数据结构，比如 vector、字符串和哈希 map。第九章探索了 Rust 的错误处理哲学和技术。</p>
<p>第十章深入介绍泛型、trait 和生命周期，他们提供了定义出适用于多种类型的代码的能力。第十一章介绍测试，即使 Rust 有安全保证，也需要测试确保程序逻辑正确。第十二章，我们构建了属于自己的在文件中搜索文本的命令行工具 <code>grep</code> 的子集功能实现。为此会利用之前章节讨论的很多概念。</p>
<p>第十三章探索了闭包和迭代器：Rust 中来自函数式编程语言的功能。第十四章会更深层次的理解 Cargo 并讨论向他人分享库的最佳实践。第十五章讨论标准库提供的智能指针以及启用这些功能的 trait。</p>
<p>第十六章会学习不同的并发编程模型，并讨论 Rust 如何助你无畏的编写多线程程序。第十七章着眼于比较 Rust 风格与你可能熟悉的面向对象编程原则。</p>
<p>第十八章是一个模式与模式匹配的参考章节，他们是在整个 Rust 程序中表达意图的强大方式。第十九章是一个高级主题大杂烩，包括 unsafe Rust 和更多关于生命周期、 trait、类型、函数和闭包的内容。</p>
<p>第二十章会完成一个项目，实现了一个底层的、多线程的 web server！</p>
<p>最后是一些附录，包含了一些关于语言的参考风格格式的实用信息。附录 A 介绍了 Rust 的关键字。附录 B 介绍 Rust 的运算符和符号。附录 C 介绍标准库提供的派生 trait。附录 D 介绍宏。</p>
<p>怎样阅读本书都不会有任何问题：如果你希望略过一些内容，请继续！如果你发现疑惑可能会再跳回之前的章节。无论怎样都是可以的。</p>
<p>学习 Rust 的过程中一个重要的部分是学习如何阅读编译器提供的错误信息：它们会指导你编写出能工作的代码。为此，我们会提供很多不能编译的示例代码，以及各个情况下编译器会展示的错误信息。请注意如果随便输入并运行随机的示例代码，它们可能无法编译！请确保阅读任何你尝试运行的示例周围的内容，检视他们是否有意写错。在大部分情况，我们会指引你将任何不能编译的代码纠正为正确版本。</p>
<a class="header" href="print.html#a源代码" id="a源代码"><h2>源代码</h2></a>
<p>生成本书的源码可以在 <a href="https://github.com/rust-lang/book/tree/master/second-edition/src">GitHub</a> 上找到。</p>
<blockquote>
<p>译者注：本译本的 <a href="https://github.com/KaiserY/trpl-zh-cn">GitHub 仓库</a>，欢迎 Issue 和 PR :)</p>
</blockquote>
<a class="header" href="print.html#a入门指南" id="a入门指南"><h1>入门指南</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch01-00-getting-started.md">ch01-00-getting-started.md</a>
<br>
commit 7480e811ab5ad8d53a5b854d9b0c7a5a4f58499f</p>
</blockquote>
<p>让我们开始 Rust 之旅！有很多内容要学，但每次旅程总有起点。在本章中，我们会讨论：</p>
<ul>
<li>在 Linux、macOS 和 Windows 上安装 Rust</li>
<li>编写一个打印 <code>Hello, world!</code> 的程序</li>
<li>使用 Rust 的包管理器和构建系统 <code>cargo</code></li>
</ul>
<a class="header" href="print.html#a安装" id="a安装"><h2>安装</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch01-01-installation.md">ch01-01-installation.md</a>
<br>
commit 7480e811ab5ad8d53a5b854d9b0c7a5a4f58499f</p>
</blockquote>
<p>第一步是安装 Rust。我们通过 <code>rustup</code> 下载 Rust，这是一个管理 Rust 版本和相关工具的命令行工具。下载时需要联网。</p>
<blockquote>
<p>注意：如果出于某些理由你倾向于不使用 <code>rustup</code>，请到 <a href="https://www.rust-lang.org/install.html">Rust 安装页面</a> 查看其它安装选项。</p>
</blockquote>
<p>接下来的步骤会安装最新的稳定版 Rust 编译器。本书所有示例和输出采用稳定版 Rust 1.21.0。Rust 的稳定性确保本书所有示例在最新版本的 Rust 中能够继续编译。不同版本的输出可能略有不同，因为 Rust 经常改进错误信息和警告。也就是说，通过这些步骤安装的最新稳定版 Rust，能正常运行本书中的内容。</p>
<blockquote>
<a class="header" href="print.html#a命令行标记" id="a命令行标记"><h3>命令行标记</h3></a>
<p>本章和全书中，我们会展示在终端中使用的命令。所有需要输入到终端的行都以 <code>$</code> 开头。但无需输入<code>$</code>；它代表每行命令的起点。不以 <code>$</code> 起始的行通常展示之前命令的输出。另外，PowerShell 专用的示例会采用 <code>&gt;</code> 而不是 <code>$</code>。</p>
</blockquote>
<a class="header" href="print.html#a在-linux-或-macos-上安装-rustup" id="a在-linux-或-macos-上安装-rustup"><h3>在 Linux 或 macOS 上安装 <code>rustup</code></h3></a>
<p>如果你使用 Linux 或 macOS，打开终端并输入如下命令：</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>此命令下载一个脚本并开始安装 <code>rustup</code> 工具，这会安装最新稳定版 Rust。过程中可能会提示你输入密码。如果安装成功，将会出现如下内容：</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>如果你愿意，可在运行前下载并检查该脚本。</p>
<p>此安装脚本自动将 Rust 加入系统 PATH 环境变量中，在下一次登录时生效。如果你希望立刻就开始使用 Rust 而不重启终端，在 shell 中运行如下命令，手动将 Rust 加入系统 PATH 变量中：</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>或者，可以在 <em>~/.bash_profile</em> 文件中增加如下行：</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<p>另外，你需要一个某种类型的链接器（linker）。很有可能已经安装，不过当你尝试编译 Rust 程序时，却有错误指出无法执行链接器，这意味着你的系统上没有安装链接器，你需要自行安装一个。C 编译器通常带有正确的链接器。请查看你使用平台的文档，了解如何安装 C 编译器。并且，一些常用的 Rust 包依赖 C 代码，也需要安装 C 编译器。因此现在安装一个是值得的。</p>
<a class="header" href="print.html#a在-windows-上安装-rustup" id="a在-windows-上安装-rustup"><h3>在 Windows 上安装 <code>rustup</code></h3></a>
<p>在 Windows 上，前往 <a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a> 并按照说明安装 Rust。在安装过程的某个步骤，你会收到一个信息说明为什么需要安装 Visual Studio 2013 或之后版本的 C++ build tools。获取这些 build tools 最方便的方法是安装 <a href="https://www.visualstudio.com/downloads/">Build Tools for Visual Studio 2017</a>。这个工具在 “Other Tools and Frameworks” 部分。</p>
<p>本书的余下部分，使用能同时运行于 <em>cmd.exe</em> 和 PowerShell 的命令。如果存在特定差异，我们会解释使用哪一个。</p>
<a class="header" href="print.html#a更新和卸载" id="a更新和卸载"><h3>更新和卸载</h3></a>
<p>通过 <code>rustup</code> 安装了 Rust 之后，很容易更新到最新版本。在 shell 中运行如下更新脚本：</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<p>为了卸载 Rust 和 <code>rustup</code>，在 shell 中运行如下卸载脚本:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#a故障排除troubleshooting" id="a故障排除troubleshooting"><h3>故障排除（Troubleshooting）</h3></a>
<p>要检查是否正确安装了 Rust，打开 shell 并运行如下行：</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>你应能看到已发布的最新稳定版的版本号、提交哈希和提交日期，显示为如下格式：</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>如果出现这些内容，Rust 就安装成功了！如果并没有看到这些信息，并且使用的是 Windows，请检查 Rust 是否位于 <code>%PATH%</code> 系统变量中。如果一切正确但 Rust 仍不能使用，有许多地方可以求助。最简单的是 <a href="irc://irc.mozilla.org/#rust">irc.mozilla.org 上的 #rust IRC 频道</a><!-- ignore --> ，可以使用 <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a> 来访问它。然后就能和其他 Rustacean（Rust 用户的称号，有自嘲意味）聊天并寻求帮助。其它给力的资源包括<a href="https://users.rust-lang.org/">用户论坛</a>和 <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>。</p>
<p>恭喜入坑！（此处应该有掌声！）</p>
<a class="header" href="print.html#a本地文档" id="a本地文档"><h3>本地文档</h3></a>
<p>安装程序也自带一份文档的本地拷贝，可以离线阅读。运行 <code>rustup doc</code> 在浏览器中查看本地文档。</p>
<p>任何时候，如果你拿不准标准库中的类型或函数的用途和用法，请查看应用程序接口（application programming interface，API）文档！</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch01-02-hello-world.md">ch01-02-hello-world.md</a>
<br>
commit 5dfa983aa8fca89f8b70cafe58ab8417491d2018</p>
</blockquote>
<p>既然安装好了 Rust，我们来编写第一个 Rust 程序。当学习一门新语言的时候，使用该语言在屏幕上打印 <code>Hello, world!</code> 是一项传统，这里我们将沿用这个传统！</p>
<blockquote>
<p>注意：本书假设你熟悉基本的命令行操作。Rust 对于你的编辑器、工具，以及代码位于何处并没有特定的要求，如果你更倾向于使用集成开发环境（IDE），而不是命令行，请尽管使用你喜欢的 IDE。目前很多 IDE 已经不同程度的支持 Rust；查看 IDE 文档了解更多细节。最近，Rust 团队已经致力于提供强大的 IDE 支持，而且进展飞速！</p>
</blockquote>
<a class="header" href="print.html#a创建项目目录" id="a创建项目目录"><h3>创建项目目录</h3></a>
<p>首先创建一个存放 Rust 代码的目录。Rust 并不关心代码的存放位置，不过对于本书的练习和项目来说，我们建议你在 home 目录中创建 <em>projects</em> 目录，并将你的所有项目存放在这里。</p>
<p>打开终端并输入如下命令创建 <em>projects</em> 目录，并在 <em>projects</em> 目录中为 Hello, world! 项目创建一个目录。</p>
<p>对于 Linux 和 macOS，输入：</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>对于 Windows CMD，输入：</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>对于 Windows PowerShell，输入：</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<a class="header" href="print.html#a编写并运行-rust-程序" id="a编写并运行-rust-程序"><h3>编写并运行 Rust 程序</h3></a>
<p>接下来，新建一个源文件，命名为 <em>main.rs</em>。Rust 源文件总是以 <em>.rs</em> 扩展名结尾。如果文件名包含多个单词，使用下划线分隔它们。例如命名为 <em>hello_world.rs</em>，而不是 <em>helloworld.rs</em>。</p>
<p>现在打开刚创建的 <em>main.rs</em> 文件，输入示例 1-1 中的代码。</p>
<p><span class="filename">文件名: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">示例 1-1: 一个打印 <code>Hello, world!</code> 的程序</span></p>
<p>保存文件，并回到终端窗口。在 Linux 或 macOS 上，输入如下命令，编译并运行文件：</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>在 Windows 上，输入命令 <code>.\main.exe</code>，而不是 <code>./main</code>：</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>不管使用何种操作系统，终端应该打印字符串 <code>Hello, world!</code>。如果没有看到这些输出，回到 “故障排除” 部分查找寻求帮助的方法。</p>
<p>如果 <code>Hello, world!</code> 出现了，恭喜你！你已经正式编写了一个 Rust 程序。现在你成为一名 Rust 程序员，欢迎！</p>
<a class="header" href="print.html#a分析-rust-程序" id="a分析-rust-程序"><h3>分析 Rust 程序</h3></a>
<p>现在，让我们回过头来仔细看看 Hello, world! 程序中到底发生了什么。这是第一块拼图：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>这几行定义了一个 Rust 函数。<code>main</code> 函数是一个特殊的函数：在可执行的 Rust 程序中，它总是最先运行的代码。第一行代码声明了一个叫做 <code>main</code> 的函数，它没有参数也没有返回值。如果有参数的话，它们的名称应该出现在小括号中，<code>()</code>。</p>
<p>还须注意，函数体被包裹在花括号中，<code>{}</code>。Rust 要求所有函数体都要用花括号包裹起来（译者注：有些语言，当函数体只有一行时可以省略花括号，但在 Rust 中是不行的）。一般来说，将左花括号与函数声明置于同一行并以空格分隔，是良好的代码风格。</p>
<p>在编写本书的时候，一个叫做 <code>rustfmt</code> 的自动格式化工具正在开发中。如果你希望在 Rust 项目中保持一种标准风格，<code>rustfmt</code> 会将代码格式化为特定的风格。Rust 团队计划最终将该工具包含在标准 Rust 发行版中，就像 <code>rustc</code>。所以根据你阅读本书的时间，它可能已经安装到你的电脑中了！检查在线文档以了解更多细节。</p>
<p>在 <code>main()</code> 函数中是如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<p>这行代码完成这个简单程序的所有工作：在屏幕上打印文本。这里有四个重要的细节需要注意。首先 Rust 的缩进风格使用 4 个空格，而不是 1 个制表符（tab）。</p>
<p>第二，<code>println!</code> 调用了一个 Rust 宏（macro）。如果是调用函数，则应输入 <code>println</code>（没有<code>!</code>）。我们将在附录 D 中详细讨论宏。现在你只需记住，当看到符号 <code>!</code> 的时候，就意味着调用的是宏而不是普通函数。</p>
<p>第三，<code>&quot;Hello, world!&quot;</code> 是一个字符串。我们把这个字符串作为一个参数传递给 <code>println!</code>，字符串将被打印到屏幕上。</p>
<p>第四，该行以分号结尾（<code>;</code>），这代表一个表达式的结束和下一个表达式的开始。大部分 Rust 代码行以分号结尾。</p>
<a class="header" href="print.html#a编译和运行是彼此独立的步骤" id="a编译和运行是彼此独立的步骤"><h3>编译和运行是彼此独立的步骤</h3></a>
<p>你刚刚运行了一个新创建的程序，那么让我们检查此过程中的每一个步骤。</p>
<p>在运行 Rust 程序之前，必须先使用 Rust 编辑器编译它，即输入 <code>rustc</code> 命令并传入源文件名称，如下：</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>如果你有 C 或 C++ 背景，就会发现这与 <code>gcc</code> 和 <code>clang</code> 类似。编译成功后，Rust 会输出一个二进制的可执行文件。</p>
<p>在 Linux、macOS 或 Windows 的 PowerShell 上，在 shell 中输入 <code>ls</code> 命令就可看见这个可执行文件，如下：</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>在 Windows 的 CMD 上，则输入如下内容：</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>这展示了扩展名为 <em>.rs</em> 的源文件、可执行文件（在 Windows 下是 <em>main.exe</em>，其它平台是 <em>main</em>），以及当使用 CMD 时会有一个包含调试信息、扩展名为 <em>.pdb</em> 的文件。从这里开始运行 <em>main</em> 或 <em>main.exe</em> 文件，如下：</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
</code></pre>
<p>如果 <em>main.rs</em> 是上文所述的 Hello, world! 程序，它将会在终端上打印 <code>Hello, world!</code>。</p>
<p>如果你更熟悉动态语言，如 Ruby、Python 或 JavaScript，则可能不习惯将编译和运行分为两个单独的步骤。Rust 是一种 <strong>预编译静态类型</strong>（<em>ahead-of-time compiled</em>）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。如果你给他人一个 <em>.rb</em>、<em>.py</em> 或 <em>.js</em> 文件，他们需要先分别安装 Ruby，Python，JavaScript 实现（运行时环境，VM）。不过在这些语言中，只需要一句命令就可以编译和运行程序。这一切都是语言设计上的权衡取舍。</p>
<p>仅仅使用 <code>rustc</code> 编译简单程序是没问题的，不过随着项目的增长，你可能需要管理你项目的方方面面，并让代码易于分享。接下来，我们要介绍一个叫做 Cargo 的工具，它会帮助你编写真实世界中的 Rust 程序。</p>
<a class="header" href="print.html#hello-cargo" id="hello-cargo"><h2>Hello, Cargo!</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch01-03-hello-cargo.md">ch01-03-hello-cargo.md</a>
<br>
commit 7480e811ab5ad8d53a5b854d9b0c7a5a4f58499f</p>
</blockquote>
<p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。（我们把代码所需要的库叫做 <strong>依赖</strong>（<em>dependencies</em>））。</p>
<p>最简单的 Rust 程序，比如我们刚刚编写的，没有任何依赖。所以如果使用 Cargo 来构建 Hello, world! 项目，将只会用到 Cargo 的构建代码那部分功能。随着编写的 Rust 程序更加复杂，你会添加依赖，如果你一开始就使用 Cargo 的话，添加依赖将会变得简单许多。</p>
<p>由于绝大多数 Rust 项目使用 Cargo，本书接下来的部分假设你也使用 Cargo。如果使用 “安装” 章节介绍的官方安装包的话，则自带了 Cargo。如果通过其他方式安装的话，可以在终端输入如下命令检查是否安装了 Cargo：</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>如果你看到了版本号，说明已安装！如果看到类似 <code>command not found</code> 的错误，你应该查看相应安装文档以确定如何单独安装 Cargo。</p>
<a class="header" href="print.html#a使用-cargo-创建项目" id="a使用-cargo-创建项目"><h3>使用 Cargo 创建项目</h3></a>
<p>我们使用 Cargo 创建一个新项目，然后看看与上面的 Hello, world! 项目有什么不同。回到 <em>projects</em> 目录（或者你存放代码的目录）。接着，可在任何操作系统下运行以下命令：</p>
<pre><code class="language-text">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>第一行命令新建了名为 <em>hello_cargo</em> 的二进制可执行程序。为 <code>cargo new</code> 传入 <code>--bin</code> 参数会生成一个可执行程序（通常就叫做 <strong>二进制文件</strong>，<em>binary</em>），而不是一个库。项目被命名为 <code>hello_cargo</code>，同时 Cargo 在一个同名目录中创建项目文件。</p>
<p>进入 <em>hello_cargo</em> 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：一个 <em>Cargo.toml</em> 文件，一个 <em>src</em> 目录，以及位于 <em>src</em> 目录中 <em>main.rs</em> 文件。它也在 <em>hello_cargo</em> 目录初始化了一个 git 仓库，以及一个 <em>.gitignore</em> 文件。</p>
<blockquote>
<p>注意：Git 是一个常用的版本控制系统（version control system， VCS）。可以通过 <code>--vcs</code> 参数使 <code>cargo new</code> 切换到其它版本控制系统（VCS），或者不使用 VCS。运行 <code>cargo new --help</code> 参看可用的选项。</p>
</blockquote>
<p>请选用文本编辑器打开 <em>Cargo.toml</em> 文件。它应该看起来如示例 1-2 所示：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p><span class="caption">示例 1-2: <em>cargo new</em> 命令生成的 <em>Cargo.toml</em> 的内容</span></p>
<p>这个文件使用 <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom's Obvious, Minimal Language</em>) 格式，这是 Cargo 配置文件的格式。</p>
<p>第一行，<code>[package]</code>，是一个片段（section）标题，表明下面的语句用来配置一个包。随着我们在这个文件增加更多的信息，还将增加其他片段（section）。</p>
<p>接下来的三行设置了 Cargo 编译程序所需的配置：项目的名称、版本和作者。Cargo 从环境中获取你的名字和 email 信息，所以如果这些信息不正确，请修改并保存此文件。</p>
<p>最后一行，<code>[dependencies]</code>，是罗列项目依赖的片段。在 Rust 中，代码包被称为 <em>crates</em>。这个项目并不需要其他的 crate，不过在第二章的第一个项目会用到依赖，那时会用得上这个片段。</p>
<p>现在打开 <em>src/main.rs</em> 看看：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 为你生成了一个 Hello World! 程序，正如我们之前编写的示例 1-1！目前为止，之前项目与 Cargo 生成项目的区别是 Cargo 将代码放在 <em>src</em> 目录，同时项目根目录包含一个 <em>Cargo.toml</em> 配置文件。</p>
<p>Cargo 期望源文件存放在 <em>src</em> 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件。使用 Cargo 帮助你保持项目干净整洁，一切井井有条。</p>
<p>如果没有用 Cargo 开始项目，比如我们创建的 Hello,world! 项目，可以将其转化为一个 Cargo 项目。将代码放入 <em>src</em> 目录，并创建一个合适的 <em>Cargo.toml</em> 文件。</p>
<a class="header" href="print.html#a构建并运行-cargo-项目" id="a构建并运行-cargo-项目"><h3>构建并运行 Cargo 项目</h3></a>
<p>现在让我们看看通过 Cargo 构建和运行 Hello, world! 程序有什么不同！在 <em>hello_cargo</em> 目录下，输入下面的命令来构建项目：</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>这个命令会创建一个可执行文件 <em>target/debug/hello_cargo</em> （在 Windows 上是 <em>target\debug\hello_cargo.exe</em>），而不是放在目前目录下。可以通过这个命令运行可执行文件：</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>如果一切顺利，终端上应该会打印出 <code>Hello, world!</code>。首次运行 <code>cargo build</code> 时，也会使 Cargo 在项目根目录创建一个新文件：<em>Cargo.lock</em>。这个文件记录项目依赖的实际版本。这个项目并没有依赖，所以其内容比较少。你自己永远也不需要碰这个文件，让 Cargo 处理它就行了。</p>
<p>我们刚刚使用 <code>cargo build</code> 构建了项目，并使用 <code>./target/debug/hello_cargo</code> 运行了程序，也可以使用 <code>cargo run</code> 在一个命令中同时编译并运行生成的可执行文件：</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>注意这一次并没有出现表明 Cargo 正在编译 <code>hello_cargo</code> 的输出。Cargo 发现文件并没有被改变，就直接运行了二进制文件。如果修改了源文件的话，Cargo 会在运行之前重新构建项目，并会出现像这样的输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo 还提供了一个叫 <code>cargo check</code> 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件：</p>
<pre><code class="language-text">$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>为什么你会不需要可执行文件呢？通常 <code>cargo check</code> 要比 <code>cargo build</code> 快得多，因为它省略了生成可执行文件的步骤。如果编写代码时持续的进行检查，<code>cargo check</code> 会加速开发！为此很多 Rustaceans 编写代码时定期运行 <code>cargo check</code> 确保它们可以编译。当准备好使用可执行文件时才运行 <code>cargo build</code>。</p>
<p>我们回顾下已学习的 Cargo 内容：</p>
<ul>
<li>可以使用 <code>cargo build</code> 或 <code>cargo check</code> 构建项目。</li>
<li>可以使用 <code>cargo run</code> 一步构建并运行项目。</li>
<li>有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 <em>target/debug</em> 目录。</li>
</ul>
<p>使用 Cargo 的一个额外的优点是，不管你使用什么操作系统，其命令都是一样的。所以从此以后本书将不再为 Linux 和 macOS 以及 Windows 提供相应的命令。</p>
<a class="header" href="print.html#a发布release构建" id="a发布release构建"><h3>发布（release）构建</h3></a>
<p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来优化编译项目。这会在 <em>target/release</em> 而不是 <em>target/debug</em> 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要经常快速重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在测试代码的运行时间，请确保运行 <code>cargo build --release</code> 并使用 <em>target/release</em> 下的可执行文件进行测试。</p>
<a class="header" href="print.html#a把-cargo-当作习惯" id="a把-cargo-当作习惯"><h3>把 Cargo 当作习惯</h3></a>
<p>对于简单项目， Cargo 并不比 <code>rustc</code> 提供了更多的优势，不过随着开发的深入，终将证明其价值。对于拥有多个 crate 的复杂项目，交给 Cargo 来协调构建将简单的多。</p>
<p>即便 <code>hello_cargo</code> 项目十分简单，它现在也使用了很多在你之后的 Rust 生涯将会用到的实用工具。其实，要在任何已存在的项目上工作时，可以使用如下命令通过 Git 检出代码，移动到该项目目录并构建：</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>关于更多 Cargo 的信息，请查阅 <a href="https://doc.rust-lang.org/cargo/">其文档</a>。</p>
<a class="header" href="print.html#a总结" id="a总结"><h2>总结</h2></a>
<p>你已经踏上了 Rust 之旅！在本章中，你学习了如何：</p>
<ul>
<li>使用 <code>rustup</code> 安装最新稳定版的 Rust</li>
<li>更新到新版的 Rust</li>
<li>打开本地安装的文档</li>
<li>直接通过 <code>rustc</code> 编写并运行 Hello, world! 程序</li>
<li>使用 Cargo 创建并运行新项目</li>
</ul>
<p>是时候通过构建更真实的程序来熟悉读写 Rust 代码了。所以在下一章，我们会构建一个猜猜看游戏程序。如果你更愿意从学习 Rust 常用的编程概念开始，请阅读第三章，接着再回到第二章。</p>
<a class="header" href="print.html#a编写-猜猜看-游戏" id="a编写-猜猜看-游戏"><h1>编写 猜猜看 游戏</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch02-00-guessing-game-tutorial.md">ch02-00-guessing-game-tutorial.md</a>
<br>
commit 7480e811ab5ad8d53a5b854d9b0c7a5a4f58499f</p>
</blockquote>
<p>让我们一起动手完成一个项目，来快速上手 Rust！本章将介绍 Rust 中一些常用概念，并通过真实的程序来展示如何运用它们。你将会学到 <code>let</code>、<code>match</code>、方法、关联函数、外部 crate 等知识！后续章节会深入探讨这些概念的细节。在这一章，我们将做基础练习。</p>
<p>我们会实现一个经典的新手编程问题：猜猜看游戏。它是这么工作的：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜对了，它会打印祝贺信息并退出。</p>
<a class="header" href="print.html#a准备一个新项目" id="a准备一个新项目"><h2>准备一个新项目</h2></a>
<p>要创建一个新项目，进入第一章中创建的 <em>projects</em> 目录，使用 Cargo 新建一个项目，如下：</p>
<pre><code class="language-text">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>第一个命令，<code>cargo new</code>，它获取项目的名称（<code>guessing_game</code>）作为第一个参数。<code>--bin</code> 参数告诉 Cargo 创建一个二进制项目，与第一章类似。第二个命令进入到新创建的项目目录。</p>
<p>看看生成的 <em>Cargo.toml</em> 文件：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>如果 Cargo 从环境中获取的开发者信息不正确，修改这个文件并再次保存。</p>
<p>正如第一章那样，<code>cargo new</code> 生成了一个 “Hello, world!” 程序。查看 <em>src/main.rs</em> 文件：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>现在使用 <code>cargo run</code> 命令，一步完成 “Hello, world!” 程序的编译和运行：</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>当你需要在项目中快速迭代时，<code>run</code> 命令就能派上用场，正如我们在这个游戏项目中做的，在下一次迭代之前快速测试每一次迭代。</p>
<p>重新打开 <em>src/main.rs</em> 文件。我们将会在这个文件中编写全部的代码。</p>
<a class="header" href="print.html#a处理一次猜测" id="a处理一次猜测"><h2>处理一次猜测</h2></a>
<p>猜猜看程序的第一部分请求和处理用户输入，并检查输入是否符合预期的格式。首先，允许玩家输入猜测。在 <em>src/main.rs</em> 中输入示例 2-1 中的代码。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">示例 2-1：获取用户猜测并打印的代码</span></p>
<p>这些代码包含很多信息，我们一行一行地过一遍。为了获取用户输入并打印结果作为输出，我们需要将 <code>io</code>（输入/输出）库引入当前作用域。<code>io</code> 库来自于标准库（也被称为 <code>std</code>）：</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>默认情况下，Rust 将 <a href="https://doc.rust-lang.org/std/prelude/index.html"><em>prelude</em></a><!-- ignore --> 模块中少量的类型引入到每个程序的作用域中。如果需要的类型不在 prelude 中，你必须使用 <code>use</code> 语句显式地将其引入作用域。<code>std::io</code> 库提供很多有用的功能，包括接收用户输入的功能。</p>
<p>如第一章所提及，<code>main</code> 函数是程序的入口点：</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p><code>fn</code> 语法声明了一个新函数，<code>()</code> 表明没有参数，<code>{</code> 作为函数体的开始。</p>
<p>第一章也提及了 <code>println!</code> 是一个在屏幕上打印字符串的宏：</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>这些代码仅仅打印提示，介绍游戏的内容然后请求用户输入。</p>
<a class="header" href="print.html#a使用变量储存值" id="a使用变量储存值"><h3>使用变量储存值</h3></a>
<p>接下来，创建一个储存用户输入的地方，像这样：</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<p>现在程序开始变得有意思了！这一小行代码发生了很多事。注意这是一个 <code>let</code> 语句，用来创建 <strong>变量</strong>。这里是另外一个例子：</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>这行代码新建了一个叫做 <code>foo</code> 的变量并把它绑定到值 <code>bar</code> 上。在 Rust 中，变量默认是不可变的。我们将会在第三章的 “变量与可变性” 部分详细讨论这个概念。下面的例子展示了如何在变量名前使用 <code>mut</code> 来使一个变量可变：</p>
<pre><code class="language-rust ignore">let foo = 5; // immutable
let mut bar = 5; // mutable
</code></pre>
<blockquote>
<p>注意：<code>//</code> 语法开始一个注释，持续到行尾。Rust 忽略注释中的所有内容，将在第三章中详细介绍注释。</p>
</blockquote>
<p>让我们回到猜猜看程序中。现在我们知道了 <code>let mut guess</code> 会引入一个叫做 <code>guess</code> 的可变变量。等号（<code>=</code>）的右边是 <code>guess</code> 所绑定的值，它是 <code>String::new</code> 的结果，这个函数会返回一个 <code>String</code> 的新实例。<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> 是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。</p>
<p><code>::new</code> 那一行的 <code>::</code> 语法表明 <code>new</code> 是 <code>String</code> 类型的一个 <strong>关联函数</strong>（<em>associated function</em>）。关联函数是针对类型实现的，在这个例子中是 <code>String</code>，而不是 <code>String</code> 的某个特定实例。一些语言中把它称为 <strong>静态方法</strong>（<em>static method</em>）。</p>
<p><code>new</code> 函数创建了一个新的空字符串，你会发现很多类型上有 <code>new</code> 函数，因为它是创建类型实例的惯用函数名。</p>
<p>总结一下，<code>let mut guess = String::new();</code> 这一行创建了一个可变变量，当前它绑定到一个新的 <code>String</code> 空实例上。</p>
<p>回忆一下，我们在程序的第一行使用 <code>use std::io;</code> 从标准库中引入了输入/输出功能。现在调用 <code>io</code> 的关联函数 <code>stdin</code>：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>如果程序的开头没有 <code>use std::io</code> 这一行，可以把函数调用写成 <code>std::io::stdin</code>。<code>stdin</code> 函数返回一个 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore --> 的实例，这代表终端标准输入句柄的类型。</p>
<p>代码的下一部分，<code>.read_line(&amp;mut guess)</code>，调用 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> 方法从标准输入句柄获取用户输入。我们还向 <code>read_line()</code> 传递了一个参数：<code>&amp;mut guess</code>。</p>
<p><code>read_line</code> 的工作是，无论用户在标准输入中键入什么内容，都将其存入一个字符串中，因此它需要字符串作为参数。这个字符串参数应该是可变的，以便 <code>read_line</code> 将用户输入附加上去。</p>
<p><code>&amp;</code> 表示这个参数是一个 <strong>引用</strong>（<em>reference</em>），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。完成当前程序并不需要了解如此多细节。现在，我们只需知道它像变量一样，默认是不可变的。因此，需要写成 <code>&amp;mut guess</code> 来使其可变，而不是 <code>&amp;guess</code>。（第四章会更全面的解释引用。）</p>
<a class="header" href="print.html#a使用-result-类型来处理潜在的错误" id="a使用-result-类型来处理潜在的错误"><h3>使用 <code>Result</code> 类型来处理潜在的错误</h3></a>
<p>我们还没有完全分析完这行代码。虽然这是单独一行代码，但它是一个逻辑行（虽然换行了但仍是一个语句）的第一部分。第二部分是这个方法：</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p>当使用 <code>.foo()</code> 语法调用方法时，通过换行加缩进来把长行拆开是明智的。我们完全可以这样写：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>不过，过长的行难以阅读，所以最好拆开来写，两个方法调用占两行。现在来看看这行代码干了什么。</p>
<p>之前提到了 <code>read_line</code> 将用户输入附加到传递给它的字符串中，不过它也返回一个值——在这个例子中是 <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->。Rust 标准库中有很多叫做 <code>Result</code> 的类型。一个 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> 泛型以及对应子模块的特定版本，比如 <code>io::Result</code>。</p>
<p><code>Result</code> 类型是 <a href="ch06-00-enums.html"><em>枚举</em>（<em>enumerations</em>）</a><!-- ignore -->，通常也写作 <em>enums</em>。枚举类型持有固定集合的值，这些值被称为枚举的 <strong>成员</strong>（<em>variants</em>）。第六章将介绍枚举的更多细节。</p>
<p><code>Result</code> 的成员是 <code>Ok</code> 和 <code>Err</code>，<code>Ok</code> 成员表示操作成功，内部包含成功时产生的值。<code>Err</code> 成员则意味着操作失败，并且包含失败的前因后果。</p>
<p>这些 <code>Result</code> 类型的作用是编码错误处理信息。<code>Result</code> 类型的值，像其他类型一样，拥有定义于其上的方法。<code>io::Result</code> 的实例拥有 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code> 方法</a><!-- ignore -->。如果 <code>io::Result</code> 实例的值是 <code>Err</code>，<code>expect</code> 会导致程序崩溃，并显示当做参数传递给 <code>expect</code> 的信息。如果 <code>read_line</code> 方法返回 <code>Err</code>，则可能是来源于底层操作系统错误的结果。如果 <code>io::Result</code> 实例的值是 <code>Ok</code>，<code>expect</code> 会获取 <code>Ok</code> 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。</p>
<p>如果不调用 <code>expect</code>，程序也能编译，不过会出现一个警告：</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust 警告我们没有使用 <code>read_line</code> 的返回值 <code>Result</code>，说明有一个可能的错误没有处理。</p>
<p>消除警告的正确做法是实际编写错误处理代码，不过由于我们就是希望程序在出现问题时立即崩溃，所以直接使用 <code>expect</code>。第九章会学习如何从错误中恢复。</p>
<a class="header" href="print.html#a使用-println-占位符打印值" id="a使用-println-占位符打印值"><h3>使用 <code>println!</code> 占位符打印值</h3></a>
<p>除了位于结尾的大括号，目前为止就只有一行代码值得讨论一下了，就是这一行：</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<p>这行代码打印存储用户输入的字符串。第一个参数是格式化字符串，里面的 <code>{}</code> 是预留在特定位置的占位符。使用 <code>{}</code> 也可以打印多个值：第一对 <code>{}</code> 使用格式化字符串之后的第一个值，第二对则使用第二个值，依此类推。调用一次 <code>println!</code> 打印多个值看起来像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
#}</code></pre></pre>
<p>这行代码会打印出 <code>x = 5 and y = 10</code>。</p>
<a class="header" href="print.html#a测试第一部分代码" id="a测试第一部分代码"><h3>测试第一部分代码</h3></a>
<p>让我们来测试下猜猜看游戏的第一部分。使用 <code>cargo run</code> 运行：</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>至此为止，游戏的第一部分已经完成：我们从键盘获取输入并打印了出来。</p>
<a class="header" href="print.html#a生成一个秘密数字" id="a生成一个秘密数字"><h2>生成一个秘密数字</h2></a>
<p>接下来，需要生成一个秘密数字，好让用户来猜。秘密数字应该每次都不同，这样重复玩才不会乏味；范围应该在 1 到 100 之间，这样才不会太困难。Rust 标准库中尚未包含随机数功能。然而，Rust 团队还是提供了一个 <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>。</p>
<a class="header" href="print.html#a使用-crate-来增加更多功能" id="a使用-crate-来增加更多功能"><h3>使用 crate 来增加更多功能</h3></a>
<p>记住，<em>crate</em> 是一个 Rust 代码包。我们正在构建的项目是一个 <strong>二进制 crate</strong>，它生成一个可执行文件。 <code>rand</code> crate 是一个 <strong>库 crate</strong>，库 crate 可以包含任意能被其他程序使用的代码。</p>
<p>Cargo 对外部 crate 的运用是其真正闪光的地方。在我们使用 <code>rand</code> 编写代码之前，需要修改 <em>Cargo.toml</em> 文件，引入一个 <code>rand</code> 依赖。现在打开这个文件并在底部的 <code>[dependencies]</code> 片段标题之下添加：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>在 <em>Cargo.toml</em> 文件中，标题以及之后的内容属同一个片段，直到遇到下一个标题才开始新的片段。<code>[dependencies]</code> 片段告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。本例中，我们使用语义化版本 <code>0.3.14</code> 来指定 <code>rand</code> crate。Cargo 理解<a href="http://semver.org">语义化版本（Semantic Versioning）</a><!-- ignore -->（有时也称为 <em>SemVer</em>），这是一种定义版本号的标准。<code>0.3.14</code> 事实上是 <code>^0.3.14</code> 的简写，它表示 “任何与 0.3.14 版本公有 API 相兼容的版本”。</p>
<p>现在，不修改任何代码，构建项目，如示例 2-2 所示：</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">示例 2-2: 将 rand crate 添加为依赖之后运行 <code>cargo build</code> 的输出</span></p>
<p>可能会出现不同的版本号（多亏了语义化版本，它们与代码是兼容的！），同时显示顺序也可能会有所不同。</p>
<p>现在我们有了一个外部依赖，Cargo 从 <em>registry</em> 上获取所有包的最新版本信息，这是一份来自 <a href="https://crates.io">Crates.io</a> 的数据拷贝。Crates.io 是 Rust 生态环境中的开发者们向他人贡献 Rust 开源项目的地方。</p>
<p>在更新完 registry 后，Cargo 检查 <code>[dependencies]</code> 片段并下载缺失的 crate 。本例中，虽然只声明了 <code>rand</code> 一个依赖，然而 Cargo 还是额外获取了 <code>libc</code> 的拷贝，因为 <code>rand</code> 依赖 <code>libc</code> 来正常工作。下载完成后，Rust 编译依赖，然后使用这些依赖编译项目。</p>
<p>如果不做任何修改，立刻再次运行 <code>cargo build</code>，则不会看到任何除了 <code>Finished</code> 完成提示之外的输出。Cargo 知道它已经下载并编译了依赖，同时 <em>Cargo.toml</em> 文件也没有变动。Cargo 还知道代码也没有任何修改，所以它不会重新编译代码。因为无事可做，它简单的退出了。</p>
<p>如果打开 <em>src/main.rs</em> 文件，做一些无关紧要的修改，保存并再次构建，只会出现两行输出：</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>这一行表示 Cargo 只针对 <em>src/main.rs</em> 文件的微小修改而更新构建。依赖没有变化，所以 Cargo 知道它可以复用已经为此下载并编译的代码。它只是重新构建了部分（项目）代码。</p>
<a class="header" href="print.html#cargolock-文件确保构建是可重现的" id="cargolock-文件确保构建是可重现的"><h4><em>Cargo.lock</em> 文件确保构建是可重现的</h4></a>
<p>Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。例如，如果下周 <code>rand</code> crate 的 <code>0.3.15</code> 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷，这时会发生什么呢？</p>
<p>这个问题的答案是 <em>Cargo.lock</em> 文件。它在第一次运行 <code>cargo build</code> 时创建，并放在 <em>guessing_game</em> 目录。当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 <em>Cargo.lock</em> 文件。当将来构建项目时，Cargo 会发现 <em>Cargo.lock</em> 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 <code>0.3.14</code> 直到你显式升级，感谢 <em>Cargo.lock</em> 文件。</p>
<a class="header" href="print.html#a更新-crate-到一个新版本" id="a更新-crate-到一个新版本"><h4>更新 crate 到一个新版本</h4></a>
<p>当你 <strong>确实</strong> 需要升级 crate 时，Cargo 提供了另一个命令，<code>update</code>，它会忽略 <em>Cargo.lock</em> 文件，并计算出所有符合 <em>Cargo.toml</em> 声明的最新版本。如果成功了，Cargo 会把这些版本写入 <em>Cargo.lock</em> 文件。</p>
<p>不过，Cargo 默认只会寻找大于 <code>0.3.0</code> 而小于 <code>0.4.0</code> 的版本。如果 <code>rand</code> crate 发布了两个新版本，<code>0.3.15</code> 和 <code>0.4.0</code>，在运行 <code>cargo update</code> 时会出现如下内容：</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>这时，你也会注意到的 <em>Cargo.lock</em> 文件中的变化无外乎现在使用的 <code>rand</code> crate 版本是<code>0.3.15</code></p>
<p>如果想要使用 <code>0.4.0</code> 版本的 <code>rand</code> 或是任何 <code>0.4.x</code> 系列的版本，必须像这样更新 <em>Cargo.toml</em> 文件：</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>下一次运行 <code>cargo build</code> 时，Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。</p>
<p>第十四章会讲到 <a href="http://doc.crates.io">Cargo</a><!-- ignore --> 及其<a href="http://doc.crates.io/crates-io.html">生态系统</a><!-- ignore -->的更多内容，不过目前你只需要了解这么多。通过 Cargo 复用库文件非常容易，因此 Rustacean 能够编写出由很多包组装而成的更轻巧的项目。</p>
<a class="header" href="print.html#a生成一个随机数" id="a生成一个随机数"><h3>生成一个随机数</h3></a>
<p>你已经把 <code>rand</code> crate 添加到 <em>Cargo.toml</em> 了，让我们开始 <strong>使用</strong> <code>rand</code> 吧。下一步是更新 <em>src/main.rs</em>，如示例 2-3 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">示例 2-3：添加生成随机数的代码</span></p>
<p>首先，这里在顶部增加一行 <code>extern crate rand;</code> 通知 Rust 我们要使用外部依赖 <code>rand</code>。这也会调用相应的 <code>use rand</code>，所以现在可以使用 <code>rand::</code> 前缀来调用 <code>rand</code> crate 中的任何内容。</p>
<p>接下来增加了另一行 <code>use</code>：<code>use rand::Rng</code>。<code>Rng</code> 是一个 trait，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 trait 必须在作用域中。第十章会详细介绍 trait。</p>
<p>另外，中间还新增加了两行。<code>rand::thread_rng</code> 函数提供实际使用的随机数生成器：它位于当前执行线程本地，并从操作系统获取 seed。接下来，调用随机数生成器的 <code>gen_range</code> 方法。这个方法由刚才引入到作用域的 <code>Rng</code> trait 定义。<code>gen_range</code> 方法获取两个数字作为参数，并生成一个范围在两者之间的随机数。它包含下限但不包含上限，所以需要指定 <code>1</code> 和 <code>101</code> 来请求一个 1 和 100 之间的数。</p>
<blockquote>
<p>注意：你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法。crate 的使用说明位于其文档中。Cargo 有一个很棒的功能是：运行 <code>cargo doc --open</code> 命令来构建所有本地依赖提供的文档，并在浏览器中打开。例如，假设你对 <code>rand</code> crate 中的其他功能感兴趣，你可以运行 <code>cargo doc --open</code> 并点击左侧导航栏中的 <code>rand</code>。</p>
</blockquote>
<p>新增加的第二行代码打印出了秘密数字。这在开发程序时很有用，因为可以测试它，不过在最终版本中会删掉它。游戏一开始就打印出结果就没什么可玩的了！</p>
<p>尝试运行程序几次：</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>你应该能得到不同的随机数，同时它们应该都是在 1 和 100 之间的。干得漂亮！</p>
<a class="header" href="print.html#a比较猜测的数字和秘密数字" id="a比较猜测的数字和秘密数字"><h2>比较猜测的数字和秘密数字</h2></a>
<p>现在有了用户输入和一个随机数，我们可以比较它们。这个步骤如示例 2-4 所示。注意这段代码还不能通过编译，我们稍后会解释。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">示例 2-4：处理比较两个数字可能的返回值</span></p>
<p>新代码的第一行是另一个 <code>use</code>，从标准库引入了一个叫做 <code>std::cmp::Ordering</code> 的类型。同 <code>Result</code> 一样， <code>Ordering</code> 也是一个枚举，不过它的成员是 <code>Less</code>、<code>Greater</code> 和 <code>Equal</code>。这是比较两个值时可能出现的三种结果。</p>
<p>接着，底部的五行新代码使用了 <code>Ordering</code> 类型，<code>cmp</code> 方法用来比较两个值并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 <code>guess</code> 与 <code>secret_number</code> 做比较。 然后它会返回一个刚才通过 <code>use</code> 引入作用域的 <code>Ordering</code> 枚举的成员。使用一个 <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> 表达式，根据对 <code>guess</code> 和 <code>secret_number</code> 调用 <code>cmp</code> 返回的 <code>Ordering</code> 成员来决定接下来做什么。</p>
<p>一个 <code>match</code> 表达式由 <strong>分支（arms）</strong> 构成。一个分支包含一个 <strong>模式</strong>（<em>pattern</em>）和表达式开头的值与分支模式相匹配时应该执行的代码。Rust 获取提供给 <code>match</code> 的值并挨个检查每个分支的模式。<code>match</code> 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并帮助你确保没有遗漏处理。这些功能将分别在第六章和第十八章详细介绍。</p>
<p>让我们看看使用 <code>match</code> 表达式的例子。假设用户猜了 50，这时随机生成的秘密数字是 38。比较 50 与 38 时，因为 50 比 38 要大，<code>cmp</code> 方法会返回 <code>Ordering::Greater</code>。<code>Ordering::Greater</code> 是 <code>match</code> 表达式得到的值。它检查第一个分支的模式，<code>Ordering::Less</code> 与 <code>Ordering::Greater</code>并不匹配，所以它忽略了这个分支的代码并来到下一个分支。下一个分支的模式是 <code>Ordering::Greater</code>，<strong>正确</strong> 匹配！这个分支关联的代码被执行，在屏幕打印出 <code>Too big!</code>。<code>match</code> 表达式就此终止，因为该场景下没有检查最后一个分支的必要。</p>
<p>然而，示例 2-4 的代码并不能编译，可以尝试一下：</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>错误的核心表明这里有 <strong>不匹配的类型</strong>（<em>mismatched types</em>）。Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 <code>let guess = String::new()</code> 时，Rust 推断出 <code>guess</code> 应该是 <code>String</code> 类型，并不需要我们写出类型。另一方面，<code>secret_number</code>，是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 <code>i32</code>；32 位无符号数字 <code>u32</code>；64 位数字 <code>i64</code> 等等。Rust 默认使用 <code>i32</code>，所以它是 <code>secret_number</code> 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。这里错误的原因在于 Rust 不会比较字符串类型和数字类型。</p>
<p>所以我们必须把从输入中读取到的 <code>String</code> 转换为一个真正的数字类型，才好与秘密数字进行比较。这可以通过在 <code>main</code> 函数体中增加如下两行代码来实现：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>这两行新代码是：</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>这里创建了一个叫做 <code>guess</code> 的变量。不过等等，不是已经有了一个叫做 <code>guess</code> 的变量了吗？确实如此，不过 Rust 允许用一个新值来 <strong>隐藏</strong> （<em>shadow</em>） <code>guess</code> 之前的值。这个功能常用在需要转换值类型之类的场景。它允许我们复用 <code>guess</code> 变量的名字，而不是被迫创建两个不同变量，诸如 <code>guess_str</code> 和 <code>guess</code> 之类。（第三章会介绍 shadowing 的更多细节。）</p>
<p>我们将 <code>guess</code> 绑定到 <code>guess.trim().parse()</code> 表达式上。表达式中的 <code>guess</code> 是包含输入的原始 <code>String</code> 类型。<code>String</code> 实例的 <code>trim</code> 方法会去除字符串开头和结尾的空白字符。<code>u32</code> 只能由数字字符转换，不过用户必须输入 <span class="keystroke">return</span> 键才能让 <code>read_line</code> 返回，然而用户按下 <span class="keystroke">return</span> 键时，会在字符串中增加一个换行（newline）符。例如，用户输入 <span class="keystroke">5</span> 并按下 <span class="keystroke">return</span>，<code>guess</code> 看起来像这样：<code>5\n</code>。<code>\n</code> 代表 “换行”，回车键。<code>trim</code> 方法消除 <code>\n</code>，只留下<code>5</code>。</p>
<p><a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">字符串的 <code>parse</code> 方法</a><!-- ignore --> 将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 <code>let guess: u32</code> 指定。<code>guess</code> 后面的冒号（<code>:</code>）告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型；<code>u32</code> 是一个无符号的 32 位整型。对于不大的正整数来说，它是不错的类型，第三章还会讲到其他数字类型。另外，程序中的 <code>u32</code> 注解以及与 <code>secret_number</code> 的比较，意味着 Rust 会推断出 <code>secret_number</code> 也是 <code>u32</code> 类型。现在可以使用相同类型比较两个值了！</p>
<p><code>parse</code> 调用很容易产生错误。例如，字符串中包含 <code>A👍%</code>，就无法将其转换为一个数字。因此，<code>parse</code> 方法返回一个 <code>Result</code> 类型。像之前 “使用 <code>Result</code> 类型来处理潜在的错误” 讨论的 <code>read_line</code> 方法那样，再次按部就班的用 <code>expect</code> 方法处理即可。如果 <code>parse</code> 不能从字符串生成一个数字，返回一个 <code>Result::Err</code> 时，<code>expect</code> 会使游戏崩溃并打印附带的信息。如果 <code>parse</code> 成功地将字符串转换为一个数字，它会返回 <code>Result::Ok</code>，然后 <code>expect</code> 会返回 <code>Ok</code> 中的数字。</p>
<p>现在让我们运行程序！</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>漂亮！即便是在猜测之前添加了空格，程序依然能判断出用户猜测了 76。多运行程序几次，输入不同的数字来检验不同的行为：猜一个正确的数字，猜一个过大的数字和猜一个过小的数字。</p>
<p>现在游戏已经大体上能玩了，不过用户只能猜一次。增加一个循环来改变它吧！</p>
<a class="header" href="print.html#a使用循环来允许多次猜测" id="a使用循环来允许多次猜测"><h2>使用循环来允许多次猜测</h2></a>
<p><code>loop</code> 关键字创建了一个无限循环。将其加入后，用户可以反复猜测：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>如上所示，我们将提示用户猜测之后的所有内容放入了循环。确保 loop 循环中的代码多缩进四个空格，再次运行程序。注意这里有一个新问题，因为程序忠实地执行了我们的要求：永远地请求另一个猜测，用户好像没法退出啊！</p>
<p>用户总能使用 <span class="keystroke">ctrl-c</span> 终止程序。不过还有另一个方法跳出无限循环，就是 “比较猜测与秘密数字” 部分提到的 <code>parse</code>：如果用户输入的答案不是一个数字，程序会崩溃。用户可以利用这一点来退出，如下所示：</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p>输入 <code>quit</code> 确实退出了程序，同时其他任何非数字输入也一样。然而，这并不理想，我们想要当猜测正确的数字时游戏能自动退出。</p>
<a class="header" href="print.html#a猜测正确后退出" id="a猜测正确后退出"><h3>猜测正确后退出</h3></a>
<p>让我们增加一个 <code>break</code>，在用户猜对时退出游戏：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>通过在 <code>You win!</code> 之后增加一行 <code>break</code>，用户猜对了神秘数字后会退出循环。退出循环也意味着退出程序，因为循环是 <code>main</code> 的最后一部分。</p>
<a class="header" href="print.html#a处理无效输入" id="a处理无效输入"><h3>处理无效输入</h3></a>
<p>为了进一步改善游戏性，不要在用户输入非数字时崩溃，需要忽略非数字，让用户可以继续猜测。可以通过修改 <code>guess</code> 将 <code>String</code> 转化为 <code>u32</code> 那部分代码来实现，如示例 2-5 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);

let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};

println!(&quot;You guessed: {}&quot;, guess);

// --snip--
</code></pre>
<p><span class="caption">示例 2-5: 忽略非数字的猜测并重新请求数字而不是让程序崩溃</span></p>
<p>将 <code>expect</code> 调用换成 <code>match</code> 语句，是从遇到错误就崩溃转换到真正处理错误的惯用方法。须知 <code>parse</code> 返回一个 <code>Result</code> 类型，而 <code>Result</code> 是一个拥有 <code>Ok</code> 或 <code>Err</code> 成员的枚举。这里使用的 <code>match</code> 表达式，和之前处理 <code>cmp</code> 方法返回 <code>Ordering</code> 时用的一样。</p>
<p>如果 <code>parse</code> 能够成功的将字符串转换为一个数字，它会返回一个包含结果数字的 <code>Ok</code>。这个 <code>Ok</code> 值与 <code>match</code> 第一个分支的模式相匹配，该分支对应的动作返回 <code>Ok</code> 值中的数字 <code>num</code>，最后如愿变成新创建的 <code>guess</code> 变量。</p>
<p>如果 <code>parse</code> <em>不</em> 能将字符串转换为一个数字，它会返回一个包含更多错误信息的 <code>Err</code>。<code>Err</code> 值不能匹配第一个 <code>match</code> 分支的 <code>Ok(num)</code> 模式，但是会匹配第二个分支的 <code>Err(_)</code> 模式：<code>_</code> 是一个通配符值，本例中用来匹配所有 <code>Err</code> 值，不管其中有何种信息。所以程序会执行第二个分支的动作，<code>continue</code> 意味着进入 <code>loop</code> 的下一次循环，请求另一个猜测。这样程序就有效的忽略了 <code>parse</code> 可能遇到的所有错误！</p>
<p>现在万事俱备，只需运行 <code>cargo run</code>：</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>太棒了！再有最后一个小的修改，就能完成猜猜看游戏了：还记得程序依然会打印出秘密数字。在测试时还好，但正式发布时会毁了游戏。删掉打印秘密数字的 <code>println!</code>。示例 2-6 为最终代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">示例 2-6：猜猜看游戏的完整代码</span></p>
<a class="header" href="print.html#a总结-1" id="a总结-1"><h2>总结</h2></a>
<p>此时此刻，你顺利完成了猜猜看游戏。恭喜！</p>
<p>本项目通过动手实践，向你介绍了 Rust 新概念：<code>let</code>、<code>match</code>、方法、关联函数、使用外部 crate 等等，接下来的几章，你会继续深入学习这些概念。第三章介绍大部分编程语言都有的概念，比如变量、数据类型和函数，以及如何在 Rust 中使用它们。第四章探索所有权（ownership），这是一个 Rust 同其他语言大不相同的功能。第五章讨论结构体和方法的语法，而第六章侧重解释枚举。</p>
<a class="header" href="print.html#a通用编程概念" id="a通用编程概念"><h1>通用编程概念</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch03-00-common-programming-concepts.md">ch03-00-common-programming-concepts.md</a>
<br>
commit b64de01431cdf1020ad3358d2f83e46af68a39ed</p>
</blockquote>
<p>本章介绍一些几乎所有编程语言都有的概念，以及它们在 Rust 中是如何工作的。很多编程语言的核心概念都是共通的，本章中展示的概念都不是 Rust 所特有的，不过我们会在 Rust 上下文中讨论它们，并解释使用这些概念的惯例。</p>
<p>具体来说，我们将会学习变量、基本类型、函数、注释和控制流。每一个 Rust 程序中都会用到这些基础知识，提早学习这些概念会让你在起步时就打下坚实的基础。</p>
<blockquote>
<a class="header" href="print.html#a关键字" id="a关键字"><h3>关键字</h3></a>
<p>Rust 语言有一组保留的 <strong>关键字</strong>（<em>keywords</em>），就像大部分语言一样，它们只能由语言本身使用。记住，你不能使用这些关键字作为变量或函数的名称。大部分关键字有特殊的意义，你将在你的 Rust 程序中使用它们完成各种任务；一些关键字目前没有相应的功能，是为将来可能添加的功能保留的。可以在附录 A 中找到关键字的列表。</p>
</blockquote>
<a class="header" href="print.html#a变量和可变性" id="a变量和可变性"><h2>变量和可变性</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch03-01-variables-and-mutability.md">ch03-01-variables-and-mutability.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>第二章中提到过，变量默认是不可改变的（immutable）。这是推动你以充分利用 Rust 提供的安全性和简单并发性编写代码的众多方式之一。不过，你仍然可以使用可变变量。让我们探讨一下 Rust 拥抱不可变性的原因及方法，以及何时你不想使用不可变性。</p>
<p>当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。为了对此进行说明，使用 <code>cargo new --bin variables</code> 命令在 <em>projects</em> 目录生成一个叫做 <em>variables</em> 的新项目。</p>
<p>接着，在新建的 <em>variables</em> 目录，打开 <em>src/main.rs</em> 并将代码替换为如下代码，这些代码还不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>保存并使用 <code>cargo run</code> 运行程序。应该会看到一条错误信息，如下输出所示：</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>这个例子展示了编译器如何帮助你找出程序中的错误。虽然编译错误令人沮丧，但那只是表示程序不能安全的完成你想让它完成的工作；并 <strong>不能</strong> 说明你不是一个好程序员！经验丰富的 Rustacean 们一样会遇到编译错误。</p>
<p>错误信息指出错误的原因是 <code>不能对不可变变量 x 二次赋值</code>（<code>cannot assign twice to immutable variable x</code>），因为你尝试对不可变变量 <code>x</code> 赋第二个值。</p>
<p>在尝试改变预设为不可变的值时，产生编译时错误是很重要的，因为这种情况可能导致 bug。如果一部分代码假设一个值永远也不会改变，而另一部分代码改变了这个值，第一部分代码就有可能以不可预料的方式运行。不得不承认这种 bug 的起因难以跟踪，尤其是第二部分代码只是 <strong>有时</strong> 会改变值。</p>
<p>Rust 编译器保证，如果声明一个值不会变，它就真的不会变。这意味着当阅读和编写代码时，不需要追踪一个值如何以及哪里可能会被改变，从而使得代码易于推导。</p>
<p>不过可变性也是非常有用的。变量只是默认不可变；正如在第二章所做的那样，你可以在变量名之前加 <code>mut</code> 来使其可变。除了允许改变值之外，<code>mut</code> 向读者表明了其他代码将会改变这个变量值的意图。</p>
<p>例如，让我们将 <em>src/main.rs</em> 修改为如下代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>现在运行这个程序，出现如下内容：</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>通过 <code>mut</code>，允许把绑定到 <code>x</code> 的值从 <code>5</code> 改成 <code>6</code>。在一些情况下，你会想用可变变量，因为与只用不可变变量相比，它会让代码更容易编写。</p>
<p>除了防止出现 bug 外，还有很多地方需要权衡取舍。例如，使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。</p>
<a class="header" href="print.html#a变量和常量的区别" id="a变量和常量的区别"><h3>变量和常量的区别</h3></a>
<p>不允许改变值的变量，可能会使你想起另一个大部分编程语言都有的概念：<strong>常量</strong>（<em>constants</em>）。类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p>
<p>首先，不允许对常量使用 <code>mut</code>。常量不光默认不能变，它总是不能变。</p>
<p>声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。在下一部分，“数据类型” 中会介绍类型和类型注解，现在无需关心这些细节，记住总是标注类型即可。</p>
<p>常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。</p>
<p>最后一个区别是，常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。</p>
<p>这是一个声明常量的例子，它的名称是 <code>MAX_POINTS</code>，值是 100,000。（Rust 常量的命名规范是使用下划线分隔的大写字母）：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const MAX_POINTS: u32 = 100_000;
#}</code></pre></pre>
<p>在声明它的作用域之中，常量在整个程序生命周期中都有效，这使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。</p>
<p>将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。</p>
<a class="header" href="print.html#a隐藏shadowing" id="a隐藏shadowing"><h3>隐藏（Shadowing）</h3></a>
<p>正如在第二章猜猜看游戏的 “比较猜测的数字和秘密数字” 中所讲，我们可以定义一个与之前变量同名的新变量，而新变量会 <strong>隐藏</strong> 之前的变量。Rustacean 们称之为第一个变量被第二个 <strong>隐藏</strong> 了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 <code>let</code> 关键字来多次隐藏，如下所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>这个程序首先将 <code>x</code> 绑定到值 <code>5</code> 上。接着通过 <code>let x =</code> 隐藏 <code>x</code>，获取初始值并加 <code>1</code>，这样 <code>x</code> 的值就变成 <code>6</code> 了。第三个 <code>let</code> 语句也隐藏了 <code>x</code>，将之前的值乘以 <code>2</code>，<code>x</code> 最终的值是 <code>12</code>。运行这个程序，它会有如下输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
</code></pre>
<p>隐藏与将变量标记为 <code>mut</code> 是有区别的。当不小心尝试对变量重新赋值时，如果没有使用 <code>let</code> 关键字，就会导致编译时错误。通过使用 <code>let</code>，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不变的。</p>
<p><code>mut</code> 与隐藏的另一个区别是，当再次使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，然而我们真正需要的是将输入存储成数字（多少个空格）：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let spaces = &quot;   &quot;;
let spaces = spaces.len();
#}</code></pre></pre>
<p>这里允许第一个 <code>spaces</code> 变量是字符串类型，而第二个 <code>spaces</code> 变量，它是一个恰巧与第一个变量同名的崭新变量，是数字类型。隐藏使我们不必使用不同的名字，如 <code>spaces_str</code> 和 <code>spaces_num</code>；相反，我们可以复用 <code>spaces</code> 这个更简单的名字。然而，如果尝试使用 <code>mut</code>，将会得到一个编译时错误，如下所示：</p>
<pre><code class="language-rust ignore">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<p>这个错误说明，我们不能改变变量的类型：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>现在我们已经了解了变量如何工作，让我们看看变量可以拥有的更多数据类型。</p>
<a class="header" href="print.html#a数据类型" id="a数据类型"><h2>数据类型</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch03-02-data-types.md">ch03-02-data-types.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>在 Rust 中，每一个值都属于某一个 <strong>数据类型</strong>（<em>data type</em>），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型：标量（scalar）和复合（compound）。</p>
<p>记住，Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，比如第二章的 “比较猜测的数字和秘密数字” 使用 <code>parse</code> 将 <code>String</code> 转换为数字时，必须增加类型注解，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
#}</code></pre></pre>
<p>这里如果不添加类型注解，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
</code></pre>
<p>你会看到其它数据类型的各种类型注解。</p>
<a class="header" href="print.html#a标量类型" id="a标量类型"><h3>标量类型</h3></a>
<p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。你可能在其他语言中见过它们。让我们深入了解它们在 Rust 中是如何工作的。</p>
<a class="header" href="print.html#a整型" id="a整型"><h4>整型</h4></a>
<p><strong>整数</strong> 是一个没有小数部分的数字。我们在第二章使用过 <code>u32</code> 整数类型。该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 <code>i</code> 开头而不是 <code>u</code>）。表格 3-1 展示了 Rust 内建的整数类型。在有符号列和无符号列中的每一个变体（例如，<code>i16</code>）都可以用来声明整数值的类型。</p>
<p><span class="caption">表格 3-1: Rust 中的整型</span></p>
<table><thead><tr><th> 长度   </th><th> 有符号   </th><th> 无符号   </th></tr></thead><tbody>
<tr><td> 8-bit  </td><td> <code>i8</code>    </td><td> <code>u8</code>     </td></tr>
<tr><td> 16-bit </td><td> <code>i16</code>   </td><td> <code>u16</code>    </td></tr>
<tr><td> 32-bit </td><td> <code>i32</code>   </td><td> <code>u32</code>    </td></tr>
<tr><td> 64-bit </td><td> <code>i64</code>   </td><td> <code>u64</code>    </td></tr>
<tr><td> arch   </td><td> <code>isize</code> </td><td> <code>usize</code>  </td></tr>
</tbody></table>
<p>每一个变体都可以是有符号或无符号的，并有一个明确的大小。<strong>有符号</strong> 和 <strong>无符号</strong> 代表数字能否为负值，换句话说，数字是否需要有一个符号（有符号数），或者永远为正而不需要符号（无符号数）。这有点像在纸上书写数字：当需要考虑符号的时候，数字以加号或减号作为前缀；然而，可以安全地假设为正数时，加号前缀通常省略。有符号数以补码形式（two’s complement representation）存储（如果你不清楚这是什么，可以在网上搜索；对其的解释超出了本书的范畴）。</p>
<p>每一个有符号的变体可以储存包含从 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1 在内的数字，这里 <em>n</em> 是变体使用的位数。所以 <code>i8</code> 可以储存从 -(2<sup>7</sup>) 到 2<sup>7</sup> - 1 在内的数字，也就是从 -128 到 127。无符号的变体可以储存从 0 到 2<sup>n</sup> - 1 的数字，所以 <code>u8</code> 可以储存从 0 到 2<sup>8</sup> - 1 的数字，也就是从 0 到 255。</p>
<p>另外，<code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<p>可以使用表格 3-2 中的任何一种形式编写数字字面值。注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 <code>57u8</code>，同时也允许使用 <code>_</code> 做为分隔符以方便读数，例如<code>1_000</code>。</p>
<p><span class="caption">表格 3-2: Rust 中的整型字面值</span></p>
<table><thead><tr><th> 数字字面值        </th><th> 例子          </th></tr></thead><tbody>
<tr><td> Decimal          </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hex              </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal            </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binary           </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> only) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<p>那么该使用哪种类型的数字呢？如果拿不定主意，Rust 的默认类型通常就很好，数字类型默认是 <code>i32</code>：它通常是最快的，甚至在 64 位系统上也是。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p>
<a class="header" href="print.html#a浮点型" id="a浮点型"><h4>浮点型</h4></a>
<p>Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。</p>
<p>这是一个展示浮点数的实例：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮点数采用 IEEE-754 标准表示。<code>f32</code> 是单精度浮点数，<code>f64</code> 是双精度浮点数。</p>
<a class="header" href="print.html#a数值运算" id="a数值运算"><h4>数值运算</h4></a>
<p>Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。下面的代码展示了如何在 <code>let</code> 语句中使用它们：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 取余
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。附录 B 包含 Rust 提供的所有运算符的列表。</p>
<a class="header" href="print.html#a布尔型" id="a布尔型"><h4>布尔型</h4></a>
<p>正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。Rust 中的布尔类型使用 <code>bool</code> 表示。例如：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // 显式指定类型注解
}
</code></pre></pre>
<p>使用布尔值的主要场景是条件表达式，例如 <code>if</code> 表达式。在 “控制流”（“Control Flow”）部分将介绍 <code>if</code> 表达式在 Rust 中如何工作。</p>
<a class="header" href="print.html#a字符类型" id="a字符类型"><h4>字符类型</h4></a>
<p>目前为止只使用到了数字，不过 Rust 也支持字母。Rust 的 <code>char</code> 类型是语言中最原生的字母类型，如下代码展示了如何使用它。（注意 <code>char</code> 由单引号指定，不同于字符串使用双引号。）</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Rust 的 <code>char</code> 类型代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 <code>char</code> 并不符合。第八章的 “字符串” 中将详细讨论这个主题。</p>
<a class="header" href="print.html#a复合类型" id="a复合类型"><h3>复合类型</h3></a>
<p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<a class="header" href="print.html#a元组类型" id="a元组类型"><h4>元组类型</h4></a>
<p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。</p>
<p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了三个部分。最后，程序打印出了 <code>y</code> 的值，也就是 <code>6.4</code>。</p>
<p>除了使用模式匹配解构外，也可以使用点号（<code>.</code>）后跟值的索引来直接访问它们。例如：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>这个程序创建了一个元组，<code>x</code>，并接着使用索引为每个元素创建新变量。跟大多数编程语言一样，元组的第一个索引值是 0。</p>
<a class="header" href="print.html#a数组类型" id="a数组类型"><h4>数组类型</h4></a>
<p>另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。</p>
<p>Rust 中，数组中的值位于中括号内的逗号分隔的列表中：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间（第四章将讨论栈与堆的更多内容），或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，你可能应该使用 vector。第八章会详细讨论 vector。</p>
<p>一个你可能想要使用数组而不是 vector 的例子是，当程序需要知道一年中月份的名字时。程序不大可能会去增加或减少月份。这时你可以使用数组，因为我们知道它总是包含 12 个元素：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
#}</code></pre></pre>
<a class="header" href="print.html#a访问数组元素" id="a访问数组元素"><h5>访问数组元素</h5></a>
<p>数组是一整块分配在栈上的内存。可以使用索引来访问数组的元素，像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>在这个例子中，叫做 <code>first</code> 的变量的值是 <code>1</code>，因为它是数组索引 <code>[0]</code> 的值。变量 <code>second</code> 将会是数组索引 <code>[1]</code> 的值 <code>2</code>。</p>
<a class="header" href="print.html#a无效的数组元素访问" id="a无效的数组元素访问"><h5>无效的数组元素访问</h5></a>
<p>如果我们访问数组结尾之后的元素会发生什么呢？比如你将上面的例子改成下面这样，这可以编译不过在运行时会因错误而退出：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>使用 <code>cargo run</code> 运行代码后会产生如下结果：</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>编译并没有产生任何错误，不过程序会出现一个 <strong>运行时</strong>（<em>runtime</em>）错误并且不会成功退出。当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em>，这是 Rust 术语，它用于程序因为错误而退出的情况。</p>
<p>这是第一个在实战中遇到的 Rust 安全原则的例子。在很多底层语言中，并没有进行这类检查，这样当提供了一个不正确的索引时，就会访问无效的内存。通过立即退出而不是允许内存访问并继续执行，Rust 让你避开此类错误。第九章会讨论更多 Rust 的错误处理。</p>
<a class="header" href="print.html#a函数" id="a函数"><h2>函数</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch03-03-how-functions-work.md">ch03-03-how-functions-work.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>函数遍布于 Rust 代码中。你已经见过语言中最重要的函数之一：<code>main</code> 函数，它是很多程序的入口点。你也见过 <code>fn</code> 关键字，它用来声明新函数。</p>
<p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Rust 中的函数定义以 <code>fn</code> 开始并在函数名后跟一对圆括号。大括号告诉编译器哪里是函数体的开始和结尾。</p>
<p>可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 <code>another_function</code> 函数，所以可以在 <code>main</code> 函数中调用它。注意，源码中 <code>another_function</code> 定义在 <code>main</code> 函数 <strong>之后</strong>；也可以定义在之前。Rust 不关心函数定义于何处，只要定义了就行。</p>
<p>让我们新建一个叫做 <em>functions</em> 的二进制项目来进一步探索函数。将上面的 <code>another_function</code> 例子写入 <em>src/main.rs</em> 中并运行。你应该会看到如下输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p><code>main</code> 函数中的代码会按顺序执行。首先，打印 “Hello, world!” 信息，然后调用 <code>another_function</code> 函数并打印它的信息。</p>
<a class="header" href="print.html#a函数参数" id="a函数参数"><h3>函数参数</h3></a>
<p>函数也可以被定义为拥有 <strong>参数</strong>（<em>parameters</em>），参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>），但是在闲谈时，人们倾向于互换着使用 <em>parameter</em> 和 <em>argument</em> 来表示函数定义中的变量或调用函数时传入的具体值。</p>
<p>下面被重写的 <code>another_function</code> 版本展示了 Rust 中参数是什么样的：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>尝试运行程序，将会输出如下内容：</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>another_function</code> 的声明中有一个命名为 <code>x</code> 的参数。<code>x</code> 的类型被指定为 <code>i32</code>。当将 <code>5</code> 传给 <code>another_function</code> 时，<code>println!</code> 宏将 <code>5</code> 放入格式化字符串中大括号的位置。</p>
<p>在函数签名中，<strong>必须</strong> 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。</p>
<p>当一个函数有多个参数时，使用逗号分隔，像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>这个例子创建了有两个参数的函数，都是 <code>i32</code> 类型。函数打印出了这两个参数的值。注意函数的参数类型并不一定相同，这个例子中只是碰巧相同罢了。</p>
<p>尝试运行代码。使用上面的例子替换当前 <em>functions</em> 项目的 <em>src/main.rs</em> 文件，并用 <code>cargo run</code> 运行它：</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>因为我们使用 <code>5</code> 作为 <code>x</code> 的值，<code>6</code> 作为 <code>y</code> 的值来调用函数，因此打印出这两个字符串及相应的值。</p>
<a class="header" href="print.html#a包含语句和表达式的函数体" id="a包含语句和表达式的函数体"><h3>包含语句和表达式的函数体</h3></a>
<p>函数体由一系列的语句和一个可选的结尾表达式构成。目前为止，我们只介绍了没有结尾表达式的函数，不过你已经见过作为语句一部分的表达式。因为 Rust 是一门基于表达式（expression-based）的语言，这是一个需要理解的（不同于其他语言）重要区别。其他语言并没有这样的区别，所以让我们看看语句与表达式有什么区别以及这些区别是如何影响函数体的。</p>
<p>实际上，我们已经使用过语句和表达式。<strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。表达式（<em>Expressions</em>）计算并产生一个值。让我们看一些例子：</p>
<p>使用 <code>let</code> 关键字创建变量并绑定一个值是一个语句。在列表 3-1 中，<code>let y = 6;</code> 是一个语句。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">列表 3-1：包含一个语句的 <code>main</code> 函数定义</span></p>
<p>函数定义也是语句，上面整个例子本身就是一个语句。</p>
<p>语句不返回值。因此，不能把 <code>let</code> 语句赋值给另一个变量，比如下面的例子尝试做的，会产生一个错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>当运行这个程序时，会得到如下错误：</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p><code>let y = 6</code> 语句并不返回值，所以没有可以绑定到 <code>x</code> 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 <code>x = y = 6</code>，这样 <code>x</code> 和 <code>y</code> 的值都是 <code>6</code>；Rust 中不能这样写。</p>
<p>表达式会计算出一些值，并且你将编写的大部分 Rust 代码是由表达式组成的。考虑一个简单的数学运算，比如 <code>5 + 6</code>，这是一个表达式并计算出值 <code>11</code>。表达式可以是语句的一部分：在示例 3-1 中，语句 <code>let y = 6;</code> 中的 <code>6</code> 是一个表达式，它计算出的值是 <code>6</code>。函数调用是一个表达式。宏调用是一个表达式。我们用来创建新作用域的大括号（代码块），<code>{}</code>，也是一个表达式，例如：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>这个表达式：</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>是一个代码块，它的值是 <code>4</code>。这个值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code> 上。注意结尾没有分号的那一行 <code>x+1</code>，与你见过的大部分代码行不同。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。在接下来探索具有返回值的函数和表达式时要谨记这一点。</p>
<a class="header" href="print.html#a具有返回值的函数" id="a具有返回值的函数"><h3>具有返回值的函数</h3></a>
<p>函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（<code>-&gt;</code>）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 <code>return</code> 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。这是一个有返回值的函数的例子：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>在 <code>five</code> 函数中没有函数调用、宏、甚至没有 <code>let</code> 语句——只有数字 <code>5</code>。这在 Rust 中是一个完全有效的函数。注意，也指定了函数返回值的类型，就是 <code>-&gt; i32</code>。尝试运行代码；输出应该看起来像这样：</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>five</code> 函数的返回值是 <code>5</code>，所以返回值类型是 <code>i32</code>。让我们仔细检查一下这段代码。有两个重要的部分：首先，<code>let x = five();</code> 这一行表明我们使用函数的返回值初始化一个变量。因为 <code>five</code> 函数返回 <code>5</code>，这一行与如下代码相同：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>其次，<code>five</code> 函数没有参数并定义了返回值类型，不过函数体只有单单一个 <code>5</code> 也没有分号，因为这是一个表达式，我们想要返回它的值。</p>
<p>让我们看看另一个例子：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>运行代码会打印出 <code>The value of x is: 6</code>。但如果在包含 <code>x + 1</code> 的行尾加上一个分号，把它从表达式变成语句，我们将看到一个错误。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>运行代码会产生一个错误，如下：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<p>主要的错误信息，“mismatched types”（类型不匹配），揭示了代码的核心问题。函数 <code>plus_one</code> 的定义说明它要返回一个 <code>i32</code> 类型的值，不过语句并不会返回值，使用空元组 <code>()</code> 表示不返回值。因为不返回值与函数定义相矛盾，从而出现一个错误。在输出中，Rust 提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。</p>
<a class="header" href="print.html#a注释" id="a注释"><h2>注释</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch03-04-comments.md">ch03-04-comments.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>所有程序员都力求使其代码易于理解，不过有时还需要提供额外的解释。在这种情况下，程序员在源码中留下记录，或者 <strong>注释</strong>（<em>comments</em>），编译器会忽略它们，不过阅读代码的人可能觉得有用。</p>
<p>这是一个简单的注释：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// hello, world
#}</code></pre></pre>
<p>在 Rust 中，注释必须以两道斜杠开始，并持续到本行的结尾。对于超过一行的注释，需要在每一行前都加上 <code>//</code>，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
#}</code></pre></pre>
<p>注释也可以在放在包含代码的行的末尾：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<p>不过你更经常看到以这种格式使用它们，也就是位于它所解释的代码行的上面一行：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust 还有另一种注释，称为文档注释，我们将在 14 章讨论它。</p>
<a class="header" href="print.html#a控制流" id="a控制流"><h2>控制流</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch03-05-control-flow.md">ch03-05-control-flow.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>根据条件是否为真来决定是否执行某些代码，以及根据条件是否为真来重复运行一段代码是大部分编程语言的基本组成部分。Rust 代码中最常见的用来控制执行流的结构是 <code>if</code> 表达式和循环。</p>
<a class="header" href="print.html#if-表达式" id="if-表达式"><h3><code>if</code> 表达式</h3></a>
<p><code>if</code> 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 “如果条件满足，运行这段代码；如果条件不满足，不运行这段代码。”</p>
<p>在 <em>projects</em> 目录新建一个叫做 <em>branches</em> 的项目，来学习 <code>if</code> 表达式。在 <em>src/main.rs</em> 文件中，输入如下内容：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>所有的 <code>if</code> 表达式都以 <code>if</code> 关键字开头，其后跟一个条件。在这个例子中，条件检查变量 <code>number</code> 的值是否小于 5。在条件为真时希望执行的代码块位于紧跟条件之后的大括号中。<code>if</code> 表达式中与条件关联的代码块有时被叫做 <em>arms</em>，就像第二章 “比较猜测的数字和秘密数字” 部分中讨论到的 <code>match</code> 表达式中的分支一样。</p>
<p>也可以包含一个可选的 <code>else</code> 表达式来提供一个在条件为假时应当执行的代码块，这里我们就这么做了。如果不提供 <code>else</code> 表达式并且条件为假时，程序会直接忽略 <code>if</code> 代码块并继续执行下面的代码。</p>
<p>尝试运行代码，应该能看到如下输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
</code></pre>
<p>尝试改变 <code>number</code> 的值使条件为假时看看会发生什么：</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<p>再次运行程序并查看输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was false
</code></pre>
<p>另外值得注意的是代码中的条件 <strong>必须</strong> 是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。例如，尝试运行以下代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>这里 <code>if</code> 条件的值是 <code>3</code>，Rust 抛出了一个错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>这个错误表明 Rust 期望一个 <code>bool</code> 却得到了一个整数。不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 <code>if</code> 的条件。例如，如果想要 <code>if</code> 代码块只在一个数字不等于 <code>0</code> 时执行，可以把 <code>if</code> 表达式修改成下面这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>运行代码会打印出 <code>number was something other than zero</code>。</p>
<a class="header" href="print.html#a使用-else-if-处理多重条件" id="a使用-else-if-处理多重条件"><h4>使用 <code>else if</code> 处理多重条件</h4></a>
<p>可以将 <code>else if</code> 表达式与 <code>if</code> 和 <code>else</code> 组合来实现多重条件。例如：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>这个程序有四个可能的执行路径。运行后应该能看到如下输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>当执行这个程序时，它按顺序检查每个 <code>if</code> 表达式并执行第一个条件为真的代码块。注意即使 6 可以被 2 整除，也不会输出 <code>number is divisible by 2</code>，更不会输出 <code>else</code> 块中的 <code>number is not divisible by 4, 3, or 2</code>。原因是 Rust 只会执行第一个条件为真的代码块，并且一旦它找到一个以后，甚至都不会检查剩下的条件了。</p>
<p>使用过多的 <code>else if</code> 表达式会使代码显得杂乱无章，所以如果有多于一个 <code>else if</code> 表达式，最好重构代码。为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 <code>match</code>。</p>
<a class="header" href="print.html#a在-let-语句中使用-if" id="a在-let-语句中使用-if"><h4>在 <code>let</code> 语句中使用 <code>if</code></h4></a>
<p>因为 <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它，例如在示例 3-2 中：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">示例 3-2：将 <code>if</code> 表达式的返回值赋给一个变量</span></p>
<p><code>number</code> 变量将会绑定到表示 <code>if</code> 表达式结果的值上。运行这段代码看看会出现什么：</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>记住，代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。在这个例子中，整个 <code>if</code> 表达式的值取决于哪个代码块被执行。这意味着 <code>if</code> 的每个分支的可能的返回值都必须是相同类型；在示例 3-2 中，<code>if</code> 分支和 <code>else</code> 分支的结果都是 <code>i32</code> 整型。如果它们的类型不匹配，如下面这个例子，则会出现一个错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>当编译这段代码时，会得到一个错误。<code>if</code> 和 <code>else</code> 分支的值类型是不相容的，同时 Rust 也准确地指出在程序中的何处发现的这个问题：</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integral variable, found &amp;str
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<p><code>if</code> 代码块中的表达式返回一个整数，而 <code>else</code> 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道 <code>number</code> 变量的类型，这样它就可以在编译时验证在每处使用的 <code>number</code> 变量的类型是有效的。Rust 并不能够在 <code>number</code> 的类型只能在运行时确定的情况下工作；这样会使编译器变得更复杂而且只能为代码提供更少的保障，因为它不得不记录所有变量的多种可能的类型。</p>
<a class="header" href="print.html#a使用循环重复执行" id="a使用循环重复执行"><h3>使用循环重复执行</h3></a>
<p>多次执行同一段代码是很常用的，Rust 为此提供了多种 <strong>循环</strong>（<em>loops</em>）。一个循环执行循环体中的代码直到结尾并紧接着回到开头继续执行。为了实验一下循环，让我们新建一个叫做 <em>loops</em> 的项目。</p>
<p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>。我们每一个都试试。</p>
<a class="header" href="print.html#a使用-loop-重复执行代码" id="a使用-loop-重复执行代码"><h4>使用 <code>loop</code> 重复执行代码</h4></a>
<p><code>loop</code> 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。</p>
<p>作为一个例子，将 <em>loops</em> 目录中的 <em>src/main.rs</em> 文件修改为如下：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>当运行这个程序时，我们会看到连续的反复打印 <code>again!</code>，直到我们手动停止程序。大部分终端都支持一个快捷键，<span class="keystroke">ctrl-c</span>，来终止一个陷入无限循环的程序。尝试一下：</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>符号 <code>^C</code> 代表你在这按下了<span class="keystroke">ctrl-c</span>。在 <code>^C</code> 之后你可能看到也可能看不到 <code>again!</code> ，这取决于在接收到终止信号时代码执行到了循环的何处。</p>
<p>幸运的是，Rust 提供了另一种更可靠的退出循环的方式。可以使用 <code>break</code> 关键字来告诉程序何时停止循环。回忆一下在第二章猜猜看游戏的 “猜测正确后退出” 部分使用过它来在用户猜对数字赢得游戏后退出程序。</p>
<a class="header" href="print.html#while-条件循环" id="while-条件循环"><h4><code>while</code> 条件循环</h4></a>
<p>在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 <code>break</code> 停止循环。这个循环类型可以通过组合 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 来实现；如果你喜欢的话，现在就可以在程序中试试。</p>
<p>然而，这个模式太常用了，Rust 为此内置了一个语言结构，它被称为 <code>while</code> 循环。示例 3-3 使用了 <code>while</code>：程序循环三次，每次数字都减一。接着，在循环结束后，打印出另一个信息并退出。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">示例 3-3: 当条件为真时，使用 <code>while</code> 循环运行代码</span></p>
<p>这种结构消除了使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 时必须有的很多嵌套，代码更加清晰。当条件为真就执行，否则退出循环。</p>
<a class="header" href="print.html#a使用-for-遍历集合" id="a使用-for-遍历集合"><h4>使用 <code>for</code> 遍历集合</h4></a>
<p>可以使用 <code>while</code> 结构来遍历集合中的元素，比如数组。例如，看看示例 3-4。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p><span class="caption">示例 3-4：使用 <code>while</code> 循环遍历集合中的元素</span></p>
<p>这里，代码对数组中的元素进行计数。它从索引 <code>0</code> 开始，并接着循环直到遇到数组的最后一个索引（这时，<code>index &lt; 5</code> 不再为真）。运行这段代码会打印出数组中的每一个元素：</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>数组中的所有五个元素都如期被打印出来。尽管 <code>index</code> 在某一时刻会到达值 <code>5</code>，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。</p>
<p>但这个过程很容易出错；如果索引长度不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。</p>
<p>作为更简洁的替代方案，可以使用 <code>for</code> 循环来对一个集合的每个元素执行一些代码。<code>for</code> 循环看起来如示例 3-5 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">示例 3-5：使用 <code>for</code> 循环遍历集合中的元素</span></p>
<p>当运行这段代码时，将看到与示例 3-4 一样的输出。更为重要的是，我们增强了代码安全性，并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug。</p>
<p>例如，在示例 3-4 的代码中，如果从数组 <code>a</code> 中移除一个元素但忘记将条件更新为 <code>while index &lt; 4</code>，代码将会 panic。使用 <code>for</code> 循环的话，就不需要惦记着在改变数组元素个数时修改其他的代码了。</p>
<p><code>for</code> 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构。即使是在想要循环执行代码特定次数时，例如示例 3-3 中使用 <code>while</code> 循环的倒计时例子，大部分 Rustacean 也会使用 <code>for</code> 循环。这么做的方式是使用 <code>Range</code>，它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列。</p>
<p>下面是一个使用 <code>for</code> 循环来倒计时的例子，它还使用了一个我们还未讲到的方法，<code>rev</code>，用来反转 range：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>这段代码看起来更帅气不是吗？</p>
<a class="header" href="print.html#a总结-2" id="a总结-2"><h2>总结</h2></a>
<p>你做到了！这是一个大章节：你学习了变量、标量和复合数据类型、函数、注释、 <code>if</code> 表达式和循环！如果你想要实践本章讨论的概念，尝试构建如下程序：</p>
<ul>
<li>相互转换摄氏与华氏温度。</li>
<li>生成 n 阶斐波那契数列。</li>
<li>打印圣诞颂歌 “The Twelve Days of Christmas” 的歌词，并利用歌曲中的重复部分（编写循环）。</li>
</ul>
<p>当你准备好继续的时候，让我们讨论一个其他语言中 <em>并不</em> 常见的概念：所有权（ownership）。</p>
<a class="header" href="print.html#a认识所有权" id="a认识所有权"><h1>认识所有权</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch04-00-understanding-ownership.md">ch04-00-understanding-ownership.md</a>
<br>
commit aff4f619c4d6dc138b57b74c3a898ba9bce06649</p>
</blockquote>
<p>所有权（系统）是 Rust 最独特的功能，其令 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据。</p>
<a class="header" href="print.html#a什么是所有权" id="a什么是所有权"><h2>什么是所有权</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch04-01-what-is-ownership.md">ch04-01-what-is-ownership.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>Rust 的核心功能（之一）是 <strong>所有权</strong>（<em>ownership</em>）。虽然该功能很容易解释，但它对语言的其他部分有着深刻的影响。</p>
<p>所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。</p>
<p>因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息是随着你对 Rust 和所有权系统的规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！</p>
<p>当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。</p>
<blockquote>
<a class="header" href="print.html#a栈stack与堆heap" id="a栈stack与堆heap"><h3>栈（Stack）与堆（Heap）</h3></a>
<p>在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。</p>
<p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。</p>
<p>栈的操作是十分快速的，这主要是得益于它存取数据的方式：因为数据存取的位置总是在栈顶而不需要寻找一个位置存放或读取数据。另一个让操作栈快速的属性是，栈中的所有数据都必须占用已知且固定的大小。</p>
<p>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。</p>
<p>想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。</p>
<p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
</blockquote>
<a class="header" href="print.html#a所有权规则" id="a所有权规则"><h3>所有权规则</h3></a>
<p>首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：</p>
<blockquote>
<ol>
<li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li>
<li>值有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<a class="header" href="print.html#a变量作用域" id="a变量作用域"><h3>变量作用域</h3></a>
<p>我们已经在第二章完成一个 Rust 程序示例。既然我们已经掌握了基本语法，将不会在之后的例子中包含 <code>fn main() {</code> 代码，所以如果你是一路跟过来的，必须手动将之后例子的代码放入一个 <code>main</code> 函数中。这样，例子将显得更加简明，使我们可以关注实际细节而不是样板代码。</p>
<p>在所有权的第一个例子中，我们看看一些变量的 <strong>作用域</strong>（<em>scope</em>）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;hello&quot;;
#}</code></pre></pre>
<p>变量 <code>s</code> 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。示例 4-1 的注释标明了变量 <code>s</code> 在何处是有效的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s 在这里无效, 它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s 不再有效
#}</code></pre></pre>
<p><span class="caption">示例 4-1：一个变量和其有效的作用域</span></p>
<p>换句话说，这里有两个重要的时间点：</p>
<ul>
<li>当 <code>s</code> <strong>进入作用域</strong> 时，它就是有效的。</li>
<li>这一直持续到它 <strong>离开作用域</strong> 为止。</li>
</ul>
<p>目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 <code>String</code> 类型。</p>
<a class="header" href="print.html#string-类型" id="string-类型"><h3><code>String</code> 类型</h3></a>
<p>为了演示所有权的规则，我们需要一个比第三章 “数据类型” 中讲到的都要复杂的数据类型。前面介绍的类型都是存储在栈上的并且当离开作用域时被移出栈，不过我们需要寻找一个存储在堆上的数据来探索 Rust 是如何知道该在何时清理数据的。</p>
<p>这里使用 <code>String</code> 作为例子，并专注于 <code>String</code> 与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。在第八章会更深入地讲解 <code>String</code>。</p>
<p>我们已经见过字符串字面值，字符串值被硬编码进程序里。字符串字面值是很方便的，不过他们并不适合使用文本的每一种场景。原因之一就是他们是不可变的。另一个原因是并不是所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，<code>String</code>。这个类型被分配到堆上，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>，如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);
#}</code></pre></pre>
<p>这两个冒号（<code>::</code>）是运算符，允许将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间（namespace）下，而不需要使用类似 <code>string_from</code> 这样的名字。在第五章的 “方法语法”（“Method Syntax”）部分会着重讲解这个语法而且在第七章的 “模块定义” 中会讲到模块的命名空间。</p>
<p><strong>可以</strong> 修改此类字符串 ：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值

println!(&quot;{}&quot;, s); // 将打印 `hello, world!`
#}</code></pre></pre>
<p>那么这里有什么区别呢？为什么 <code>String</code> 可变而字面值却不行呢？区别在于两个类型对内存的处理上。</p>
<a class="header" href="print.html#a内存与分配" id="a内存与分配"><h3>内存与分配</h3></a>
<p>就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向操作系统请求内存。</li>
<li>需要一个当我们处理完 <code>String</code> 时将内存返回给操作系统的方法。</li>
</ul>
<p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现 (<em>implementation</em>) 请求其所需的内存。这在编程语言中是非常通用的。</p>
<p>然而，第二部分实现起来就各有区别了。在有 <strong>垃圾回收</strong>（<em>garbage collector</em>，<em>GC</em>）的语言中， GC 记录并清除不再使用的内存，而我们并不需要关心它。没有 GC 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 <code>allocate</code> 配对一个 <code>free</code>。</p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 <code>String</code> 而不是字符串字面值的版本：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效
#}</code></pre></pre>
<p>这是一个将 <code>String</code> 需要的内存返回给操作系统的很自然的位置：当 <code>s</code> 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <code>drop</code>，在这里 <code>String</code> 的作者可以放置释放内存的代码。Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 <strong>资源获取即初始化</strong>（<em>Resource Acquisition Is Initialization (RAII)</em>）。如果你使用过 RAII 模式的话应该对 Rust 的 <code>drop</code> 函数并不陌生。</p>
</blockquote>
<p>这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。</p>
<a class="header" href="print.html#a变量与数据交互的方式一移动" id="a变量与数据交互的方式一移动"><h4>变量与数据交互的方式（一）：移动</h4></a>
<p>Rust 中的多个变量可以采用一种独特的方式与同一数据交互。让我们看看示例 4-2 中一个使用整型的例子。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">示例 4-2：将变量 <code>x</code> 的整数值赋给 <code>y</code></span></p>
<p>我们大致可以猜到这在干什么：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为正数是有已知固定大小的简单值，所以这两个 <code>5</code> 被放入了栈中。</p>
<p>现在看看这个 <code>String</code> 版本：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>这看起来与上面的代码非常类似，所以我们可能会假设他们的运行方式也是类似的：也就是说，第二行可能会生成一个 <code>s1</code> 的拷贝并绑定到 <code>s2</code> 上。不过，事实上并不完全是这样。</p>
<p>看看图 4-1 以了解 <code>String</code> 的底层会发生什么。<code>String</code> 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。</p>
<p><img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-1：将值 <code>&quot;hello&quot;</code> 绑定给 <code>s1</code> 的 <code>String</code> 在内存中的表现形式</span></p>
<p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从操作系统总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p>
<p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，<code>String</code> 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 4-2 所示。</p>
<p><img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-2：变量 <code>s2</code> 的内存表现，它有一份 <code>s1</code> 指针、长度和容量的拷贝</span></p>
<p>这个表现形式看起来 <strong>并不像</strong> 图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 <code>s2 = s1</code> 在堆上数据比较大的时候会对运行时性能造成非常大的影响。</p>
<p><img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-3：另一个 <code>s2 = s1</code> 时可能的内存表现，如果 Rust 同时也拷贝了堆上的数据的话</span></p>
<p>之前，我们提到过当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。与其尝试拷贝被分配的内存，Rust 则认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。看看在 <code>s2</code> 被创建之后尝试使用 <code>s1</code> 会发生什么；它不会工作：</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>如果你在其他语言中听说过术语 <strong>浅拷贝</strong>（<em>shallow copy</em>）和 <strong>深拷贝</strong>（<em>deep copy</em>），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 <strong>移动</strong>（<em>move</em>），而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被 <strong>移动</strong> 到了 <code>s2</code> 中。那么具体发生了什么，如图 4-4 所示。</p>
<p><img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-4：<code>s1</code> 无效之后的内存表现</span></p>
<p>这样就解决了我们的问题！因为只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存，完毕。</p>
<p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 <strong>自动</strong> 的复制可以被认为对运行时性能影响较小。</p>
<a class="header" href="print.html#a变量与数据交互的方式二克隆" id="a变量与数据交互的方式二克隆"><h4>变量与数据交互的方式（二）：克隆</h4></a>
<p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的通用函数。第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。</p>
<p>这是一个实际使用 <code>clone</code> 方法的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据 <strong>确实</strong> 被复制了。</p>
<p>当出现 <code>clone</code> 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。</p>
<a class="header" href="print.html#a只在栈上的数据拷贝" id="a只在栈上的数据拷贝"><h4>只在栈上的数据：拷贝</h4></a>
<p>这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的，他们是示例 4-2 中的一部分：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过 <code>x</code> 依然有效且没有被移动到 <code>y</code> 中。</p>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型拥有 <code>Copy</code> trait，一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。要学习如何为你的类型增加 <code>Copy</code> 注解，请阅读附录 C 中的 “可派生的 trait”。</p>
<p>那么什么类型是 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<a class="header" href="print.html#a所有权与函数" id="a所有权与函数"><h3>所有权与函数</h3></a>
<p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!(&quot;{}&quot;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!(&quot;{}&quot;, some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre></pre>
<p><span class="caption">示例 4-3：带有所有权和作用域注释的函数</span></p>
<p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。</p>
<a class="header" href="print.html#a返回值与作用域" id="a返回值与作用域"><h3>返回值与作用域</h3></a>
<p>返回值也可以转移所有权。示例 4-4 与示例 4-3 一样带有类似的注释。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中, 
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></pre>
<p><span class="caption">示例 4-4: 转移返回值的所有权</span></p>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如示例 4-5 所示。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
</code></pre></pre>
<p><span class="caption">示例 4-5: 返回参数的所有权</span></p>
<p>但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个功能，叫做 <strong>引用</strong>（<em>references</em>）。</p>
<a class="header" href="print.html#a引用与借用" id="a引用与借用"><h2>引用与借用</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch04-02-references-and-borrowing.md">ch04-02-references-and-borrowing.md</a>
<br>
commit f949ff883628db8ed2f2f5f19e146ebf19ed6a6f</p>
</blockquote>
<p>示例 4-5 中的元组代码有这样一个问题：我们必须将 <code>String</code> 返回给调用函数，以便在调用 <code>calculate_length</code> 后仍能使用 <code>String</code>，因为 <code>String</code> 被移动到了 <code>calculate_length</code> 内。</p>
<p>下面是如何定义并使用一个（新的）<code>calculate_length</code> 函数，它以一个对象的引用作为参数而不是获取值的所有权：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>首先，注意变量声明和函数返回值中的所有元组代码都消失了。其次，注意我们传递 <code>&amp;s1</code> 给 <code>calculate_length</code>，同时在函数定义中，我们获取 <code>&amp;String</code> 而不是 <code>String</code>。</p>
<p>这些 &amp; 符号就是 <strong>引用</strong>，它们允许你使用值但不获取其所有权。图 4-5 展示了一张示意图。</p>
<p><img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">图 4-5：<code>&amp;String s</code> 指向 <code>String s1</code> 示意图</span></p>
<blockquote>
<p>注意：与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符，<code>*</code>。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。</p>
</blockquote>
<p>仔细看看这个函数调用：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calculate_length(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
#}</code></pre></pre>
<p><code>&amp;s1</code> 语法让我们创建一个 <strong>指向</strong> 值 <code>s1</code> 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。</p>
<p>同理，函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calculate_length(s: &amp;String) -&gt; usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
#}</code></pre></pre>
<p>变量 <code>s</code> 有效的作用域与函数参数的作用域一样，不过当引用离开作用域后并不丢弃它指向的数据，因为我们没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</p>
<p>我们将获取引用作为函数参数称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。</p>
<p>如果我们尝试修改借用的变量呢？尝试示例 4-6 中的代码。剧透：这行不通！</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">示例 4-6：尝试修改借用的值</span></p>
<p>这里是错误：</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<a class="header" href="print.html#a可变引用" id="a可变引用"><h3>可变引用</h3></a>
<p>我们通过一个小调整就能修复示例 4-6 代码中的错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>首先，必须将 <code>s</code> 改为 <code>mut</code>。然后必须创建一个可变引用 <code>&amp;mut s</code> 和接受一个可变引用 <code>some_string: &amp;mut String</code>。</p>
<p>不过可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用。这些代码会失败：</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>错误如下：</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; borrow_twice.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>这个限制允许可变性，不过是以一种受限制的方式允许。新 Rustacean 们经常与此作斗争，因为大部分语言中变量任何时候都是可变的。</p>
<p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p>
<p>一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>类似的规则也存在于同时使用可变与不可变引用中。这些代码会导致一个错误：</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // no problem
let r2 = &amp;s; // no problem
let r3 = &amp;mut s; // BIG PROBLEM
</code></pre>
<p>错误如下：</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; borrow_thrice.rs:6:19
  |
4 |     let r1 = &amp;s; // no problem
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>哇哦！我们 <strong>也</strong> 不能在拥有不可变引用的同时拥有可变引用。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。</p>
<p>尽管这些错误有时使人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在。这样你就不必去跟踪为何数据并不是你想象中的那样。</p>
<a class="header" href="print.html#a悬垂引用dangling-references" id="a悬垂引用dangling-references"><h3>悬垂引用（Dangling References）</h3></a>
<p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 <strong>悬垂指针</strong>（<em>dangling pointer</em>），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>让我们尝试创建一个悬垂引用，Rust 会通过一个编译时错误来避免：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>这里是错误：</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。第十章会详细介绍生命周期。不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息：</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>让我们仔细看看我们的 <code>dangle</code> 代码的每一步到底发生了什么：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle 返回一个 String 引用

    let s = String::from(&quot;hello&quot;); // s 是新创建的 String

    &amp;s // 我们返回 String 的引用，s
} // 这里，s 移出了作用域，并被丢弃。它的内存被释放
  // 危险！
</code></pre>
<p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！Rust 不会允许我们这么做。</p>
<p>这里的解决方法是直接返回 <code>String</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
#}</code></pre></pre>
<p>这样就没有任何错误了。所有权被移动出去，所以没有值被释放。</p>
<a class="header" href="print.html#a引用的规则" id="a引用的规则"><h3>引用的规则</h3></a>
<p>让我们概括一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li>
<li>引用必须总是有效。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>
<a class="header" href="print.html#slice-类型" id="slice-类型"><h2>Slice 类型</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch04-03-slices.md">ch04-03-slices.md</a>
<br>
commit 729f1118332ddcf01138d284eac5db0e85f8c8ed</p>
</blockquote>
<p>另一个没有所有权的数据类型是 <em>slice</em>。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。</p>
<p>这里有一个编程小习题：编写一个函数，该函数接收一个字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p>
<p>让我们考虑一下这个函数的签名：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p><code>first_word</code> 函数有一个参数 <code>&amp;String</code>。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取 <strong>部分</strong> 字符串的办法。不过，我们可以返回单词结尾的索引。试试如示例 4-7 中的代码。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">示例 4-7：<code>first_word</code> 函数返回 <code>String</code> 参数的一个字节索引值</span></p>
<p>因为需要逐个元素的检查 <code>String</code> 中的值是否为空格，需要用 <code>as_bytes</code> 方法将 <code>String</code> 转化为字节数组：</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>接下来，使用 <code>iter</code> 方法在字节数组上创建一个迭代器：</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>我们将在第十三章详细讨论迭代器。现在，只需知道 <code>iter</code> 方法返回集合中的每一个元素，而 <code>enumerate</code> 包装 <code>iter</code> 的结果并返回一个元组，其中每一个元素是元组的一部分。<code>enumerate</code> 返回元组的第一个元素是索引，第二个元素是集合中元素的引用。这比我们自己计算索引要方便一些。</p>
<p>因为 <code>enumerate</code> 方法返回一个元组，我们可以使用模式来解构，就像 Rust 中其他任何地方所做的一样。所以在 <code>for</code> 循环中，我们指定了一个模式，其中元组中的 <code>i</code> 是索引而元组中的 <code>&amp;item</code> 是单个字节。因为我们从 <code>.iter().enumerate()</code> 中获取了集合元素的引用，所以模式中使用了 <code>&amp;</code>。</p>
<p>在 <code>for</code> 循环中，我们通过字节的字面值语法来寻找代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 <code>s.len()</code> 返回字符串的长度：</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}

s.len()
</code></pre>
<p>现在有了一个找到字符串中第一个单词结尾索引的方法，不过这有一个问题。我们返回了一个独立的 <code>usize</code>，不过它只在 <code>&amp;String</code> 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 <code>String</code> 相分离的值，无法保证将来它仍然有效。考虑一下示例 4-8 中使用了示例 4-7 中 <code>first_word</code> 函数的程序。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word 的值为 5

    s.clear(); // 这清空了字符串，使其等于 &quot;&quot;

    // word 在此处的值仍然是 5，
    // 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！
}
</code></pre></pre>
<p><span class="caption">示例 4-8：存储 <code>first_word</code> 函数调用的返回值并接着改变 <code>String</code> 的内容</span></p>
<p>这个程序编译时没有任何错误，而且在调用 <code>s.clear()</code> 之后使用 <code>word</code> 也不会出错。因为 <code>word</code> 与 <code>s</code> 状态完全没有联系，所以 <code>word</code> 仍然包含值 <code>5</code>。可以尝试用值 <code>5</code> 来提取变量 <code>s</code> 的第一个单词，不过这是有 bug 的，因为在我们将 <code>5</code> 保存到 <code>word</code> 之后 <code>s</code> 的内容已经改变。</p>
<p>我们不得不时刻担心 <code>word</code> 的索引与 <code>s</code> 中的数据不再同步，这很啰嗦且易出错！如果编写这么一个 <code>second_word</code> 函数的话，管理索引这件事将更加容易出问题。它的签名看起来像这样：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>现在我们要跟踪一个开始索引 <strong>和</strong> 一个结尾索引，同时有了更多从数据的某个特定状态计算而来的值，但都完全没有与这个状态相关联。现在有三个飘忽不定的不相关变量需要保持同步。</p>
<p>幸运的是，Rust 为这个问题提供了一个解决方法：字符串 slice。</p>
<a class="header" href="print.html#a字符串-slice" id="a字符串-slice"><h3>字符串 slice</h3></a>
<p><strong>字符串 slice</strong>（<em>string slice</em>）是 <code>String</code> 中一部分值的引用，它看起来像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<p>这类似于引用整个 <code>String</code> 不过带有额外的 <code>[0..5]</code> 部分。不是对整个 <code>String</code> 的引用，而是对部分 <code>String</code> 的引用。<code>start..end</code> 语法代表一个以 <code>start</code> 开头并一直持续到但不包含 <code>end</code> 的 range。</p>
<p>使用一个由中括号中的 <code>[starting_index..ending_index]</code> 指定的 range 创建一个 slice，其中 <code>starting_index</code> 是 slice 的第一个位置，<code>ending_index</code> 则是 slice 最后一个位置的后一个值。在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度对应于 <code>ending_index</code> 减去 <code>starting_index</code> 的值。所以对于 <code>let world = &amp;s[6..11];</code> 的情况，<code>world</code> 将是一个包含指向 <code>s</code> 第 7 个字节的指针和长度值 5 的 slice。</p>
<p>图 4-6 展示了一个图例。</p>
<p><img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-6：引用了部分 <code>String</code> 的字符串 slice</span></p>
<p>对于 Rust 的 <code>..</code> range 语法，如果想要从第一个索引（0）开始，可以不写两个点号之前的值。换句话说，如下两个语句是相同的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>由此类推，如果 slice 包含 <code>String</code> 的最后一个字节，也可以舍弃尾部的数字。这意味着如下也是相同的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>也可以同时舍弃这两个值来获取整个字符串的 slice。所以如下亦是相同的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。出于介绍字符串 slice 的目的，本部分假设只使用 ASCII 字符集；第八章的 “使用字符串存储 UTF-8 编码的文本” 部分会更加全面的讨论 UTF-8 处理问题。</p>
</blockquote>
<p>在记住所有这些知识后，让我们重写 <code>first_word</code> 来返回一个 slice。“字符串 slice” 的类型声明写作 <code>&amp;str</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>我们使用跟示例 4-7 相同的方式获取单词结尾的索引，通过寻找第一个出现的空格。当找到一个空格，我们返回一个字符串 slice，它使用字符串的开始和空格的索引作为开始和结束的索引。</p>
<p>现在当调用 <code>first_word</code> 时，会返回与底层数据关联的单个值。这个值由一个 slice 开始位置的引用和 slice 中元素的数量组成。</p>
<p><code>second_word</code> 函数也可以改为返回一个 slice：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>现在我们有了一个不易混淆且直观的 API 了，因为编译器会确保指向 <code>String</code> 的引用持续有效。还记得示例 4-8 程序中，那个当我们获取第一个单词结尾的索引后，接着就清除了字符串导致索引就无效的 bug 吗？那些代码在逻辑上是不正确的，但却没有显示任何直接的错误。问题会在之后尝试对空字符串使用第一个单词的索引时出现。slice 就不可能出现这种 bug 并让我们更早的知道出问题了。使用 slice 版本的 <code>first_word</code> 会抛出一个编译时错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!
}
</code></pre>
<p>这里是编译错误：</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = first_word(&amp;s);
  |                            - immutable borrow occurs here
5 |
6 |     s.clear(); // error!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>回忆一下借用规则，当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 <code>clear</code> 需要清空 <code>String</code>，它尝试获取一个可变引用，它失败了。Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！</p>
<a class="header" href="print.html#a字符串字面值就是-slice" id="a字符串字面值就是-slice"><h4>字符串字面值就是 slice</h4></a>
<p>还记得我们讲到过字符串字面值被储存在二进制文件中吗。现在知道 slice 了，我们就可以正确的理解字符串字面值了：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<p>这里 <code>s</code> 的类型是 <code>&amp;str</code>：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；<code>&amp;str</code> 是一个不可变引用。</p>
<a class="header" href="print.html#a字符串-slice-作为参数" id="a字符串-slice-作为参数"><h4>字符串 slice 作为参数</h4></a>
<p>在知道了能够获取字面值和 <code>String</code> 的 slice 后，我们对 <code>first_word</code> 做了改进，这是它的签名：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>而更有经验的 Rustacean 会编写出示例 4-9 中的签名，因为它使得可以对 <code>String</code> 值和 <code>&amp;str</code> 值使用相同的函数：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p><span class="caption">示例 4-9: 通过将 <code>s</code> 参数的类型改为字符串 slice 来改进 <code>first_word</code> 函数</span></p>
<p>如果有一个字符串 slice，可以直接传递它。如果有一个 <code>String</code>，则可以传递整个 <code>String</code> 的 slice。定义一个获取字符串 slice 而不是 <code>String</code> 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word 中传入 `String` 的 slice
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word 中传入字符串字面值的 slice
    let word = first_word(&amp;my_string_literal[..]);

    // 因为字符串字面值 **就是** 字符串 slice，
    // 这样写也可以，即不使用 slice 语法！
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<a class="header" href="print.html#a其他类型的-slice" id="a其他类型的-slice"><h3>其他类型的 slice</h3></a>
<p>字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>这个 slice 的类型是 <code>&amp;[i32]</code>。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。第八章讲到 vector 时会详细讨论这些集合。</p>
<a class="header" href="print.html#a总结-3" id="a总结-3"><h2>总结</h2></a>
<p>所有权、借用和 slice 这些概念让 Rust 程序在编译时确保内存安全。Rust 语言提供了跟其他系统编程语言相同的方式来控制你使用的内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无须额外编写和调试相关的控制代码。</p>
<p>所有权系统影响了 Rust 中很多其他部分的工作方式，所以我们还会继续讲到这些概念，这将贯穿本书的余下内容。让我们开始第五章，来看看如何将多份数据组合进一个 <code>struct</code> 中。</p>
<a class="header" href="print.html#a使用结构体组织相关联的数据" id="a使用结构体组织相关联的数据"><h1>使用结构体组织相关联的数据</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch05-00-structs.md">ch05-00-structs.md</a>
<br>
commit 5e2368866cb445d912f5d2a2c92f4b42bcb542bb</p>
</blockquote>
<p><em>struct</em>，或者 <em>structure</em>，是一个自定义数据类型，允许你命名和包装多个相关的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，<em>struct</em> 就像对象中的数据属性。在本章中，我们会对比元组与结构体的异同，演示结构体的用法，并讨论如何在结构体上定义方法和关联函数来指定与结构体数据相关的行为。你在程序中基于结构体和枚举（<em>enum</em>）（在第六章介绍）创建新类型，以充分利用 Rust 的编译时类型检查。</p>
<a class="header" href="print.html#a定义并实例化结构体" id="a定义并实例化结构体"><h2>定义并实例化结构体</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch05-01-defining-structs.md">ch05-01-defining-structs.md</a>
<br>
commit c560db1e0145d5a64b9415c9cfe463c7dac31ab8</p>
</blockquote>
<p>结构体和我们在第三章讨论过的元组类似。和元组一样，结构体的每一部分可以是不同类型。但不同于元组，结构体需要命名各部分数据以便能清楚的表明其值的意义。由于有了这些名字，结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值。</p>
<p>定义结构体，需要使用 <code>struct</code> 关键字并为整个结构体提供一个名字。结构体的名字需要描述它所组合的数据的意义。接着，在大括号中，定义每一部分数据的名字和类型，我们称为 <strong>字段</strong>（<em>field</em>）。例如，示例 5-1 展示了一个存储用户账号信息的结构体：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
#}</code></pre></pre>
<p><span class="caption">示例 5-1：<code>User</code> 结构体定义</span></p>
<p>一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的 <strong>实例</strong>。创建一个实例需要以结构体的名字开头，接着在大括号中使用 <code>key: value</code> 键-值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。实例中字段的顺序不需要和它们在结构体中声明的顺序一致。换句话说，结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。例如，可以像示例 5-2 这样来声明一个特定的用户：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
#}</code></pre></pre>
<p><span class="caption">示例 5-2：创建 <code>User</code> 结构体的实例</span></p>
<p>为了从结构体中获取某个特定的值，可以使用点号。如果我们只想要用户的邮箱地址，可以用 <code>user1.email</code>。要更改结构体中的值，如果结构体的实例是可变的，我们可以使用点号并为对应的字段赋值。示例 5-3 展示了如何改变一个可变的 <code>User</code> 实例 <code>email</code> 字段的值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
#}</code></pre></pre>
<p><span class="caption">示例 5-3：改变 <code>User</code> 实例 <code>email</code> 字段的值</span></p>
<p>注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。</p>
<p>示例 5-4 显示了一个 <code>build_user</code> 函数，它返回一个带有给定的 email 和用户名的 <code>User</code> 结构体实例。<code>active</code> 字段的值为 <code>true</code>，并且 <code>sign_in_count</code> 的值为 <code>1</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 5-4：<code>build_user</code> 函数获取 email 和用户名并返回 <code>User</code> 实例</span></p>
<p>为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 <code>email</code> 和 <code>username</code> 字段名称与变量有些啰嗦。如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语法！</p>
<a class="header" href="print.html#a变量与字段同名时的字段初始化简写语法" id="a变量与字段同名时的字段初始化简写语法"><h3>变量与字段同名时的字段初始化简写语法</h3></a>
<p>因为示例 5-4 中的参数名与字段名都完全相同，我们可以使用 <strong>字段初始化简写语法</strong>（<em>field init shorthand</em>）来重写 <code>build_user</code>，这样其行为与之前完全相同，不过无需重复 <code>email</code> 和 <code>username</code> 了，如示例 5-5 所示。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 5-5：<code>build_user</code> 函数使用了字段初始化简写语法，因为 <code>email</code> 和 <code>username</code> 参数与结构体字段同名</span></p>
<p>这里我们创建了一个新的 <code>User</code> 结构体实例，它有一个叫做 <code>email</code> 的字段。我们想要将 <code>email</code> 字段的值设置为 <code>build_user</code> 函数 <code>email</code> 参数的值。因为 <code>email</code> 字段与 <code>email</code> 参数有着相同的名称，则只需编写 <code>email</code> 而不是 <code>email: email</code>。</p>
<a class="header" href="print.html#a使用结构体更新语法从其他实例创建实例" id="a使用结构体更新语法从其他实例创建实例"><h3>使用结构体更新语法从其他实例创建实例</h3></a>
<p>使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例通常是很有帮助的。这可以通过 <strong>结构体更新语法</strong>（<em>struct update syntax</em>）实现。</p>
<p>首先，示例 5-6 展示了不使用更新语法时，如何在 <code>user2</code> 中创建一个新 <code>User</code> 实例。我们为 <code>email</code> 和 <code>username</code> 设置了新的值，其他值则使用了实例 5-2 中创建的 <code>user1</code> 中的同名值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
#}</code></pre></pre>
<p><span class="caption">示例 5-6：创建 <code>User</code> 新实例，其使用了一些来自 <code>user1</code> 的值</span></p>
<p>使用结构体更新语法，我们可以通过更少的代码来达到相同的效果，如示例 5-7 所示。<code>..</code> 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
#}</code></pre></pre>
<p><span class="caption">示例 5-7：使用结构体更新语法为一个 <code>User</code> 实例设置新的 <code>email</code> 和 <code>username</code> 值，不过其余值来自 <code>user1</code> 变量中实例的字段</span></p>
<p>示例 5-7 中的代码也在 <code>user2</code> 中创建了一个新实例，其有不同的 <code>email</code> 和 <code>username</code> 值不过 <code>active</code> 和 <code>sign_in_count</code> 字段的值与 <code>user1</code> 相同。</p>
<a class="header" href="print.html#a使用没有命名字段的元组结构体来创建不同的类型" id="a使用没有命名字段的元组结构体来创建不同的类型"><h3>使用没有命名字段的元组结构体来创建不同的类型</h3></a>
<p>也可以定义与元组（在第三章讨论过）类似的结构体，称为 <strong>元组结构体</strong>（<em>tuple structs</em>）。元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p>
<p>定义元组结构体，以 <code>struct</code> 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 <code>Color</code> 和 <code>Point</code> 元组结构体的定义和用法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<p>注意 <code>black</code> 和 <code>origin</code> 值的类型不同，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。例如，一个获取 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，即便这两个类型都由三个 <code>i32</code> 值组成。在其他方面，元组结构体实例类似于元组：可以将其解构为单独的部分，也可以使用 <code>.</code> 后跟索引来访问单独的值，等等。</p>
<a class="header" href="print.html#a没有任何字段的类单元结构体" id="a没有任何字段的类单元结构体"><h3>没有任何字段的类单元结构体</h3></a>
<p>我们也可以定义一个没有任何字段的结构体！它们被称为 <strong>类单元结构体</strong>（<em>unit-like structs</em>）因为它们类似于 <code>()</code>，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。我们将在第十章介绍 trait。</p>
<blockquote>
<a class="header" href="print.html#a结构体数据的所有权" id="a结构体数据的所有权"><h2>结构体数据的所有权</h2></a>
<p>在示例 5-1 中的 <code>User</code> 结构体的定义中，我们使用了自身拥有所有权的 <code>String</code> 类型而不是 <code>&amp;str</code> 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。</p>
<p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>），这是一个第十章会讨论的 Rust 功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的，比如这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>编译器会抱怨它需要生命周期标识符：</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>第十章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们会使用像 <code>String</code> 这类拥有所有权的类型来替代 <code>&amp;str</code> 这样的引用以修正这个错误。</p>
</blockquote>
<a class="header" href="print.html#a一个使用结构体的示例程序" id="a一个使用结构体的示例程序"><h2>一个使用结构体的示例程序</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch05-02-example-structs.md">ch05-02-example-structs.md</a>
<br>
commit c560db1e0145d5a64b9415c9cfe463c7dac31ab8</p>
</blockquote>
<p>为了理解何时会需要使用结构体，让我们编写一个计算长方形面积的程序。我们会从单独的变量开始，接着重构程序直到使用结构体替代他们为止。</p>
<p>使用 Cargo 新建一个叫做 <em>rectangles</em> 的二进制程序，它获取以像素为单位的长方形的宽度和高度，并计算出长方形的面积。示例 5-8 显示了位于项目的 <em>src/main.rs</em> 中的小程序，它刚刚好实现此功能：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">示例 5-8：通过分别指定长方形的宽和高的变量来计算长方形面积</span></p>
<p>现在使用 <code>cargo run</code> 运行程序：</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
</code></pre>
<p>虽然示例 5-8 可以运行，并在调用 <code>area</code> 函数时传入每个维度来计算出长方形的面积，不过我们可以做的更好。宽度和高度是相关联的，因为他们在一起才能定义一个长方形。</p>
<p>这些代码的问题突显在 <code>area</code> 的签名上：</p>
<pre><code class="language-rust ignore">fn area(width: u32, height: u32) -&gt; u32 {
</code></pre>
<p>函数 <code>area</code> 本应该计算一个长方形的面积，不过函数却有两个参数。这两个参数是相关联的，不过程序本身却没有表现出这一点。将长度和宽度组合在一起将更易懂也更易处理。第三章的 “元组类型” 部分已经讨论过了一种可行的方法：元组。</p>
<a class="header" href="print.html#a使用元组重构" id="a使用元组重构"><h3>使用元组重构</h3></a>
<p>示例 5-9 展示了使用元组的另一个程序版本。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">示例 5-9：使用元组来指定长方形的宽高</span></p>
<p>在某种程度上说，这个程序更好一点了。元组帮助我们增加了一些结构性，并且现在只需传一个参数。不过在另一方面，这个版本却有一点不明确了：元组并没有给出元素的名称，所以计算变得更费解了，因为不得不使用索引来获取元组的每一部分：</p>
<p>在计算面积时将宽和高弄混倒无关紧要，不过当在屏幕上绘制长方形时就有问题了！我们必须牢记 <code>width</code> 的元组索引是 <code>0</code>，<code>height</code> 的元组索引是 <code>1</code>。如果其他人要使用这些代码，他们必须要搞清楚这一点，并也要牢记于心。很容易忘记或者混淆这些值而造成错误，因为我们没有在代码中传达数据的意图。</p>
<a class="header" href="print.html#a使用结构体重构赋予更多意义" id="a使用结构体重构赋予更多意义"><h3>使用结构体重构：赋予更多意义</h3></a>
<p>我们使用结构体为数据命名来为其赋予意义。我们可以将我们正在使用的元组转换成一个有整体名称而且每个部分也有对应名字的数据类型，如示例 5-10 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">示例 5-10：定义 <code>Rectangle</code> 结构体</span></p>
<p>这里我们定义了一个结构体并称其为 <code>Rectangle</code>。在大括号中定义了字段 <code>width</code> 和 <code>height</code>，类型都是 <code>u32</code>。接着在 <code>main</code> 中，我们创建了一个具体的 <code>Rectangle</code> 实例，它的宽是 30，高是 50。</p>
<p>函数 <code>area</code> 现在被定义为接收一个名叫 <code>rectangle</code> 的参数，其类型是一个结构体 <code>Rectangle</code> 实例的不可变借用。第四章讲到过，我们希望借用结构体而不是获取它的所有权，这样 <code>main</code> 函数就可以保持 <code>rect1</code> 的所有权并继续使用它，所以这就是为什么在函数签名和调用的地方会有 <code>&amp;</code>。</p>
<p><code>area</code> 函数访问 <code>Rectangle</code> 实例的 <code>width</code> 和 <code>height</code> 字段。<code>area</code> 的函数签名现在明确的阐述了我们的意图：使用 <code>Rectangle</code> 的 <code>width</code> 和 <code>height</code> 字段，计算 <code>Rectangle</code> 的面积。这表明宽高是相互联系的，并为这些值提供了描述性的名称而不是使用元组的索引值 <code>0</code> 和 <code>1</code> 。结构体胜在更清晰明了。</p>
<a class="header" href="print.html#a通过派生-trait-增加实用功能" id="a通过派生-trait-增加实用功能"><h3>通过派生 trait 增加实用功能</h3></a>
<p>如果能够在调试程序时打印出 <code>Rectangle</code> 实例来查看其所有字段的值就更好了。示例 5-11 像前面章节那样尝试使用 <code>println!</code> 宏。但这并不行。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">示例 5-11：尝试打印出 <code>Rectangle</code> 实例</span></p>
<p>当我们运行这个代码时，会出现带有如下核心信息的错误：</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
</code></pre>
<p><code>println!</code> 宏能处理很多类型的格式，不过，<code>{}</code> 默认告诉 <code>println!</code> 使用被称为 <code>Display</code> 的格式：意在提供给直接终端用户查看的输出。目前为止见过的基本类型都默认实现了 <code>Display</code>，因为它就是向用户展示 <code>1</code> 或其他任何基本类型的唯一方式。不过对于结构体，<code>println!</code> 应该用来输出的格式是不明确的，因为这有更多显示的可能性：是否需要逗号？需要打印出大括号吗？所有字段都应该显示吗？由于这种不确定性，Rust 不会尝试猜测我们的意图，所以结构体并没有提供一个 <code>Display</code> 实现。</p>
<p>但是如果我们继续阅读错误，将会发现这个有帮助的信息：</p>
<pre><code class="language-text">`Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
</code></pre>
<p>让我们来试试！现在 <code>println!</code> 宏调用看起来像 <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code> 这样。在 <code>{}</code> 中加入 <code>:?</code> 指示符告诉 <code>println!</code> 我们想要使用叫做 <code>Debug</code> 的输出格式。<code>Debug</code> 是一个 trait，它允许我们以一种对开发者有帮助的方式打印结构体，以便当我们调试代码时能看到它的值。</p>
<p>这样调整后再次运行程序。见鬼了！仍然能看到一个错误：</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
</code></pre>
<p>不过编译器又一次给出了一个有帮助的信息！</p>
<pre><code class="language-text">`Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
</code></pre>
<p>Rust <strong>确实</strong> 包含了打印出调试信息的功能，不过我们必须为结构体显式选择这个功能。为此，在结构体定义之前加上 <code>#[derive(Debug)]</code> 注解，如示例 5-12 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">示例 5-12：增加注解来派生 <code>Debug</code> trait，并使用调试格式打印 <code>Rectangle</code> 实例</span></p>
<p>现在我们再运行这个程序时，就不会有任何错误，并会出现如下输出：</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>好极了！这并不是最漂亮的输出，不过它显示这个实例的所有字段，毫无疑问这对调试有帮助。当我们有一个更大的结构体时，能有更易读一点的输出就好了，为此可以使用 <code>{:#?}</code> 替换 <code>println!</code> 字符串中的 <code>{:?}</code>。如果在这个例子中使用了 <code>{:#?}</code> 风格的话，输出会看起来像这样：</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50
}
</code></pre>
<p>Rust 为我们提供了很多可以通过 <code>derive</code> 注解来使用的 trait，他们可以为我们的自定义类型增加实用的行为。附录 C 中列出了这些 trait 和行为。第十章会介绍如何通过自定义行为来实现这些 trait，同时还有如何创建你自己的 trait。</p>
<p>我们的 <code>area</code> 函数是非常特殊的，它只计算长方形的面积。如果这个行为与 <code>Rectangle</code> 结构体再结合得更紧密一些就更好了，因为它不能用于其他类型。现在让我们看看如何继续重构这些代码，来将 <code>area</code> 函数协调进 <code>Rectangle</code> 类型定义的 <code>area</code> <strong>方法</strong> 中。</p>
<a class="header" href="print.html#a方法语法" id="a方法语法"><h2>方法语法</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch05-03-method-syntax.md">ch05-03-method-syntax.md</a>
<br>
commit c560db1e0145d5a64b9415c9cfe463c7dac31ab8</p>
</blockquote>
<p><strong>方法</strong> 与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<a class="header" href="print.html#a定义方法" id="a定义方法"><h3>定义方法</h3></a>
<p>让我们把前面实现的获取一个 <code>Rectangle</code> 实例作为参数的 <code>area</code> 函数，改写成一个定义于 <code>Rectangle</code> 结构体上的 <code>area</code> 方法，如示例 5-13 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">示例 5-13：在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法</span></p>
<p>为了使函数定义于 <code>Rectangle</code> 的上下文中，我们开始了一个 <code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写）。接着将 <code>area</code> 函数移动到 <code>impl</code> 大括号中，并将签名中的第一个（在这里也是唯一一个）参数和函数体中其他地方的对应参数改成 <code>self</code>。然后在 <code>main</code> 中将我们先前调用 <code>area</code> 方法并传递 <code>rect1</code> 作为参数的地方，改成使用 <strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p>
<p>在 <code>area</code> 的签名中，使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>，因为该方法位于 <code>impl Rectangle</code> 上下文中所以 Rust 知道 <code>self</code> 的类型是 <code>Rectangle</code>。注意仍然需要在 <code>self</code> 前面加上 <code>&amp;</code>，就像 <code>&amp;Rectangle</code> 一样。方法可以选择获取 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p>
<p>这里选择 <code>&amp;self</code> 的理由跟在函数版本中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。如果想要在方法中改变调用方法的实例，需要将第一个参数改为 <code>&amp;mut self</code>。通过仅仅使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 <code>self</code> 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。</p>
<p>使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 <code>self</code> 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 <code>impl</code> 块中，而不是让将来的用户在我们的库中到处寻找 <code>Rectangle</code> 的功能。</p>
<blockquote>
<a class="header" href="print.html#a--运算符到哪去了" id="a--运算符到哪去了"><h3><code>-&gt;</code> 运算符到哪去了？</h3></a>
<p>在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 就像 <code>(*object).something()</code> 一样。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug,Copy,Clone)]
# struct Point {
#     x: f64,
#     y: f64,
# }
#
# impl Point {
#    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
#        let x_squared = f64::powi(other.x - self.x, 2);
#        let y_squared = f64::powi(other.y - self.y, 2);
#
#        f64::sqrt(x_squared + y_squared)
#    }
# }
# let p1 = Point { x: 0.0, y: 0.0 };
# let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
#}</code></pre></pre>
<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</blockquote>
<a class="header" href="print.html#a带有更多参数的方法" id="a带有更多参数的方法"><h3>带有更多参数的方法</h3></a>
<p>让我们通过实现 <code>Rectangle</code> 结构体上的另一方法来练习使用方法。这回，我们让一个 <code>Rectangle</code> 的实例获取另一个 <code>Rectangle</code> 实例，如果 <code>self</code> 能完全包含第二个长方形则返回 <code>true</code>；否则返回 <code>false</code>。一旦定义了 <code>can_hold</code> 方法，就可以编写示例 5-14 中的代码。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">示例 5-14：使用还未实现的 <code>can_hold</code> 方法</span></p>
<p>同时我们希望看到如下输出，因为 <code>rect2</code> 的两个维度都小于 <code>rect1</code>，而 <code>rect3</code> 比 <code>rect1</code> 要宽：</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>因为我们想定义一个方法，所以它应该位于 <code>impl Rectangle</code> 块中。方法名是 <code>can_hold</code>，并且它会获取另一个 <code>Rectangle</code> 的不可变借用作为参数。通过观察调用方法的代码可以看出参数是什么类型的：<code>rect1.can_hold(&amp;rect2)</code> 传入了 <code>&amp;rect2</code>，它是一个 <code>Rectangle</code> 的实例 <code>rect2</code> 的不可变借用。这是可以理解的，因为我们只需要读取 <code>rect2</code>（而不是写入，这意味着我们需要一个可变借用），而且希望 <code>main</code> 保持 <code>rect2</code> 的所有权，这样就可以在调用这个方法后继续使用它。<code>can_hold</code> 的返回值是一个布尔值，其实现会分别检查 <code>self</code> 的宽高是否都大于另一个 <code>Rectangle</code>。让我们在示例 5-13 的 <code>impl</code> 块中增加这个新的 <code>can_hold</code> 方法，如示例 5-15 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 5-15：在 <code>Rectangle</code> 上实现 <code>can_hold</code> 方法，它获取另一个 <code>Rectangle</code> 实例作为参数</span></p>
<p>如果结合示例 5-14 的 <code>main</code> 函数来运行，就会看到期望的输出。在方法签名中，可以在 <code>self</code> 后增加多个参数，而且这些参数就像函数中的参数一样工作。</p>
<a class="header" href="print.html#a关联函数" id="a关联函数"><h3>关联函数</h3></a>
<p><code>impl</code> 块的另一个有用的功能是：允许在 <code>impl</code> 块中定义 <strong>不</strong> 以 <code>self</code> 作为参数的函数。这被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 <code>String::from</code> 关联函数了。</p>
<p>关联函数经常被用作返回一个结构体新实例的构造函数。例如我们可以提供一个关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 <code>Rectangle</code> 而不必指定两次同样的值：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
#}</code></pre></pre>
<p>使用结构体名和 <code>::</code> 语法来调用这个关联函数：比如 <code>let sq = Rectangle::square(3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。第七章会讲到模块。</p>
<a class="header" href="print.html#a多个-impl-块" id="a多个-impl-块"><h3>多个 <code>impl</code> 块</h3></a>
<p>每个结构体都允许拥有多个 <code>impl</code> 块。例如，示例 5-16 中的代码等同于示例 5-15，但每个方法有其自己的 <code>impl</code> 块。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 5-16：使用多个 <code>impl</code> 块重写示例 5-15</span></p>
<p>这里没有理由将这些方法分散在多个 <code>impl</code> 块中，不过这是有效的语法。第十章讨论泛型和 trait 时会看到实用的多 <code>impl</code> 块的用例。</p>
<a class="header" href="print.html#a总结-4" id="a总结-4"><h2>总结</h2></a>
<p>结构体让你可以创建出在你的领域中有意义的自定义类型。通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。方法允许为结构体实例指定行为，而关联函数将特定功能置于结构体的命名空间中并且无需一个实例。</p>
<p>但结构体并不是创建自定义类型的唯一方法：让我们转向 Rust 的枚举功能，为你的工具箱再添一个工具。</p>
<a class="header" href="print.html#a枚举和模式匹配" id="a枚举和模式匹配"><h1>枚举和模式匹配</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch06-00-enums.md">ch06-00-enums.md</a>
<br>
commit e3be64b3c034de029ae9e4f04e6d2742d799d2b1</p>
</blockquote>
<p>本章介绍 <strong>枚举</strong>（<em>enumerations</em>），也被称作 <em>enums</em>。枚举允许你通过列举可能的值来定义一个类型。首先，我们会定义并使用一个枚举来展示它是如何连同数据一起编码信息的。接下来，我们会探索一个特别有用的枚举，叫做 <code>Option</code>，它代表一个值要么是某个值要么什么都不是。然后会讲到在 <code>match</code> 表达式中用模式匹配，针对不同的枚举值编写相应要执行的代码。最后会介绍 <code>if let</code>，另一个简洁方便处理代码中枚举的结构。</p>
<p>枚举是一个很多语言都有的功能，不过不同语言中其功能各不相同。Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 <strong>代数数据类型</strong>（<em>algebraic data types</em>）最为相似。</p>
<a class="header" href="print.html#a定义枚举" id="a定义枚举"><h1>定义枚举</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch06-01-defining-an-enum.md">ch06-01-defining-an-enum.md</a>
<br>
commit 923201d5117c45bf78ce433422b50e4de9bd9b11</p>
</blockquote>
<p>让我们看看一个需要诉诸于代码的场景，来考虑为何此时使用枚举更为合适且实用。假设我们要处理 IP 地址。目前被广泛使用的两个主要 IP 标准：IPv4（version four）和 IPv6（version six）。这是我们的程序可能会遇到的所有可能的 IP 地址类型：所以可以 <strong>枚举</strong> 出所有可能的值，这也正是此枚举名字的由来。</p>
<p>任何一个 IP 地址要么是 IPv4 的要么是 IPv6 的，而且不能两者都是。IP 地址的这个特性使得枚举数据结构非常适合这个场景，因为枚举值只可能是其中一个成员。IPv4 和 IPv6 从根本上讲仍是 IP 地址，所以当代码在处理适用于任何类型的 IP 地址的场景时应该把它们当作相同的类型。</p>
<p>可以通过在代码中定义一个 <code>IpAddrKind</code> 枚举来表现这个概念并列出可能的 IP 地址类型，<code>V4</code> 和 <code>V6</code>。这被称为枚举的 <strong>成员</strong>（<em>variants</em>）：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}
#}</code></pre></pre>
<p>现在 <code>IpAddrKind</code> 就是一个可以在代码中使用的自定义数据类型了。</p>
<a class="header" href="print.html#a枚举值" id="a枚举值"><h3>枚举值</h3></a>
<p>可以像这样创建 <code>IpAddrKind</code> 两个不同成员的实例：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#}</code></pre></pre>
<p>注意枚举的成员位于其标识符的命名空间中，并使用两个冒号分开。这么设计的益处是现在 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 都是 <code>IpAddrKind</code> 类型的。例如，接着可以定义一个函数来获取任何 <code>IpAddrKind</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_type: IpAddrKind) { }
#}</code></pre></pre>
<p>现在可以使用任一成员来调用这个函数：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_type: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
#}</code></pre></pre>
<p>使用枚举甚至还有更多优势。进一步考虑一下我们的 IP 地址类型，目前没有一个存储实际 IP 地址 <strong>数据</strong> 的方法；只知道它是什么 <strong>类型</strong> 的。考虑到已经在第五章学习过结构体了，你可能会像示例 6-1 那样处理这个问题：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">示例 6-1：将 IP 地址的数据和 <code>IpAddrKind</code> 成员存储在一个 <code>struct</code> 中</span></p>
<p>这里我们定义了一个有两个字段的结构体 <code>IpAddr</code>：<code>IpAddrKind</code>（之前定义的枚举）类型的 <code>kind</code> 字段和 <code>String</code> 类型 <code>address</code> 字段。我们有这个结构体的两个实例。第一个，<code>home</code>，它的 <code>kind</code> 的值是 <code>IpAddrKind::V4</code> 与之相关联的地址数据是 <code>127.0.0.1</code>。第二个实例，<code>loopback</code>，<code>kind</code> 的值是 <code>IpAddrKind</code> 的另一个成员，<code>V6</code>，关联的地址是 <code>::1</code>。我们使用了一个结构体来将 <code>kind</code> 和 <code>address</code> 打包在一起，现在枚举成员就与值相关联了。</p>
<p>我们可以使用一种更简洁的方式来表达相同的概念，仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。<code>IpAddr</code> 枚举的新定义表明了 <code>V4</code> 和 <code>V6</code> 成员都关联了 <code>String</code> 值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
<p>用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。IPv4 版本的 IP 地址总是含有四个值在 0 和 255 之间的数字部分。如果我们想要将 <code>V4</code> 地址存储为四个 <code>u8</code> 值而 <code>V6</code> 地址仍然表现为一个 <code>String</code>，这就不能使用结构体了。枚举则可以轻易处理的这个情况：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>这些代码展示了使用枚举来存储两种不同 IP 地址的几种可能的选择。然而，事实证明存储和编码 IP 地址实在是太常见了<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">以致标准库提供了一个开箱即用的定义！</a><!-- ignore -->让我们看看标准库是如何定义 <code>IpAddr</code> 的：它正有着跟我们定义和使用的一样的枚举和成员，不过它将成员中的地址数据嵌入到了两个不同形式的结构体中，它们对不同的成员的定义是不同的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>这些代码展示了可以将任意类型的数据放入枚举成员中：例如字符串、数字类型或者结构体。甚至可以包含另一个枚举！另外，标准库中的类型通常并不比你设想出来的要复杂多少。</p>
<p>注意虽然标准库中包含一个 <code>IpAddr</code> 的定义，仍然可以创建和使用我们自己的定义而不会有冲突，因为我们并没有将标准库中的定义引入作用域。第七章会讲到如何导入类型。</p>
<p>来看看示例 6-2 中的另一个枚举的例子：它的成员中内嵌了多种多样的类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">示例 6-2：一个 <code>Message</code> 枚举，其每个成员都存储了不同数量和类型的值</span></p>
<p>这个枚举有四个含有不同类型的成员：</p>
<ul>
<li><code>Quit</code> 没有关联任何数据。</li>
<li><code>Move</code> 包含一个匿名结构体。</li>
<li><code>Write</code> 包含单独一个 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li>
</ul>
<p>定义一个如示例 6-2 中所示那样的有关联值的枚举的方式和定义多个不同类型的结构体的方式很相像——除了枚举不使用 <code>struct</code> 关键字以及其所有成员都被组合在一起位于 <code>Message</code> 类型下。如下这些结构体可以包含与之前枚举成员中相同的数据：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct QuitMessage; // 类单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
#}</code></pre></pre>
<p>不过，如果我们使用不同的结构体，由于它们都有不同的类型，我们将不能像使用示例 6-2 中定义的 <code>Message</code> 枚举那样，轻易的定义一个能够处理这些不同类型的结构体的函数。因为使用枚举的情况下，“它们”是一个类型。</p>
<p>结构体和枚举还有另一个相似点：就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。这是一个定义于我们 <code>Message</code> 枚举上的叫做 <code>call</code> 的方法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&amp;self) {
        // 在这里定义方法体
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
#}</code></pre></pre>
<p>方法体使用了 <code>self</code> 来获取调用方法的值。这个例子中，创建了一个值为 <code>Message::Write(String::from(&quot;hello&quot;))</code> 的变量 <code>m</code>，而且这就是当 <code>m.call()</code> 运行时 <code>call</code> 方法中的 <code>self</code> 的值。</p>
<p>让我们看看标准库中的另一个非常常见且实用的枚举：<code>Option</code>。</p>
<a class="header" href="print.html#option-枚举和其相对于空值的优势" id="option-枚举和其相对于空值的优势"><h3><code>Option</code> 枚举和其相对于空值的优势</h3></a>
<p>在之前的部分，我们看到了 <code>IpAddr</code> 枚举如何利用 Rust 的类型系统在程序中编码更多信息而不单单是数据。接下来我们分析一个 <code>Option</code> 的案例，<code>Option</code> 是标准库定义的另一个枚举。<code>Option</code> 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。从类型系统的角度来表达这个概念就意味着编译器需要检查是否处理了所有应该处理的情况，这样就可以避免在其他编程语言中非常常见的 bug。</p>
<p>编程语言的设计经常要考虑包含哪些功能，但考虑排除哪些功能也很重要。Rust 并没有很多其他语言中有的空值功能。<strong>空值</strong>（<em>Null</em> ）是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。</p>
<p>Tony Hoare，null 的发明者，在他 2009 年的演讲 “Null References: The Billion Dollar Mistake” 中曾经说到：</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My
goal was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn't resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in
the last forty years.</p>
<p>我称之为我十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。</p>
</blockquote>
<p>空值的问题在于当你尝试像一个非空值那样使用一个空值，会出现某种形式的错误。因为空和非空的属性无处不在，非常容易出现这类错误。</p>
<p>然而，空值尝试表达的概念仍然是有意义的：空值是一个因为某种原因目前无效或缺失的值。</p>
<p>问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>，而且它<a href="https://doc.rust-lang.org/std/option/enum.Option.html">定义于标准库中</a><!-- ignore -->，如下:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要 <code>Option::</code> 前缀来直接使用 <code>Some</code> 和 <code>None</code>。即便如此 <code>Option&lt;T&gt;</code> 也仍是常规的枚举，<code>Some(T)</code> 和 <code>None</code> 仍是 <code>Option&lt;T&gt;</code> 的成员。</p>
<p><code>&lt;T&gt;</code> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。目前，所有你需要知道的就是 <code>&lt;T&gt;</code> 意味着 <code>Option</code> 枚举的 <code>Some</code> 成员可以包含任意类型的数据。这里是一些包含数字类型和字符串类型 <code>Option</code> 值的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>如果使用 <code>None</code> 而不是 <code>Some</code>，需要告诉 Rust <code>Option&lt;T&gt;</code> 是什么类型的，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 成员保存的值的类型。</p>
<p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T&gt;</code> 为什么就比空值要好呢？</p>
<p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code>。例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加：</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>哇哦！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>不再担心会错误的假设一个非空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 <code>Option&lt;T&gt;</code> 的值时，如何从 <code>Some</code> 成员中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T&gt;</code> 枚举拥有大量用于各种情况的方法：你可以查看<a href="https://doc.rust-lang.org/std/option/enum.Option.html">它的文档</a><!-- ignore -->。熟悉 <code>Option&lt;T&gt;</code> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 <code>Option&lt;T&gt;</code> 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
<a class="header" href="print.html#match-控制流运算符" id="match-控制流运算符"><h2><code>match</code> 控制流运算符</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch06-02-match.md">ch06-02-match.md</a>
<br>
commit 18fd30d70f4d6ee67e0a808710bf7a3135ef7ed6</p>
</blockquote>
<p>Rust 有一个叫做 <code>match</code> 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成；第十八章会涉及到所有不同种类的模式以及它们的作用。<code>match</code> 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。</p>
<p>可以把 <code>match</code> 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 <code>match</code> 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。</p>
<p>因为刚刚提到了硬币，让我们用它们来作为一个使用 <code>match</code> 的例子！我们可以编写一个函数来获取一个未知的（美帝）硬币，并以一种类似验钞机的方式，确定它是何种硬币并返回它的美分值，如示例 6-3 中所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 6-3：一个枚举和一个以枚举成员作为模式的 <code>match</code> 表达式</span></p>
<p>拆开 <code>value_in_cents</code> 函数中的 <code>match</code> 来看。首先，我们列出 <code>match</code> 关键字后跟一个表达式，在这个例子中是 <code>coin</code> 的值。这看起来非常像 <code>if</code> 使用的表达式，不过这里有一个非常大的区别：对于 <code>if</code>，表达式必须返回一个布尔值。而这里它可以是任何类型的。例子中的 <code>coin</code> 的类型是示例 6-3 中定义的 <code>Coin</code> 枚举。</p>
<p>接下来是 <code>match</code> 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 <code>Coin::Penny</code> 而之后的 <code>=&gt;</code> 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 <code>1</code>。每一个分支之间使用逗号分隔。</p>
<p>当 <code>match</code> 表达式执行时，它将结果值按顺序与每一个分支的模式相比较，如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支，非常类似一个硬币分类器。可以拥有任意多的分支：示例 6-3 中的 <code>match</code> 有四个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 <code>match</code> 表达式的返回值。</p>
<p>如果分支代码较短的话通常不使用大括号，正如示例 6-3 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a绑定值的模式" id="a绑定值的模式"><h3>绑定值的模式</h3></a>
<p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。</p>
<p>作为一个例子，让我们修改枚举的一个成员来存放数据。1999 年到 2008 年间，美帝在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 25 美分硬币有特殊的价值。可以将这些信息加入我们的 <code>enum</code>，通过改变 <code>Quarter</code> 成员来包含一个 <code>State</code> 值，示例 6-4 中完成了这些修改：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
#}</code></pre></pre>
<p><span class="caption">示例 6-4：<code>Quarter</code> 成员也存放了一个 <code>UsState</code> 值的 <code>Coin</code> 枚举</span></p>
<p>想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。</p>
<p>在这些代码的匹配表达式中，我们在匹配 <code>Coin::Quarter</code> 成员的分支的模式中增加了一个叫做 <code>state</code> 的变量。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 将会绑定 25 美分硬币所对应州的值。接着在那个分支的代码中使用 <code>state</code>，如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
#}</code></pre></pre>
<p>如果调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当将值与每个分支相比较时，没有分支会匹配，直到遇到 <code>Coin::Quarter(state)</code>。这时，<code>state</code> 绑定的将会是值 <code>UsState::Alaska</code>。接着就可以在 <code>println!</code> 表达式中使用这个绑定了，像这样就可以获取 <code>Coin</code> 枚举的 <code>Quarter</code> 成员中内部的州的值。</p>
<a class="header" href="print.html#a匹配-optiont" id="a匹配-optiont"><h3>匹配 <code>Option&lt;T&gt;</code></h3></a>
<p>在之前的部分在使用 <code>Option&lt;T&gt;</code> 时我们想要从 <code>Some</code> 中取出其内部的 <code>T</code> 值；也可以像处理 <code>Coin</code> 枚举那样使用 <code>match</code> 处理 <code>Option&lt;T&gt;</code>！与其直接比较硬币，我们将比较 <code>Option&lt;T&gt;</code> 的成员，不过 <code>match</code> 表达式的工作方式保持不变。</p>
<p>比如我们想要编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code> 并且如果其中有一个值，将其加一。如果其中没有值，函数应该返回 <code>None</code> 值并不尝试执行任何操作。</p>
<p>得益于 <code>match</code>，编写这个函数非常简单，它将看起来像示例 6-5 中这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#}</code></pre></pre>
<p><span class="caption">示例 6-5：一个在 <code>Option&lt;i32&gt;</code> 上使用 <code>match</code> 表达式的函数</span></p>
<a class="header" href="print.html#a匹配-somet" id="a匹配-somet"><h4>匹配 <code>Some(T)</code></h4></a>
<p>让我们更仔细的检查 <code>plus_one</code> 的第一行操作。当调用 <code>plus_one(five)</code> 时，<code>plus_one</code> 函数体中的 <code>x</code> 将会是值 <code>Some(5)</code>。接着将其与每个分支比较。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>值 <code>Some(5)</code> 并不匹配模式 <code>None</code>，所以继续进行下一个分支。</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5)</code> 与 <code>Some(i)</code> 匹配吗？当然匹配！它们是相同的成员。<code>i</code> 绑定了 <code>Some</code> 中包含的值，所以 <code>i</code> 的值是 <code>5</code>。接着匹配分支的代码被执行，所以我们将 <code>i</code> 的值加一并返回一个含有值 <code>6</code> 的新 <code>Some</code>。</p>
<a class="header" href="print.html#a匹配-none" id="a匹配-none"><h4>匹配 <code>None</code></h4></a>
<p>接着考虑下示例 6-5 中 <code>plus_one</code> 的第二个调用，这里 <code>x</code> 是 <code>None</code>。我们进入 <code>match</code> 并与第一个分支相比较。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>匹配上了！这里没有值来加一，所以程序结束并返回 <code>=&gt;</code> 右侧的值 <code>None</code>，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<p>将 <code>match</code> 与枚举相结合在很多场景中都是有用的。你会在 Rust 代码中看到很多这样的模式：<code>match</code> 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯了，你会希望所有语言都拥有它！这一直是用户的最爱。</p>
<a class="header" href="print.html#a匹配是穷尽的" id="a匹配是穷尽的"><h3>匹配是穷尽的</h3></a>
<p><code>match</code> 还有另一方面需要讨论。考虑一下 <code>plus_one</code> 函数的这个版本：</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>Rust 知道我们没有覆盖所有可能的情况甚至知道那些模式被忘记了！Rust 中的匹配是 <strong>穷尽的</strong>（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这使我们免于假设拥有一个实际上为空的值，这造成了之前提到过的价值亿万的错误。</p>
<a class="header" href="print.html#a_-通配符" id="a_-通配符"><h3><code>_</code> 通配符</h3></a>
<p>Rust 也提供了一个模式用于不想列举出所有可能值的场景。例如，<code>u8</code> 可以拥有 0 到 255 的有效的值，如果我们只关心 1、3、5 和 7 这几个值，就并不想必须列出 0、2、4、6、8、9 一直到 255 的值。所幸我们不必这么做：可以使用特殊的模式 <code>_</code> 替代：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><code>_</code> 模式会匹配所有的值。通过将其放置于其他分支之后，<code>_</code> 将会匹配所有之前没有指定的可能的值。<code>()</code> 就是 unit 值，所以 <code>_</code> 的情况什么也不会发生。因此，可以说我们想要对 <code>_</code> 通配符之前没有列出的所有可能的值不做任何处理。</p>
<p>然而，<code>match</code> 在只关心 <strong>一个</strong> 情况的场景中可能就有点啰嗦了。为此 Rust 提供了<code>if let</code>。</p>
<a class="header" href="print.html#if-let-简单控制流" id="if-let-简单控制流"><h2><code>if let</code> 简单控制流</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch06-03-if-let.md">ch06-03-if-let.md</a>
<br>
commit 3f2a1bd8dbb19cc48b210fc4fb35c305c8d81b56</p>
</blockquote>
<p><code>if let</code> 语法让我们以一种不那么冗长的方式结合 <code>if</code> 和 <code>let</code>，来处理只匹配一个模式的值而忽略其他模式的情况。考虑示例 6-6 中的程序，它匹配一个 <code>Option&lt;u8&gt;</code> 值并只希望当值为三时执行代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">示例 6-6：<code>match</code> 只关心当值为 <code>Some(3)</code> 时执行代码</span></p>
<p>我们想要对 <code>Some(3)</code> 匹配进行操作但是不想处理任何其他 <code>Some&lt;u8&gt;</code> 值或 <code>None</code> 值。为了满足 <code>match</code> 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样也要增加很多样板代码。</p>
<p>不过我们可以使用 <code>if let</code> 这种更短的方式编写。如下代码与示例 6-6 中的 <code>match</code> 行为一致：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> 获取通过 <code>=</code> 分隔的一个模式和一个表达式。它的工作方式与 <code>match</code> 相同，这里的表达式对应 <code>match</code> 而模式则对应第一个分支。</p>
<p>使用 <code>if let</code> 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 <code>match</code> 强制要求的穷尽性检查。<code>match</code> 和 <code>if let</code> 之间的选择依赖特定的环境以及增加简洁度和失去穷尽性检查的权衡取舍。</p>
<p>换句话说，可以认为 <code>if let</code> 是 <code>match</code> 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。</p>
<p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。回忆一下示例 6-4 中 <code>Coin</code> 枚举的定义，其 <code>Quarter</code> 成员也包含一个 <code>UsState</code> 值。如果想要计数所有不是 25 美分的硬币的同时也报告 25 美分硬币所属的州，可以使用这样一个 <code>match</code> 表达式：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
#}</code></pre></pre>
<p>或者可以使用这样的 <code>if let</code> 和 <code>else</code> 表达式：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
#}</code></pre></pre>
<p>如果你的程序遇到一个使用 <code>match</code> 表达起来过于啰嗦的逻辑，记住 <code>if let</code> 也在你的 Rust 工具箱中。</p>
<a class="header" href="print.html#a总结-5" id="a总结-5"><h2>总结</h2></a>
<p>现在我们涉及到了如何使用枚举来创建有一系列可列举值的自定义类型。我们也展示了标准库的 <code>Option&lt;T&gt;</code> 类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据需要处理多少情况来选择使用 <code>match</code> 或 <code>if let</code> 来获取并使用这些值。</p>
<p>你的 Rust 程序现在能够使用结构体和枚举在自己的作用域内表现其内容了。在你的 API 中使用自定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。</p>
<p>为了向你的用户提供一个组织良好的 API，它使用起来很直观并且只向用户暴露他们确实需要的部分，那么现在就让我们转向 Rust 的模块系统吧。</p>
<a class="header" href="print.html#a使用模块组织和复用代码" id="a使用模块组织和复用代码"><h1>使用模块组织和复用代码</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch07-00-modules.md">ch07-00-modules.md</a>
<br>
commit 050ff6f34f107b2c8695807fc16aeb827ffe1fa3</p>
</blockquote>
<p>在你刚开始编写 Rust 程序时，代码可能仅仅位于 <code>main</code> 函数中。随着代码量的增长，为了复用和更好地组织代码，最终你会将功能移动到其他函数中。通过将代码拆分成更小的块，每一个块就更易于理解。但是如果你有太多的函数该怎么办呢？Rust 有一个模块系统，可以有组织地复用代码。</p>
<p>就跟你将代码行提取到一个函数中一样，也可以将函数（和其他代码，例如结构体和枚举）提取到不同模块中。<strong>模块</strong>（<em>module</em>）是一个包含函数或类型定义的命名空间，你可以选择这些定义能（公有）或不能（私有）在其模块外可见。下面是一个模块如何工作的梗概：</p>
<ul>
<li>使用 <code>mod</code> 关键字声明新模块。此模块中的代码要么直接位于声明之后的大括号中，要么位于另一个文件。</li>
<li>函数、类型、常量和模块默认都是私有的。可以使用 <code>pub</code> 关键字将其变成公有并在其命名空间之外可见。</li>
<li><code>use</code> 关键字将模块或模块中的定义引入到作用域中以便于引用它们。</li>
</ul>
<p>我们会逐一了解这每一部分并学习如何将它们结合在一起。</p>
<a class="header" href="print.html#mod-和文件系统" id="mod-和文件系统"><h2><code>mod</code> 和文件系统</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch07-01-mod-and-the-filesystem.md">ch07-01-mod-and-the-filesystem.md</a>
<br>
commit a120c730714e07f8f32d905e9374a50b2e0ffdf5</p>
</blockquote>
<p>我们将通过使用 Cargo 创建一个新项目来开始我们的模块之旅，不过这次不再创建一个二进制 crate，而是创建一个库 crate：一个其他人可以作为依赖导入的项目。第二章猜猜看游戏中作为依赖使用的 <code>rand</code> 就是这样的 crate。</p>
<p>我们将创建一个库的框架，提供一些通用的网络功能；我们将专注于模块和函数的组织，而不必担心函数体中的具体代码。这个项目叫做 <code>communicator</code>。若要创建一个库，应当使用 <code>--lib</code> 参数而不是之前所用的 <code>--bin</code> 参数：</p>
<pre><code class="language-text">$ cargo new communicator --lib
$ cd communicator
</code></pre>
<p>注意 Cargo 生成了 <em>src/lib.rs</em> 而不是 <em>src/main.rs</em>。在 <em>src/lib.rs</em> 中我们会找到这些：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo 创建了一个空的测试来帮助我们开始库项目，不像使用 <code>--bin</code> 参数那样创建一个 “Hello, world!” 二进制项目。在本章之后的 “使用 <code>super</code> 访问父模块” 部分会介绍 <code>#[]</code> 和 <code>mod tests</code> 语法，目前只需确保它们位于 <em>src/lib.rs</em> 底部即可。</p>
<p>因为没有 <em>src/main.rs</em> 文件，所以没有可供 Cargo 的 <code>cargo run</code> 执行的东西。因此，我们将只使用 <code>cargo build</code> 命令编译库 crate 的代码。</p>
<p>我们将学习根据编写代码的意图来以不同方法组织库项目代码以适应多种情况。</p>
<a class="header" href="print.html#a模块定义" id="a模块定义"><h3>模块定义</h3></a>
<p>对于 <code>communicator</code> 网络库，首先要定义一个叫做 <code>network</code> 的模块，它包含一个叫做 <code>connect</code> 的函数定义。Rust 中所有模块的定义都以关键字 <code>mod</code> 开始。在 <em>src/lib.rs</em> 文件的开头在测试代码的上面增加这些代码：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><code>mod</code> 关键字的后面是模块的名字，<code>network</code>，接着是位于大括号中的代码块。代码块中的一切都位于 <code>network</code> 命名空间中。在这个例子中，只有一个函数，<code>connect</code>。如果想要在 <code>network</code> 模块外面的代码中调用这个函数，需要指定模块名并使用命名空间语法 <code>::</code>，像这样：<code>network::connect()</code>。</p>
<p>也可以在 <em>src/lib.rs</em> 文件中同时存在多个模块。例如，再拥有一个 <code>client</code> 模块，它也有一个叫做 <code>connect</code> 的函数，如示例 7-1 中所示那样增加这个模块：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 7-1：<code>network</code> 模块和 <code>client</code> 一同定义于 <em>src/lib.rs</em></span></p>
<p>现在我们有了 <code>network::connect</code> 函数和 <code>client::connect</code> 函数。它们可能有着完全不同的功能，同时它们也不会彼此冲突，因为它们位于不同的模块。</p>
<p>在这个例子中，因为我们构建的是一个库，作为库入口点的文件是 <em>src/lib.rs</em>。然而，对于创建模块来说，<em>src/lib.rs</em> 并没有什么特殊意义。也可以在二进制 crate 的 <em>src/main.rs</em> 中创建模块，正如在库 crate 的 <em>src/lib.rs</em> 创建模块一样。事实上，也可以将模块放入其他模块中。这有助于随着模块的增长，将相关的功能组织在一起并又保持各自独立。选择组织代码的方式取决于如何考虑代码各部分之间的关系。例如，对于库的用户来说，<code>client</code> 模块和它的函数 <code>connect</code> 可能放在 <code>network</code> 命名空间里显得更有道理，如示例 7-2 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 7-2：将 <code>client</code> 模块移动到 <code>network</code> 模块中</span></p>
<p>在 <em>src/lib.rs</em> 文件中，将现有的 <code>mod network</code> 和 <code>mod client</code> 的定义替换为示例 7-2 中的定义，这里将 <code>client</code> 模块作为 <code>network</code> 的一个内部模块。现在我们有了 <code>network::connect</code> 和 <code>network::client::connect</code> 函数：它们都叫 <code>connect</code> ，但它们并不互相冲突，因为它们在不同的命名空间中。</p>
<p>这样，模块之间形成了一个层次结构。<em>src/lib.rs</em> 的内容位于最顶层，而其子模块位于较低的层次。如下是示例 7-1 中的例子以层次的方式考虑的结构：</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>而这是示例 7-2 中例子的层次结构：</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>可以看到示例 7-2 中，<code>client</code> 是 <code>network</code> 的子模块，而不是它的同级模块。更为复杂的项目可以有很多的模块，所以它们需要符合逻辑地组合在一起以便记录它们。在项目中 “符合逻辑” 的意义全凭你的理解和库的用户对你项目领域的认识。利用我们这里讲到的技术来创建同级模块和嵌套的模块，总有一个会是你会喜欢的结构。</p>
<a class="header" href="print.html#a将模块移动到其他文件" id="a将模块移动到其他文件"><h3>将模块移动到其他文件</h3></a>
<p>位于层级结构中的模块，非常类似计算机领域的另一个我们非常熟悉的结构：文件系统！我们可以利用 Rust 的模块系统连同多个文件一起分解 Rust 项目，这样就不会是所有的内容都落到 <em>src/lib.rs</em> 或 <em>src/main.rs</em> 中了。为了举例，我们将从示例 7-3 中的代码开始：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 7-3：三个模块，<code>client</code>、<code>network</code> 和 <code>network::server</code>，它们都定义于 <em>src/lib.rs</em></span></p>
<p><em>src/lib.rs</em> 文件有如下层次结构：</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>如果这些模块有很多函数，而这些函数又很长，将难以在文件中寻找我们需要的代码。因为这些函数被嵌套进一个或多个 <code>mod</code> 块中，同时函数中的代码也会开始变长。这就有充分的理由将 <code>client</code>、<code>network</code> 和 <code>server</code> 每一个模块从 <em>src/lib.rs</em> 抽出并放入它们自己的文件中。</p>
<p>首先，将 <code>client</code> 模块的代码替换为只有 <code>client</code> 模块声明，这样 <em>src/lib.rs</em> 看起来应该像如示例 7-4 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption">示例 7-4：提取出 <code>client</code> 模块的内容但仍将其声明留在 <em>src/lib.rs</em></span></p>
<p>这里我们仍然 <strong>声明</strong> 了 <code>client</code> 模块，不过将代码块替换为了分号，这告诉了 Rust 在 <code>client</code> 模块的作用域中寻找另一个定义代码的位置。换句话说，<code>mod client;</code> 行意味着：</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}
</code></pre>
<p>那么现在需要创建对应模块名的外部文件。在 <em>src/</em> 目录创建一个 <em>client.rs</em> 文件，接着打开它并输入如下内容，它是上一步被去掉的 <code>client</code> 模块中的 <code>connect</code> 函数：</p>
<p><span class="filename">文件名: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>注意这个文件中并不需要一个 <code>mod</code> 声明；因为已经在 <em>src/lib.rs</em> 中已经使用 <code>mod</code> 声明了 <code>client</code> 模块。这个文件仅仅提供 <code>client</code> 模块的 <strong>内容</strong>。如果在这里加上一个 <code>mod client</code>，那么就等于给 <code>client</code> 模块增加了一个叫做 <code>client</code> 的子模块了！</p>
<p>Rust 默认只知道 <em>src/lib.rs</em> 中的内容。如果想要对项目加入更多文件，我们需要在 <em>src/lib.rs</em> 中告诉 Rust 去寻找其他文件；这就是为什么 <code>mod client</code> 需要被定义在 <em>src/lib.rs</em> 而不能在 <em>src/client.rs</em> 的原因。</p>
<p>现在，一切应该能成功编译，虽然会有一些警告。记住使用 <code>cargo build</code> 而不是 <code>cargo run</code>， 因为这是一个库 crate 而不是二进制 crate：</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>这些警告提醒我们有从未被使用的函数。目前不用担心这些警告，在本章后面的 “使用 <code>pub</code> 控制可见性” 部分会解决它们。好消息是，它们仅仅是警告，我们的项目能够成功编译。</p>
<p>下面使用相同的模式将 <code>network</code> 模块提取到自己的文件中。删除 <em>src/lib.rs</em> 中 <code>network</code> 模块的内容并在声明后加上一个分号，像这样：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>接着新建 <em>src/network.rs</em> 文件并输入如下内容：</p>
<p><span class="filename">文件名: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>注意这个模块文件中我们也使用了一个 <code>mod</code> 声明；这是因为我们希望 <code>server</code> 成为 <code>network</code> 的一个子模块。</p>
<p>现在再次运行 <code>cargo build</code>。成功！不过我们还需要再提取出另一个模块：<code>server</code>。因为这是一个子模块——也就是模块中的模块——目前的将模块提取到对应名字的文件中的策略就不管用了。如果我们仍这么尝试则会出现错误。对 <em>src/network.rs</em> 的第一个修改是用 <code>mod server;</code> 替换 <code>server</code> 模块的内容：</p>
<p><span class="filename">文件名: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>接着创建 <em>src/server.rs</em> 文件并输入需要提取的 <code>server</code> 模块的内容：</p>
<p><span class="filename">文件名: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>当尝试运行 <code>cargo build</code> 时，会出现如示例 7-5 中所示的错误：</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">示例 7-5：尝试将 <code>server</code> 子模块提取到 <em>src/server.rs</em> 时出现的错误</span></p>
<p>这个错误说明 “不能在这个位置新声明一个模块” 并指出 <em>src/network.rs</em> 中的 <code>mod server;</code> 这一行。看来 <em>src/network.rs</em> 与 <em>src/lib.rs</em> 在某些方面是不同的；继续阅读以理解这是为什么。</p>
<p>示例 7-5 中间的 note 事实上是非常有帮助的，因为它指出了一些我们还未讲到的操作：</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>我们可以按照记录所建议的去操作，而不是继续使用之前的与模块同名文件的模式：</p>
<ol>
<li>新建一个叫做 <em>network</em> 的 <strong>目录</strong>，这是父模块的名字</li>
<li>将 <em>src/network.rs</em> 移动到新建的 <em>network</em> 目录中并重命名为 <em>src/network/mod.rs</em></li>
<li>将子模块文件 <em>src/server.rs</em> 移动到 <em>network</em> 目录中</li>
</ol>
<p>如下是执行这些步骤的命令：</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>现在如果运行 <code>cargo build</code> 的话将顺利编译（虽然仍有警告）。现在模块的布局看起来仍然与示例 7-3 中所有代码都在 <em>src/lib.rs</em> 中时完全一样：</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>对应的文件布局现在看起来像这样：</p>
<pre><code class="language-text">└── src
    ├── client.rs
    ├── lib.rs
    └── network
        ├── mod.rs
        └── server.rs
</code></pre>
<p>那么，当我们想要提取 <code>network::server</code> 模块时，为什么也必须将 <em>src/network.rs</em> 文件改名成 <em>src/network/mod.rs</em> 文件呢，还有为什么要将 <code>network::server</code> 的代码放入 <em>network</em> 目录的 <em>src/network/server.rs</em> 文件中呢？原因是如果 <em>server.rs</em> 文件在 <em>src</em> 目录中那么 Rust 就不能知道 <code>server</code> 应当是 <code>network</code> 的子模块。为了阐明这里 Rust 的行为，让我们考虑一下有着如下层级的另一个例子，其所有定义都位于 <em>src/lib.rs</em> 中：</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>在这个例子中，仍然有这三个模块，<code>client</code>、<code>network</code> 和 <code>network::client</code>。如果按照与上面最开始将模块提取到文件中相同的步骤来操作，对于 <code>client</code> 模块会创建 <em>src/client.rs</em>。对于 <code>network</code> 模块，会创建 <em>src/network.rs</em>。但是接下来不能将 <code>network::client</code> 模块提取到 <em>src/client.rs</em> 文件中，因为它已经存在了，对应顶层的 <code>client</code> 模块！如果将 <code>client</code> 和 <code>network::client</code> 的代码都放入 <em>src/client.rs</em> 文件，Rust 将无从可知这些代码是属于 <code>client</code> 还是 <code>network::client</code> 的。</p>
<p>因此，为了将 <code>network</code> 模块的子模块 <code>network::client</code> 提取到一个文件中，需要为 <code>network</code> 模块新建一个目录替代 <em>src/network.rs</em> 文件。接着 <code>network</code> 模块的代码将进入 <em>src/network/mod.rs</em> 文件，而子模块 <code>network::client</code> 将拥有其自己的文件 <em>src/network/client.rs</em>。现在顶层的 <em>src/client.rs</em> 中的代码毫无疑问的都属于 <code>client</code> 模块。</p>
<a class="header" href="print.html#a模块文件系统的规则" id="a模块文件系统的规则"><h3>模块文件系统的规则</h3></a>
<p>让我们总结一下与文件有关的模块规则：</p>
<ul>
<li>如果一个叫做 <code>foo</code> 的模块没有子模块，应该将 <code>foo</code> 的声明放入叫做 <em>foo.rs</em> 的文件中。</li>
<li>如果一个叫做 <code>foo</code> 的模块有子模块，应该将 <code>foo</code> 的声明放入叫做 <em>foo/mod.rs</em> 的文件中。</li>
</ul>
<p>这些规则适用于递归（嵌套），所以如果 <code>foo</code> 模块有一个子模块 <code>bar</code> 而 <code>bar</code> 没有子模块，则 <em>src</em> 目录中应该有如下文件：</p>
<pre><code class="language-text">└── foo
    ├── bar.rs (contains the declarations in `foo::bar`)
    └── mod.rs (contains the declarations in `foo`, including `mod bar`)
</code></pre>
<p>模块自身则应该使用 <code>mod</code> 关键字定义于父模块的文件中。</p>
<p>接下来，我们讨论一下 <code>pub</code> 关键字，并除掉那些警告！</p>
<a class="header" href="print.html#a使用-pub-控制可见性" id="a使用-pub-控制可见性"><h2>使用 <code>pub</code> 控制可见性</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch07-02-controlling-visibility-with-pub.md">ch07-02-controlling-visibility-with-pub.md</a>
<br>
commit a120c730714e07f8f32d905e9374a50b2e0ffdf5</p>
</blockquote>
<p>我们通过将 <code>network</code> 和 <code>network::server</code> 的代码分别移动到 <em>src/network/mod.rs</em> 和 <em>src/network/server.rs</em> 文件中解决了示例 7-5 中出现的错误信息。现在，<code>cargo build</code> 能够构建我们的项目，不过仍然有一些警告信息，表示 <code>client::connect</code>、<code>network::connect</code> 和<code>network::server::connect</code> 函数没有被使用：</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>那么为什么会出现这些错误信息呢？毕竟我们构建的是一个库，它的函数的目的是被 <strong>用户</strong> 使用，而不一定要被项目自身使用，所以不应该担心这些 <code>connect</code> 函数是未使用的。创建它们的意义就在于被另一个项目而不是被我们自己使用。</p>
<p>为了理解为什么这个程序出现了这些警告，尝试在另一个项目中使用这个 <code>connect</code> 库，从外部调用它们。为此，通过创建一个包含这些代码的 <em>src/main.rs</em> 文件，在与库 crate 相同的目录创建一个二进制 crate：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>使用 <code>extern crate</code> 指令将 <code>communicator</code> 库 crate 引入到作用域。我们的包现在包含 <strong>两个</strong> crate。Cargo 认为 <em>src/main.rs</em> 是一个二进制 crate 的根文件，与现存的以 <em>src/lib.rs</em> 为根文件的库 crate 相区分。这个模式在可执行项目中非常常见：大部分功能位于库 crate 中，而二进制 crate 使用该库 crate。通过这种方式，其他程序也可以使用这个库 crate，这是一个很好的关注分离（separation of concerns）。</p>
<p>从一个外部 crate 的视角观察 <code>communicator</code> 库的内部，我们创建的所有模块都位于一个与 crate 同名的模块内部，<code>communicator</code>。这个顶层的模块被称为 crate 的 <strong>根模块</strong>（<em>root module</em>）。</p>
<p>另外注意到即便在项目的子模块中使用外部 crate，<code>extern crate</code> 也应该位于根模块（也就是 <em>src/main.rs</em> 或 <em>src/lib.rs</em>）。接着，在子模块中，我们就可以像顶层模块那样引用外部 crate 中的项了。</p>
<p>我们的二进制 crate 如今正好调用了库中 <code>client</code> 模块的 <code>connect</code> 函数。然而，执行 <code>cargo build</code> 会在之前的警告之后出现一个错误：</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>啊哈！这告诉了我们 <code>client</code> 模块是私有的，这也正是那些警告的症结所在。这也是我们第一次在 Rust 上下文中涉及到 <strong>公有</strong>（<em>public</em>）和 <strong>私有</strong>（<em>private</em>）的概念。Rust 所有代码的默认状态是私有的：除了自己之外别人不允许使用这些代码。如果不在自己的项目中使用一个私有函数，因为程序自身是唯一允许使用这个函数的代码，Rust 会警告说函数未被使用。</p>
<p>一旦我们指定一个像 <code>client::connect</code> 的函数为公有，不光二进制 crate 中的函数调用是允许的，函数未被使用的警告也会消失。将其标记为公有让 Rust 知道了函数将会在程序的外部被使用。现在这个可能的理论上的外部可用性使得 Rust 认为这个函数 “已经被使用”。因此。当某项被标记为公有，Rust 不再要求它在程序自身被使用并停止警告函数未被使用。</p>
<a class="header" href="print.html#a标记函数为公有" id="a标记函数为公有"><h3>标记函数为公有</h3></a>
<p>为了告诉 Rust 将函数标记为公有，在声明的开头增加 <code>pub</code> 关键字。现在我们将致力于修复 <code>client::connect</code> 未被使用的警告，以及二进制 crate 中 “模块 <code>client</code> 是私有的” 的错误。像这样修改 <em>src/lib.rs</em> 使 <code>client</code> 模块公有：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p><code>pub</code> 写在 <code>mod</code> 之前。再次尝试构建：</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>非常好！另一个不同的错误！好的，不同的错误信息也是值得庆祝的（可能是程序员被黑的最惨的一次）。新错误表明“函数 <code>connect</code> 是私有的”，那么让我们修改 <em>src/client.rs</em> 将 <code>client::connect</code> 也设为公有：</p>
<p><span class="filename">文件名: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>再一次运行 <code>cargo build</code>：</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>编译通过了，关于 <code>client::connect</code> 未被使用的警告消失了！</p>
<p>未被使用的代码并不总是意味着它们需要被设为公有的：如果你 <strong>不</strong> 希望这些函数成为公有 API 的一部分，未被使用的代码警告可能是在提醒你这些代码不再需要并可以安全的删除它们。这也可能是警告你出 bug 了，如果你刚刚不小心删除了库中所有这个函数的调用。</p>
<p>当然我们的情况是，<strong>确实</strong> 希望另外两个函数也作为 crate 公有 API 的一部分，所以让我们也将其标记为 <code>pub</code> 并去掉剩余的警告。修改 <em>src/network/mod.rs</em> 为：</p>
<p><span class="filename">文件名: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>并编译代码：</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>虽然将 <code>network::connect</code> 设为 <code>pub</code> 了我们仍然得到了一个未被使用函数的警告。这是因为模块中的函数是公有的，不过函数所在的 <code>network</code> 模块却不是公有的。这回我们是自内向外修改库文件的，而 <code>client::connect</code> 的时候是自外向内修改的。我们需要修改 <em>src/lib.rs</em> 让 <code>network</code> 也是公有的，如下：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>现在编译的话，那个警告就消失了：</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>只剩一个警告了！尝试自食其力修改它吧！</p>
<a class="header" href="print.html#a私有性规则" id="a私有性规则"><h3>私有性规则</h3></a>
<p>总的来说，有如下项的可见性规则：</p>
<ol>
<li>如果一个项是公有的，它能被任何父模块访问</li>
<li>如果一个项是私有的，它能被其直接父模块及其任何子模块访问</li>
</ol>
<a class="header" href="print.html#a私有性示例" id="a私有性示例"><h3>私有性示例</h3></a>
<p>让我们看看更多私有性的例子作为练习。创建一个新的库项目并在新项目的 <em>src/lib.rs</em> 输入示例 7-6 中的代码：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">示例 7-6：私有和公有函数的例子，其中部分是不正确的</span></p>
<p>在尝试编译这些代码之前，猜测一下 <code>try_me</code> 函数的哪一行会出错。接着编译项目来看看是否猜对了，然后继续阅读后面关于错误的讨论！</p>
<a class="header" href="print.html#a检查错误" id="a检查错误"><h4>检查错误</h4></a>
<p><code>try_me</code> 函数位于项目的根模块。叫做 <code>outermost</code> 的模块是私有的，不过第二条私有性规则说明 <code>try_me</code> 函数允许访问 <code>outermost</code> 模块，因为 <code>outermost</code> 位于当前（根）模块，<code>try_me</code> 也是。</p>
<p><code>outermost::middle_function</code> 的调用是正确的。因为 <code>middle_function</code> 是公有的，而 <code>try_me</code> 通过其父模块 <code>outermost</code> 访问 <code>middle_function</code>。根据上一段的规则我们可以确定这个模块是可访问的。</p>
<p><code>outermost::middle_secret_function</code> 的调用会造成一个编译错误。<code>middle_secret_function</code> 是私有的，所以第二条（私有性）规则生效了。根模块既不是 <code>middle_secret_function</code> 的当前模块（<code>outermost</code> 是），也不是 <code>middle_secret_function</code> 当前模块的子模块。</p>
<p>叫做 <code>inside</code> 的模块是私有的且没有子模块，所以它只能被当前模块 <code>outermost</code> 访问。这意味着 <code>try_me</code> 函数不允许调用 <code>outermost::inside::inner_function</code> 或 <code>outermost::inside::secret_function</code> 中的任何一个。</p>
<a class="header" href="print.html#a修改错误" id="a修改错误"><h4>修改错误</h4></a>
<p>这里有一些尝试修复错误的代码修改意见。在你尝试它们之前，猜测一下它们哪个能修复错误，接着编译查看你是否猜对了，并结合私有性规则理解为什么。</p>
<ul>
<li>如果 <code>inside</code> 模块是公有的？</li>
<li>如果 <code>outermost</code> 是公有的而 <code>inside</code> 是私有的？</li>
<li>如果在 <code>inner_function</code> 函数体中调用 <code>::outermost::middle_secret_function()</code>？（开头的两个冒号意味着从根模块开始引用模块。）</li>
</ul>
<p>请随意设计更多的实验并尝试理解它们！</p>
<p>接下来，让我们讨论一下使用 <code>use</code> 关键字将项引入作用域。</p>
<a class="header" href="print.html#a引用不同模块中的名称" id="a引用不同模块中的名称"><h2>引用不同模块中的名称</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch07-03-importing-names-with-use.md">ch07-03-importing-names-with-use.md</a>
<br>
commit 550c8ea6f74060ff1f7b67e7e1878c4da121682d</p>
</blockquote>
<p>我们已经讲到了如何使用模块名称作为调用的一部分，来调用模块中的函数，如示例 7-7 中所示的 <code>nested_modules</code> 函数调用。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">示例 7-7：通过完全指定模块中的路径来调用函数</span></p>
<p>如你所见，指定函数的完全限定名称可能会非常冗长。所幸 Rust 有一个关键字使得这些调用显得更简洁。</p>
<a class="header" href="print.html#a使用-use-关键字将名称导入作用域" id="a使用-use-关键字将名称导入作用域"><h3>使用 <code>use</code> 关键字将名称导入作用域</h3></a>
<p>Rust 的 <code>use</code> 关键字能将你想要调用的函数所在的模块引入到当前作用域中，通过这种方式可以缩短冗长的函数调用。这是一个将 <code>a::series::of</code> 模块导入一个二进制 crate 的根作用域的例子：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p><code>use a::series::of;</code> 这一行的意思是每当想要引用 <code>of</code> 模块时，不必使用完整的 <code>a::series::of</code> 路径，可以直接使用 <code>of</code>。</p>
<p><code>use</code> 关键字只将指定的模块引入作用域；它并不会将其子模块也引入。这就是为什么想要调用 <code>nested_modules</code> 函数时仍然必须写成 <code>of::nested_modules</code>。</p>
<p>也可以将函数本身引入到作用域中，通过如下在 <code>use</code> 中指定函数的方式：</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>这使得我们可以忽略所有的模块并直接引用函数。</p>
<p>因为枚举也像模块一样组成了某种命名空间，也可以使用 <code>use</code> 来导入枚举的成员。对于任何类型的 <code>use</code> 语句，如果从一个命名空间导入多个项，可以在最后使用大括号和逗号来列举它们，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>我们仍然为 <code>Green</code> 成员指定了 <code>TrafficLight</code> 命名空间，因为并没有在 <code>use</code> 语句中包含 <code>Green</code>。</p>
<a class="header" href="print.html#a使用-glob-将所有名称引入作用域" id="a使用-glob-将所有名称引入作用域"><h3>使用 glob 将所有名称引入作用域</h3></a>
<p>为了一次将某个命名空间下的所有名称都引入作用域，可以使用 <code>*</code> 语法，这称为 <strong>glob 运算符</strong>（<em>glob operator</em>）。这个例子将一个枚举的所有成员引入作用域而没有将其一一列举出来：</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p><code>*</code> 会将 <code>TrafficLight</code> 命名空间中所有可见的项都引入作用域。请保守的使用 glob：它们是方便的，但是也可能会引入多于预期的内容从而导致命名冲突。</p>
<a class="header" href="print.html#a使用-super-访问父模块" id="a使用-super-访问父模块"><h3>使用 <code>super</code> 访问父模块</h3></a>
<p>正如我们已经知道的，当创建一个库 crate 时，Cargo 会生成一个 <code>tests</code> 模块。现在让我们来深入了解一下。在 <code>communicator</code> 项目中，打开 <em>src/lib.rs</em>。</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>第十一章会更详细的解释测试，不过其中部分内容现在应该可以理解了：有一个叫做 <code>tests</code> 的模块紧邻其他模块，同时包含一个叫做 <code>it_works</code> 的函数。即便存在一些特殊注解，<code>tests</code> 也不过是另外一个模块！所以我们的模块层次结构看起来像这样：</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<p>测试是为了检验库中的代码而存在的，所以让我们尝试在 <code>it_works</code> 函数中调用 <code>client::connect</code> 函数，即便现在不准备测试任何功能。这还不能工作：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>使用 <code>cargo test</code> 命令运行测试：</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>编译失败了，不过为什么呢？并不需要像 <em>src/main.rs</em> 那样将 <code>communicator::</code> 置于函数前，因为这里肯定是在 <code>communicator</code> 库 crate 之内的。失败的原因是路径是相对于当前模块的，在这里就是 <code>tests</code>。唯一的例外就是 <code>use</code> 语句，它默认是相对于 crate 根模块的。我们的 <code>tests</code> 模块需要 <code>client</code> 模块位于其作用域中！</p>
<p>那么如何在模块层次结构中回退一级模块，以便在 <code>tests</code> 模块中能够调用 <code>client::connect</code>函数呢？在 <code>tests</code> 模块中，要么可以在开头使用双冒号来让 Rust 知道我们想要从根模块开始并列出整个路径：</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>要么可以使用 <code>super</code> 在层级中上移到当前模块的上一级模块，如下：</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>在这个例子中这两个选择看不出有多么大的区别，不过随着模块层次的更加深入，每次都从根模块开始就会显得很长了。在这些情况下，使用 <code>super</code> 来获取当前模块的同级模块是一个好的捷径。再加上，如果在代码中的很多地方指定了从根开始的路径，那么当通过移动子树或到其他位置来重新排列模块时，最终就需要更新很多地方的路径，这就非常乏味无趣了。</p>
<p>在每一个测试中总是不得不编写 <code>super::</code> 也会显得很恼人，不过你已经见过解决这个问题的利器了：<code>use</code>！<code>super::</code> 的功能改变了提供给 <code>use</code> 的路径，使其不再相对于根模块而是相对于父模块。</p>
<p>为此，特别是在 <code>tests</code> 模块，<code>use super::something</code> 是常用的手段。所以现在的测试看起来像这样：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>如果再次运行<code>cargo test</code>，测试将会通过而且测试结果输出的第一部分将会是：</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#a总结-6" id="a总结-6"><h2>总结</h2></a>
<p>现在你掌握了组织代码的核心科技！利用它们将相关的代码组合在一起、防止代码文件过长并将一个整洁的公有 API 展现给库的用户。</p>
<p>接下来，让我们看看一些标准库提供的集合数据类型，你可以利用它们编写出漂亮整洁的代码。</p>
<a class="header" href="print.html#a通用集合类型" id="a通用集合类型"><h1>通用集合类型</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch08-00-common-collections.md">ch08-00-common-collections.md</a>
<br>
commit 54e81980185fbb1a4cb5a18dce1dc6deeb66b573</p>
</blockquote>
<p>Rust 标准库中包含一系列被称为 <strong>集合</strong>（<em>collections</em>）的非常有用的数据结构。大部分其他数据类型都代表一个特定的值，不过集合可以包含多个值。不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知并且可以随着程序的运行增长或缩小。每种集合都有着不同能力和代价，而为所处的场景选择合适的集合则是你将要始终成长的技能。在这一章里，我们将详细的了解三个在 Rust 程序中被广泛使用的集合：</p>
<ul>
<li><em>vector</em> 允许我们一个挨着一个地储存一系列数量可变的值</li>
<li><strong>字符串</strong>（<em>string</em>）是一个字符的集合。我们之前见过 <code>String</code> 类型，不过在本章我们将深入了解。</li>
<li><strong>哈希 map</strong>（<em>hash map</em>）允许我们将值与一个特定的键（key）相关联。这是一个叫做 <em>map</em> 的更通用的数据结构的特定实现。</li>
</ul>
<p>对于标准库提供的其他类型的集合，请查看<a href="https://doc.rust-lang.org/std/collections">文档</a>。</p>
<p>我们将讨论如何创建和更新 vector、字符串和哈希 map，以及它们有什么不同。</p>
<a class="header" href="print.html#vector-用来储存一系列的值" id="vector-用来储存一系列的值"><h2>vector 用来储存一系列的值</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch08-01-vectors.md">ch08-01-vectors.md</a>
<br>
commit 550c8ea6f74060ff1f7b67e7e1878c4da121682d</p>
</blockquote>
<p>我们要讲到的第一个类型是 <code>Vec&lt;T&gt;</code>，也被称为 <em>vector</em>。vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。它们在拥有一系列项的场景下非常实用，例如文件中的文本行或是购物车中商品的价格。</p>
<a class="header" href="print.html#a新建-vector" id="a新建-vector"><h3>新建 vector</h3></a>
<p>为了创建一个新的空 vector，可以调用 <code>Vec::new</code> 函数，如示例 8-1 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p><span class="caption">示例 8-1：新建一个空的 vector 来储存 <code>i32</code> 类型的值</span></p>
<p>注意这里我们增加了一个类型注解。因为没有向这个 vector 中插入任何值，Rust 并不知道我们想要储存什么类型的元素。这是一个非常重要的点。vector 是用泛型实现的，第十章会涉及到如何对你自己的类型使用它们。现在，所有你需要知道的就是 <code>Vec</code> 是一个由标准库提供的类型，它可以存放任何类型，而当 <code>Vec</code> 存放某个特定类型时，那个类型位于尖括号中。这里我们告诉 Rust <code>v</code> 这个 <code>Vec</code> 将存放 <code>i32</code> 类型的元素。</p>
<p>在更实际的代码中，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解。更常见的做法是使用初始值来创建一个 <code>Vec</code>，而且为了方便 Rust 提供了 <code>vec!</code> 宏。这个宏会根据我们提供的值来创建一个新的 <code>Vec</code>。示例 8-2 新建一个拥有值 <code>1</code>、<code>2</code> 和 <code>3</code> 的 <code>Vec&lt;i32&gt;</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p><span class="caption">示例 8-2：新建一个包含初值的 vector</span></p>
<p>因为我们提供了 <code>i32</code> 类型的初始值，Rust 可以推断出 <code>v</code> 的类型是 <code>Vec&lt;i32&gt;</code>，因此类型注解就不是必须的。接下来让我们看看如何修改一个 vector。</p>
<a class="header" href="print.html#a更新-vector" id="a更新-vector"><h3>更新 vector</h3></a>
<p>对于新建一个 vector 并向其增加元素，可以使用 <code>push</code> 方法，如示例 8-3 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p><span class="caption">示例 8-3：使用 <code>push</code> 方法向 vector 增加值</span></p>
<p>如第三章中讨论的任何变量一样，如果想要能够改变它的值，必须使用 <code>mut</code> 关键字使其可变。放入其中的所有值都是 <code>i32</code> 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<a class="header" href="print.html#a丢弃-vector-时也会丢弃其所有元素" id="a丢弃-vector-时也会丢弃其所有元素"><h3>丢弃 vector 时也会丢弃其所有元素</h3></a>
<p>类似于任何其他的 <code>struct</code>，vector 在其离开作用域时会被释放，如示例 8-4 所标注的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // &lt;- v goes out of scope and is freed here
#}</code></pre></pre>
<p><span class="caption">示例 8-4：展示 vector 和其元素于何处被丢弃</span></p>
<p>当 vector 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。这可能看起来非常直观，不过一旦开始使用 vector 元素的引用，情况就变得有些复杂了。下面让我们处理这种情况！</p>
<a class="header" href="print.html#a读取-vector-的元素" id="a读取-vector-的元素"><h3>读取 vector 的元素</h3></a>
<p>现在你知道如何创建、更新和销毁 vector 了，接下来的一步最好了解一下如何读取它们的内容。有两种方法引用 vector 中储存的值。为了更加清楚的说明这个例子，我们标注这些函数返回的值的类型。</p>
<p>示例 8-5 展示了访问 vector 中一个值的两种方式，索引语法或者 <code>get</code> 方法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p><span class="caption">列表 8-5：使用索引语法或 <code>get</code> 方法来访问 vector 中的项</span></p>
<p>这里有两个需要注意的地方。首先，我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 0 开始的。其次，这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</p>
<p>Rust 有两个引用元素的方法的原因是程序可以选择如何处理当索引值在 vector 中没有对应值的情况。作为一个例子，让我们看看如果有一个有五个元素的 vector 接着尝试访问索引为 100 的元素时程序会如何处理，如示例 8-6 所示：</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p><span class="caption">示例 8-6：尝试访问一个包含 5 个元素的 vector 的索引 100 处的元素</span></p>
<p>当运行这段代码，你会发现对于第一个 <code>[]</code> 方法，当引用一个不存在的元素时 Rust 会造成 <code>panic!</code>。这个方法更适合当程序认为尝试访问超过 vector 结尾的元素是一个严重错误的情况，这时应该使程序崩溃。</p>
<p>当 <code>get</code> 方法被传递了一个数组外的索引时，它不会 panic 而是返回 <code>None</code>。当偶尔出现超过 vector 范围的访问属于正常情况的时候可以考虑使用它。接着你的代码可以有处理 <code>Some(&amp;element)</code> 或 <code>None</code> 的逻辑，如第六章讨论的那样。例如，索引可能来源于用户输入的数字。如果它们不慎输入了一个过大的数字那么程序就会得到 <code>None</code> 值，你可以告诉用户当前 vector 元素的数量并再请求它们输入一个有效的值。这就比因为输入错误而使程序崩溃要友好的多！</p>
<a class="header" href="print.html#a无效引用" id="a无效引用"><h4>无效引用</h4></a>
<p>一旦程序获取了一个有效的引用，借用检查器将会执行第四章讲到的所有权和借用规则来确保 vector 内容的这个引用和任何其他引用保持有效。回忆一下不能在相同作用域中同时存在可变和不可变引用的规则。这个规则适用于示例 8-7，当我们获取了 vector 的第一个元素的不可变引用并尝试在 vector 末尾增加一个元素的时候，这是行不通的：</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p><span class="caption">示例 8-7：在拥有 vector 中项的引用的同时向其增加一个元素</span></p>
<p>编译会给出这个错误：</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt;
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^ mutable borrow occurs here
7 |
8 | }
  | - immutable borrow ends here
</code></pre>
<p>示例 8-7 中的代码看起来应该能够运行：为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式。在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p>
<blockquote>
<p>注意：关于 <code>Vec&lt;T&gt;</code> 类型的更多实现细节，在 <em>https://doc.rust-lang.org/stable/nomicon/vec.html</em> 查看 “The Nomicon”</p>
</blockquote>
<a class="header" href="print.html#a遍历-vector-中的元素" id="a遍历-vector-中的元素"><h3>遍历 vector 中的元素</h3></a>
<p>如果想要依次访问 vector 中的每一个元素，我们可以遍历其所有的元素而无需通过索引一次一个的访问。示例 8-8 展示了如何使用 <code>for</code> 循环来获取 <code>i32</code> 值的 vector 中的每一个元素的不可变引用并将其打印：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p><span class="caption">示例 8-8：通过 <code>for</code> 循环遍历 vector 的元素并打印</span></p>
<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们。示例 8-9 中的 <code>for</code> 循环会给每一个元素加 <code>50</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
#}</code></pre></pre>
<p><span class="caption">示例8-9：遍历 vector 中元素的可变引用</span></p>
<p>为了修改可变引用所指向的值，在使用 <code>+=</code> 运算符之前必须使用解引用运算符（<code>*</code>）获取 <code>i</code> 中的值。</p>
<a class="header" href="print.html#a使用枚举来储存多种类型" id="a使用枚举来储存多种类型"><h3>使用枚举来储存多种类型</h3></a>
<p>在本章的开始，我们提到 vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！</p>
<p>例如，假如我们想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。我们可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型，那个枚举的类型。接着可以创建一个储存枚举值的 vector，这样最终就能够储存不同类型的值了。示例 8-10 展示了其用例：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">示例 8-10：定义一个枚举，以便能在 vector 中存放不同类型的数据</span></p>
<p>Rust 在编译时就必须准确的知道 vector 中类型的原因在于它需要知道储存每个元素到底需要多少内存。第二个好处是可以准确的知道这个 vector 中允许什么类型。如果 Rust 允许 vector 存放任意类型，那么当对 vector 元素执行操作时一个或多个类型的值就有可能会造成错误。使用枚举外加 <code>match</code> 意味着 Rust 能在编译时就保证总是会处理所有可能的情况，正如第六章讲到的那样。</p>
<p>如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象，第十七章会讲到它。</p>
<p>现在我们了解了一些使用 vector 的最常见的方式，请一定去看看标准库中 <code>Vec</code> 定义的很多其他实用方法的 API 文档。例如，除了 <code>push</code> 之外还有一个 <code>pop</code> 方法，它会移除并返回 vector 的最后一个元素。让我们继续下一个集合类型：<code>String</code>！</p>
<a class="header" href="print.html#a使用字符串存储-utf-8-编码的文本" id="a使用字符串存储-utf-8-编码的文本"><h2>使用字符串存储 UTF-8 编码的文本</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch08-02-strings.md">ch08-02-strings.md</a>
<br>
commit d0e83220e083ef87880e6a04f030b90c9af9385b</p>
</blockquote>
<p>第四章已经讲过一些字符串的内容，不过现在让我们更深入地了解它。字符串是新晋 Rustacean 们通常会被困住的领域，这是由于三方面内容的结合：Rust 倾向于确保暴露出可能的错误，字符串是比很多程序员所想象的要更为复杂的数据结构，以及 UTF-8。所有这些结合起来对于来自其他语言背景的程序员就可能显得很困难了。</p>
<p>在集合章节中讨论字符串的原因是，字符串就是作为字节的集合外加一些方法实现的，当这些字节被解释为文本时，这些方法提供了实用的功能。在这一部分，我们会讲到 <code>String</code> 中那些任何集合类型都有的操作，比如创建、更新和读取。也会讨论 <code>String</code> 与其他集合不一样的地方，例如索引<code>String</code> 是很复杂的，由于人和计算机理解 <code>String</code> 数据方式的不同。</p>
<a class="header" href="print.html#a什么是字符串" id="a什么是字符串"><h3>什么是字符串？</h3></a>
<p>在开始深入这些方面之前，我们需要讨论一下术语 <strong>字符串</strong> 的具体意义。Rust 的核心语言中只有一种字符串类型：<code>str</code>，字符串 slice，它通常以被借用的形式出现，<code>&amp;str</code>。第四章讲到了 <strong>字符串 slice</strong>：它们是一些储存在别处的 UTF-8 编码字符串数据的引用。比如字符串字面值被储存在程序的二进制输出中，字符串 slice 也是如此。</p>
<p>称作 <code>String</code> 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。当 Rustacean 们谈到 Rust 的 “字符串”时，它们通常指的是 <code>String</code> 和字符串 slice <code>&amp;str</code> 类型，而不仅仅是其中之一。虽然本部分内容大多是关于 <code>String</code> 的，不过这两个类型在 Rust 标准库中都被广泛使用，<code>String</code> 和字符串 slice 都是 UTF-8 编码的。</p>
<p>Rust 标准库中还包含一系列其他字符串类型，比如 <code>OsString</code>、<code>OsStr</code>、<code>CString</code> 和 <code>CStr</code>。相关库 crate 甚至会提供更多储存字符串数据的选择。看到这些由 <code>String</code> 或是 <code>Str</code> 结尾的名字了吗？这对应着它们提供的所有权和可借用的字符串变体，就像是你之前看到的 <code>String</code> 和 <code>str</code>。举例而言，这些字符串类型能够以不同的编码或内存表现形式上以不同的形式存储文本内容。本章将不会讨论其他这些字符串类型，查看 API 文档来更多的了解如何使用它们以及各自适合的场景。</p>
<a class="header" href="print.html#a新建字符串" id="a新建字符串"><h3>新建字符串</h3></a>
<p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从以 <code>new</code> 函数创建字符串开始，如示例 8-11 所示。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p><span class="caption">示例 8-11：新建一个空的 <code>String</code></span></p>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。</p>
<p>通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面值也实现了它。示例 8-12 展示了两个例子。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p><span class="caption">示例 8-12：使用 <code>to_string</code> 方法从字符串字面值创建 <code>String</code></span></p>
<p>这些代码会创建包含 <code>initial contents</code> 的字符串。</p>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面值创建 <code>String</code>。示例 8-13 中的代码代码等同于使用 <code>to_string</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p><span class="caption">示例 8-13：使用 <code>String::from</code> 函数从字符串字面值创建 <code>String</code></span></p>
<p>因为字符串应用广泛，这里有很多不同的用于字符串的通用 API 可供选择。它们有些可能显得有些多余，不过都有其用武之地！在这个例子中，<code>String::from</code> 和 <code>.to_string</code> 最终做了完全相同的工作，所以如何选择就是风格问题了。</p>
<p>记住字符串是 UTF-8 编码的，所以可以包含任何可以正确编码的数据，如示例 8-14 所示。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
#}</code></pre></pre>
<p><span class="caption">示例 8-14：在字符串中储存不同语言的问候语</span></p>
<p>所有这些都是有效的 <code>String</code>值。</p>
<a class="header" href="print.html#a更新字符串" id="a更新字符串"><h3>更新字符串</h3></a>
<p><code>String</code> 的大小可以增长其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，<code>String</code> 实现了 <code>+</code> 运算符作为连接运算符以便于使用。</p>
<a class="header" href="print.html#a使用-push-附加字符串" id="a使用-push-附加字符串"><h4>使用 push 附加字符串</h4></a>
<p>可以通过 <code>push_str</code> 方法来附加字符串 slice，从而使 <code>String</code> 变长，如示例 8-15 所示。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><span class="caption">示例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 附加字符串 slice</span></p>
<p>执行这两行代码之后 <code>s</code> 将会包含 <code>foobar</code>。<code>push_str</code> 方法获取字符串 slice，因为我们并不需要获取参数的所有权。例如，示例 8-16 展示了如果将 <code>s2</code> 的内容附加到 <code>s1</code> 中后自身不能被使用就糟糕了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
#}</code></pre></pre>
<p><span class="caption">示例 8-16：将字符串 slice 的内容附加到 <code>String</code> 后使用它</span></p>
<p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，就不能在最后一行打印出其值了。好在代码如我们期望那样工作！</p>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中。示例 8-17 展示了使用 <code>push</code> 方法将字母 l 加入 <code>String</code> 的代码。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p><span class="caption">示例 8-17：使用 <code>push</code> 将一个字符加入 <code>String</code> 值中</span></p>
<p>执行这些代码之后，<code>s</code> 将会包含 “lol”。</p>
<a class="header" href="print.html#a使用--运算符或-format-宏连接字符串" id="a使用--运算符或-format-宏连接字符串"><h4>使用 + 运算符或 <code>format!</code> 宏连接字符串</h4></a>
<p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符，如示例 8-18 所示。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
#}</code></pre></pre>
<p><span class="caption">示例 8-18：使用 <code>+</code> 运算符将两个 <code>String</code> 值合并到一个新的 <code>String</code> 值中</span></p>
<p>执行完这些代码之后字符串 <code>s3</code> 将会包含 <code>Hello, world!</code>。<code>s1</code> 在相加后不再有效的原因，和使用 <code>s2</code> 的引用的原因与使用 <code>+</code> 运算符时调用的方法签名有关，这个函数签名看起来像这样：</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>这并不是标准库中实际的签名；标准库中的 <code>add</code> 使用泛型定义。这里我们看到的 <code>add</code> 的签名使用具体类型代替了泛型，这也正是当使用 <code>String</code> 值调用这个方法会发生的。第十章会讨论泛型。这个签名提供了理解 <code>+</code> 运算那微妙部分的线索。</p>
<p>首先，<code>s2</code> 使用了 <code>&amp;</code>，意味着我们使用第二个字符串的 <strong>引用</strong> 与第一个字符串相加。这是因为 <code>add</code> 函数的 <code>s</code> 参数：只能将 <code>&amp;str</code> 和 <code>String</code> 相加，不能将两个 <code>String</code> 值相加。不过等一下——正如 <code>add</code> 的第二个参数所指定的，<code>&amp;s2</code> 的类型是 <code>&amp;String</code> 而不是 <code>&amp;str</code>。那么为什么示例 8-18 还能编译呢？</p>
<p>之所以能够在 <code>add</code> 调用中使用 <code>&amp;s2</code> 是因为 <code>&amp;String</code> 可以被 <strong>强转</strong>（<em>coerced</em>）成 <code>&amp;str</code>——当<code>add</code>函数被调用时，Rust 使用了一个被称为 <strong>解引用强制多态</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 <code>&amp;s2</code> 变成了 <code>&amp;s2[..]</code>。第十五章会更深入的讨论解引用强制多态。因为 <code>add</code> 没有获取参数的所有权，所以 <code>s2</code> 在这个操作后仍然是有效的 <code>String</code>。</p>
<p>其次，可以发现签名中 <code>add</code> 获取了 <code>self</code> 的所有权，因为 <code>self</code> <strong>没有</strong> 使用 <code>&amp;</code>。这意味着上面例子中的 <code>s1</code> 的所有权将被移动到 <code>add</code> 调用中，之后就不再有效。所以虽然 <code>let s3 = s1 + &amp;s2;</code> 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 <code>s1</code> 的所有权，附加上从 <code>s2</code> 中拷贝的内容，并返回结果的所有权。换句话说，它看起来好像生成了很多拷贝不过实际上并没有：这个实现比拷贝要更高效。</p>
<p>如果想要级联多个字符串，<code>+</code> 的行为就显得笨重了：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p>这时 <code>s</code> 的内容会是 “tic-tac-toe”。在有这么多 <code>+</code> 和 <code>&quot;</code> 字符的情况下，很难理解具体发生了什么。对于更为复杂的字符串链接，可以使用 <code>format!</code> 宏：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>这些代码也会将 <code>s</code> 设置为 “tic-tac-toe”。<code>format!</code> 与 <code>println!</code> 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 <code>String</code>。这个版本就好理解的多，并且不会获取任何参数的所有权。</p>
<a class="header" href="print.html#a索引字符串" id="a索引字符串"><h3>索引字符串</h3></a>
<p>在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而在 Rust 中，如果你尝试使用索引语法访问 <code>String</code> 的一部分，会出现一个错误。考虑一下如示例 8-19 中所示的无效代码。</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p><span class="caption">示例 8-19：尝试对字符串使用索引语法</span></p>
<p>会导致如下错误：</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>错误和提示说明了全部问题：Rust 的字符串不支持索引。那么接下来的问题是，为什么不支持呢？为了回答这个问题，我们必须先聊一聊 Rust 是如何在内存中储存字符串的。</p>
<a class="header" href="print.html#a内部表现" id="a内部表现"><h4>内部表现</h4></a>
<p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。让我们看看之前一些正确编码的字符串的例子。首先是这一个：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>在这里，<code>len</code> 的值是 4 ，这意味着储存字符串 “Hola” 的 <code>Vec</code> 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。那下面这个例子又如何呢？（注意这个字符串中的首字母是西里尔字母的 Ze 而不是阿拉伯数字 3 ）</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值。作为演示，考虑如下无效的 Rust 代码：</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code> 的值应该是什么呢？它应该是第一个字符 <code>З</code> 吗？当使用 UTF-8 编码时，<code>З</code> 的第一个字节 <code>208</code>，第二个是 <code>151</code>，所以 <code>answer</code> 实际上应该是 <code>208</code>，不过 <code>208</code> 自身并不是一个有效的字母。返回 <code>208</code> 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回，即便这个字符串只有拉丁字母： 即便 <code>&amp;&quot;hello&quot;[0]</code> 是返回字节值的有效代码，它也应当返回 <code>104</code> 而不是 <code>h</code>。为了避免返回意想不到值并造成不能立刻发现的 bug。Rust 选择不编译这些代码并及早杜绝了误会的发生。</p>
<a class="header" href="print.html#a字节标量值和字形簇天呐" id="a字节标量值和字形簇天呐"><h4>字节、标量值和字形簇！天呐！</h4></a>
<p>这引起了关于 UTF-8 的另外一个问题：从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p>
<p>比如这个用梵文书写的印度语单词 “नमस्ते”，最终它储存在 vector 中的 <code>u8</code> 值看起来像这样：</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>这里有 18 个字节，也就是计算机最终会储存的数据。如果从 Unicode 标量值的角度理解它们，也就像 Rust 的 <code>char</code> 类型那样，这些字节看起来像这样：</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>这里有六个 <code>char</code>，不过第四个和第六个都不是字母，它们是发音符号本身并没有任何意义。最后，如果以字形簇的角度理解，就会得到人们所说的构成这个单词的四个字母：</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。</p>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 不得不检查从字符串的开头到索引位置的内容来确定这里有多少有效的字符。</p>
<a class="header" href="print.html#a字符串-slice-1" id="a字符串-slice-1"><h3>字符串 slice</h3></a>
<p>索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。因此，如果你真的希望使用索引创建字符串 slice 时 Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：在运行时会 panic，就跟访问 vector 中的无效索引时一样：</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
</code></pre>
<p>你应该小心谨慎的使用这个操作，因为这么做可能会使你的程序崩溃。</p>
<a class="header" href="print.html#a遍历字符串的方法" id="a遍历字符串的方法"><h3>遍历字符串的方法</h3></a>
<p>幸运的是，这里还有其他获取字符串元素的方式。</p>
<p>如果你需要操作单独的 Unicode 标量值，最好的选择是使用 <code>chars</code> 方法。对 “नमस्ते” 调用 <code>chars</code> 方法会将其分开并返回六个 <code>char</code> 类型的值，接着就可以遍历其结果来访问每一个元素了：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>这些代码会打印出如下内容：</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<pre><code class="language-text">224
164
168
224
// --snip--
165
135
</code></pre>
<p>不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。</p>
<p>从字符串中获取字形簇是很复杂的，所以标准库并没有提供这个功能。<a href="https://crates.io">crates.io</a> 上有些提供这样功能的 crate。</p>
<a class="header" href="print.html#a字符串并不简单" id="a字符串并不简单"><h3>字符串并不简单</h3></a>
<p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向程序员展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着程序员们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。</p>
<p>现在让我们转向一些不太复杂的集合：哈希 map！</p>
<a class="header" href="print.html#a哈希-map-储存键值对" id="a哈希-map-储存键值对"><h2>哈希 map 储存键值对</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch08-03-hash-maps.md">ch08-03-hash-maps.md</a>
<br>
commit c2fd7b2d39c4130dd17bb99c101ac94af83d1a44</p>
</blockquote>
<p>最后介绍的常用集合类型是 <strong>哈希 map</strong>（<em>hash map</em>）。<code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射。它通过一个 <strong>哈希函数</strong>（<em>hashing function</em>）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表或者关联数组，仅举几例。</p>
<p>哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引。例如，在一个游戏中，你可以将每个团队的分数记录到哈希 map 中，其中键是队伍的名字而值是每个队伍的分数。给出一个队名，就能得到它们的得分。</p>
<p>本章我们会介绍哈希 map 的基本 API，不过还有更多吸引人的功能隐藏于标准库中 <code>HashMap</code> 定义的函数中。请一如既往地查看标准库文档来了解更多信息。</p>
<a class="header" href="print.html#a新建一个哈希-map" id="a新建一个哈希-map"><h3>新建一个哈希 map</h3></a>
<p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素。这里我们记录两支队伍的分数，分别是蓝队和黄队。蓝队开始有 10 分而黄队开始有 50 分：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p><span class="caption">示例 8-20：新建一个哈希 map 并插入一些键值对</span></p>
<p>注意必须首先 <code>use</code> 标准库中集合部分的 <code>HashMap</code>。在这三个常用集合中，<code>HashMap</code> 是最不常用的，所以并没有被 prelude 自动引用。标准库中对 <code>HashMap</code> 的支持也相对较少，例如，并没有内建的构建宏。</p>
<p>像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 <code>HashMap</code> 的键类型是 <code>String</code> 而值类型是 <code>i32</code>。同样类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。</p>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>。例如，如果队伍的名字和初始分数分别在两个 vector 中，可以使用 <code>zip</code> 方法来创建一个元组的 vector，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 <code>collect</code> 方法将这个元组 vector 转换成一个 <code>HashMap</code>，如示例 8-21 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p><span class="caption">示例 8-21：用队伍列表和分数列表创建哈希 map</span></p>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型注解是必要的，因为可能 <code>collect</code> 很多不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<a class="header" href="print.html#a哈希-map-和所有权" id="a哈希-map-和所有权"><h3>哈希 map 和所有权</h3></a>
<p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者，如示例 8-22 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#}</code></pre></pre>
<p><span class="caption">示例 8-22：展示一旦键值对被插入后就为哈希 map 所拥有</span></p>
<p>当 <code>insert</code> 调用将 <code>field_name</code> 和 <code>field_value</code> 移动到哈希 map 中后，将不能使用这两个绑定。</p>
<p>如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。第十章 “使用生命周期保证引用有效” 部分将会更多的讨论这个问题。</p>
<a class="header" href="print.html#a访问哈希-map-中的值" id="a访问哈希-map-中的值"><h3>访问哈希 map 中的值</h3></a>
<p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值，如示例 8-23 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p><span class="caption">示例 8-23：访问哈希 map 中储存的蓝队分数</span></p>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。这时就要用某种第六章提到的方法之一来处理 <code>Option</code>。</p>
<p>可以使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 <code>for</code> 循环：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>这会以任意顺序打印出每一个键值对：</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#a更新哈希-map" id="a更新哈希-map"><h3>更新哈希 map</h3></a>
<p>尽管键值对的数量是可以增长的，不过任何时候，每个键只能关联一个值。当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况。可以选择完全无视旧值并用新值代替旧值。可以选择保留旧值而忽略新值，并只在键 <strong>没有</strong> 对应值时增加新值。或者可以结合新旧两值。让我们看看这分别该如何处理！</p>
<a class="header" href="print.html#a覆盖一个值" id="a覆盖一个值"><h4>覆盖一个值</h4></a>
<p>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换。即便示例 8-24 中的代码调用了两次 <code>insert</code>，哈希 map 也只会包含一个键值对，因为两次都是对蓝队的键插入的值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><span class="caption">示例 8-24：替换以特定键储存的值</span></p>
<p>这会打印出 <code>{&quot;Blue&quot;: 25}</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<a class="header" href="print.html#a只在键没有对应值时插入" id="a只在键没有对应值时插入"><h4>只在键没有对应值时插入</h4></a>
<p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。比如说我们想要检查黄队的键是否关联了一个值。如果没有，就插入值 50，对于蓝队也是如此。使用 entry API 的代码看起来像示例 8-25 这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><span class="caption">示例 8-25：使用 <code>entry</code> 方法只在键没有对应一个值时插入</span></p>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的 <code>Entry</code>，如果不存在则将参数作为新值插入并返回修改过的 <code>Entry</code>。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<p>运行示例 8-25 的代码会打印出 <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>。第一个 <code>entry</code> 调用会插入黄队的键和值 <code>50</code>，因为黄队并没有一个值。第二个 <code>entry</code> 调用不会改变哈希 map 因为蓝队已经有了值 <code>10</code>。</p>
<a class="header" href="print.html#a根据旧值更新一个值" id="a根据旧值更新一个值"><h4>根据旧值更新一个值</h4></a>
<p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。例如，示例 8-26 中的代码计数一些文本中每一个单词分别出现了多少次。我们使用哈希 map 以单词作为键并递增其值来记录我们遇到过几次这个单词。如果是第一次看到某个单词，就插入值 <code>0</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p><span class="caption">示例 8-26：通过哈希 map 储存单词和计数来统计出现次数</span></p>
<p>这会打印出 <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>，<code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）。这里我们将这个可变引用储存在 <code>count</code> 变量中，所以为了赋值必须首先使用星号（<code>*</code>）解引用 <code>count</code>。这个可变引用在 <code>for</code> 循环的结尾离开作用域，这样所有这些改变都是安全的并符合借用规则。</p>
<a class="header" href="print.html#a哈希函数" id="a哈希函数"><h3>哈希函数</h3></a>
<p><code>HashMap</code> 默认使用一种密码学安全的哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 <code>BuildHasher</code> trait 的类型。第十章会讨论 trait 和如何实现它们。你并不需要从头开始实现你自己的 hasher；crates.io 有其他人分享的实现了许多常用哈希算法的 hasher 的库。</p>
<a class="header" href="print.html#a总结-7" id="a总结-7"><h2>总结</h2></a>
<p>vector、字符串和哈希 map 会在你的程序需要储存、访问和修改数据时帮助你。这里有一些你应该能够解决的练习问题：</p>
<ul>
<li>给定一系列数字，使用 vector 并返回这个列表的平均数（mean, average）、中位数（排列数组后位于中间的值）和众数（mode，出现次数最多的值；这里哈希函数会很有帮助）。</li>
<li>将字符串转换为 Pig Latin，也就是每一个单词的第一个辅音字母被移动到单词的结尾并增加 “ay”，所以 “first” 会变成 “irst-fay”。元音字母开头的单词则在结尾增加  “hay”（“apple” 会变成 “apple-hay”）。牢记 UTF-8 编码！</li>
<li>使用哈希 map 和 vector，创建一个文本接口来允许用户向公司的部门中增加员工的名字。例如，“Add Sally to Engineering” 或 “Add Amir to Sales”。接着让用户获取一个部门的所有员工的列表，或者公司每个部门的所有员工按照字母顺排序的列表。</li>
</ul>
<p>标准库 API 文档中描述的这些类型的方法将有助于你进行这些练习！</p>
<p>我们已经开始接触可能会有失败操作的复杂程序了，这也意味着接下来是一个了解错误处理的绝佳时机！</p>
<a class="header" href="print.html#a错误处理" id="a错误处理"><h1>错误处理</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch09-00-error-handling.md">ch09-00-error-handling.md</a>
<br>
commit 7f0c806e746a133ab344cb2035d31f2a63fb6d79</p>
</blockquote>
<p>Rust 对可靠性的执着也延伸到了错误处理。错误对于软件来说是不可避免的，所以 Rust 有很多特性来处理出现错误的情况。在很多情况下，Rust 要求你承认出错的可能性并在编译代码之前就采取行动。通过确保不会只有在将代码部署到生产环境之后才会发现错误来使得程序更可靠。</p>
<p>Rust 将错误组合成两个主要类别：<strong>可恢复错误</strong>（<em>recoverable</em>）和 <strong>不可恢复错误</strong>（<em>unrecoverable</em>）。可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件。不可恢复错误通常是 bug 的同义词，比如尝试访问超过数组结尾的位置。</p>
<p>大部分语言并不区分这两类错误，并采用类似异常这样方式统一处理他们。Rust 并没有异常。相反，对于可恢复错误有 <code>Result&lt;T, E&gt;</code> 值，以及 <code>panic!</code>，它在遇到不可恢复错误时停止程序执行。这一章会首先介绍 <code>panic!</code> 调用，接着会讲到如何返回 <code>Result&lt;T, E&gt;</code>。此外，我们将在决定是尝试从错误中恢复还是停止执行时探讨注意事项。</p>
<a class="header" href="print.html#panic-与不可恢复的错误" id="panic-与不可恢复的错误"><h2><code>panic!</code> 与不可恢复的错误</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch09-01-unrecoverable-errors-with-panic.md">ch09-01-unrecoverable-errors-with-panic.md</a>
<br>
commit 609909ec443042399858d1f679b0df1d6d0eba22</p>
</blockquote>
<p>突然有一天，糟糕的事情发生了，而你对此束手无策。对于这种情况，Rust 有 <code>panic!</code>宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。出现这种情况的场景通常是检测到一些类型的 bug 而且程序员并不清楚该如何处理它。</p>
<blockquote>
<a class="header" href="print.html#panic-中的栈展开与终止" id="panic-中的栈展开与终止"><h3>Panic 中的栈展开与终止</h3></a>
<p>当出现 <code>panic!</code> 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在  <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>让我们在一个简单的程序中调用 <code>panic!</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>运行程序将会出现类似这样的输出：</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>最后三行包含 <code>panic!</code> 造成的错误信息。第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置：<em>src/main.rs:2:4</em> 表明这是 <em>src/main.rs</em> 文件的第二行第四个字符。</p>
<p>在这个例子中，被指明的那一行是我们代码的一部分，而且查看这一行的话就会发现 <code>panic!</code> 宏的调用。在其他情况下，<code>panic!</code> 可能会出现在我们的代码调用的代码中。错误信息报告的文件名和行号可能指向别人代码中的 <code>panic!</code> 宏调用，而不是我们代码中最终导致 <code>panic!</code> 的那一行。可以使用 <code>panic!</code> 被调用的函数的 backtrace 来寻找（我们代码中出问题的地方）。下面我们会详细介绍 backtrace 是什么。</p>
<a class="header" href="print.html#a使用-panic-的-backtrace" id="a使用-panic-的-backtrace"><h3>使用 <code>panic!</code> 的 backtrace</h3></a>
<p>让我们来看看另一个因为我们代码中的 bug 引起的别的库中 <code>panic!</code> 的例子，而不是直接的宏调用。示例 9-1 有一些尝试通过索引访问 vector 中元素的例子：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">示例 9-1：尝试访问超越 vector 结尾的元素，这会造成 <code>panic!</code></span></p>
<p>这里尝试访问 vector 的第一百个元素，不过它只有三个元素。这种情况下 Rust 会 panic。<code>[]</code> 应当返回一个元素，不过如果传递了一个无效索引，就没有可供 Rust 返回的正确的元素。</p>
<p>这种情况下其他像 C 这样语言会尝试直接提供所要求的值，即便这可能不是你期望的：你会得到任何对应 vector 中这个元素的内存位置的值，甚至是这些内存并不属于 vector 的情况。这被称为 <strong>缓冲区溢出</strong>（<em>buffer overread</em>），并可能会导致安全漏洞，比如攻击者可以像这样操作索引来读取储存在数组后面不被允许的数据。</p>
<p>为了使程序远离这类漏洞，如果尝试读取一个索引不存在的元素，Rust 会停止执行并拒绝继续。尝试运行上面的程序会出现如下：</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', /checkout/src/liballoc/vec.rs:1555:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>这指向了一个不是我们编写的文件，<em>libcollections/vec.rs</em>。这是标准库中 <code>Vec&lt;T&gt;</code> 的实现。这是当对 vector <code>v</code> 使用 <code>[]</code> 时 <em>libcollections/vec.rs</em> 中会执行的代码，也是真正出现 <code>panic!</code> 的地方。</p>
<p>接下来的几行提醒我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace <em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地。这一行往上是你的代码调用的代码；往下则是调用你的代码的代码。这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码。让我们尝试获取一个 backtrace：示例 9-2 展示了与你看到类似的输出：</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at /checkout/src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at /checkout/src/libstd/sys_common/backtrace.rs:60
             at /checkout/src/libstd/panicking.rs:381
   3: std::panicking::default_hook
             at /checkout/src/libstd/panicking.rs:397
   4: std::panicking::rust_panic_with_hook
             at /checkout/src/libstd/panicking.rs:611
   5: std::panicking::begin_panic
             at /checkout/src/libstd/panicking.rs:572
   6: std::panicking::begin_panic_fmt
             at /checkout/src/libstd/panicking.rs:522
   7: rust_begin_unwind
             at /checkout/src/libstd/panicking.rs:498
   8: core::panicking::panic_fmt
             at /checkout/src/libcore/panicking.rs:71
   9: core::panicking::panic_bounds_check
             at /checkout/src/libcore/panicking.rs:58
  10: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;usize&gt;&gt;::index
             at /checkout/src/liballoc/vec.rs:1555
  11: panic::main
             at src/main.rs:4
  12: __rust_maybe_catch_panic
             at /checkout/src/libpanic_unwind/lib.rs:99
  13: std::rt::lang_start
             at /checkout/src/libstd/panicking.rs:459
             at /checkout/src/libstd/panic.rs:361
             at /checkout/src/libstd/rt.rs:61
  14: main
  15: __libc_start_main
  16: &lt;unknown&gt;
</code></pre>
<p><span class="caption">示例 9-2：当设置 <code>RUST_BACKTRACE</code> 环境变量时 <code>panic!</code> 调用所生成的 backtrace 信息</span></p>
<p>这里有大量的输出！你实际看到的输出可能因不同的操作系统和 Rust 版本而有所不同。为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 --release 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用，这里便是如此。</p>
<p>示例 9-2 的输出中，backtrace 的 11 行指向了我们项目中造成问题的行：<em>src/main.rs</em> 的第 4 行。如果你不希望程序 panic，第一个提到我们编写的代码行的位置是你应该开始调查的，以便查明是什么值如何在这个地方引起了 panic。在上面的例子中，我们故意编写会 panic 的代码来演示如何使用 backtrace，修复这个 panic 的方法就是不要尝试在一个只包含三个项的 vector 中请求索引是 100 的元素。当将来你的代码出现了 panic，你需要搞清楚在这特定的场景下代码中执行了什么操作和什么值导致了 panic，以及应当如何处理才能避免这个问题。</p>
<p>本章后面的小节“panic! 还是不 panic!”会再次回到 <code>panic!</code> 并讲到何时应该及何时不应该使用这个方式。接下来，我们来看看如何使用 <code>Result</code> 来从错误中恢复。</p>
<a class="header" href="print.html#result-与可恢复的错误" id="result-与可恢复的错误"><h2><code>Result</code> 与可恢复的错误</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch09-02-recoverable-errors-with-result.md">ch09-02-recoverable-errors-with-result.md</a>
<br>
commit 347a8bf6beaf34cef5c4e82c2171f498f081485e</p>
</blockquote>
<p>大部分错误并没有严重到需要程序完全停止执行。有时，一个函数会因为一个容易理解并做出反应的原因失败。例如，如果尝试打开一个文件不过由于文件并不存在而失败，此时我们可能想要创建这个文件而不是终止进程。</p>
<p>回忆一下第二章 “使用 <code>Result</code> 类型来处理潜在的错误” 部分中的那个 <code>Result</code> 枚举，它定义有如下两个成员，<code>Ok</code> 和 <code>Err</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>T</code> 和 <code>E</code> 是泛型类型参数；第十章会详细介绍泛型。现在你需要知道的就是 <code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型，而 <code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型。因为 <code>Result</code> 有这些泛型类型参数，我们可以将 <code>Result</code> 类型和标准库中为其定义的函数用于很多不同的场景，这些情况中需要返回的成功值和失败值可能会各不相同。</p>
<p>让我们调用一个返回 <code>Result</code> 的函数，因为它可能会失败：如示例 9-3 所示打开一个文件：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">示例 9-3：打开文件</span></p>
<p>如何知道 <code>File::open</code> 返回一个 <code>Result</code> 呢？我们可以查看标准库 API 文档，或者可以直接问编译器！如果给 <code>f</code> 某个我们知道 <strong>不是</strong> 函数返回值类型的类型注解，接着尝试编译代码，编译器会告诉我们类型不匹配。然后错误信息会告诉我们 <code>f</code> 的类型 <strong>应该</strong> 是什么。让我们试试！我们知道 <code>File::open</code> 的返回值不是 <code>u32</code> 类型的，所以将 <code>let f</code> 语句改为如下：</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>现在尝试编译会给出如下输出：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>这就告诉我们了 <code>File::open</code> 函数的返回值类型是 <code>Result&lt;T, E&gt;</code>。这里泛型参数 <code>T</code> 放入了成功值的类型 <code>std::fs::File</code>，它是一个文件句柄。<code>E</code> 被用在失败值上时 <code>E</code> 的类型是 <code>std::io::Error</code>。</p>
<p>这个返回值类型说明 <code>File::open</code> 调用可能会成功并返回一个可以进行读写的文件句柄。这个函数也可能会失败：例如，文件可能并不存在，或者可能没有访问文件的权限。<code>File::open</code> 需要一个方式告诉我们是成功还是失败，并同时提供给我们文件句柄或错误信息。而这些信息正是 <code>Result</code> 枚举可以提供的。</p>
<p>当 <code>File::open</code> 成功的情况下，变量 <code>f</code> 的值将会是一个包含文件句柄的 <code>Ok</code> 实例。在失败的情况下，<code>f</code> 的值会是一个包含更多关于出现了何种错误信息的 <code>Err</code> 实例。</p>
<p>我们需要在示例 9-3 的代码中增加根据 <code>File::open</code> 返回值进行不同处理的逻辑。示例 9-4 展示了一个使用基本工具处理 <code>Result</code> 的例子：第六章学习过的 <code>match</code> 表达式。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">示例 9-4：使用 <code>match</code> 表达式处理可能的 <code>Result</code> 成员</span></p>
<p>注意与 <code>Option</code> 枚举一样，<code>Result</code> 枚举和其成员也被导入到了 prelude 中，所以就不需要在 <code>match</code> 分支中的 <code>Ok</code> 和 <code>Err</code> 之前指定 <code>Result::</code>。</p>
<p>这里我们告诉 Rust 当结果是 <code>Ok</code> 时，返回 <code>Ok</code> 成员中的 <code>file</code> 值，然后将这个文件句柄赋值给变量 <code>f</code>。<code>match</code> 之后，我们可以利用这个文件句柄来进行读写。</p>
<p><code>match</code> 的另一个分支处理从 <code>File::open</code> 得到 <code>Err</code> 值的情况。在这种情况下，我们选择调用 <code>panic!</code> 宏。如果当前目录没有一个叫做 <em>hello.txt</em> 的文件，当运行这段代码时会看到如下来自 <code>panic!</code> 宏的输出：</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>输出一如既往告诉了我们到底出了什么错。</p>
<a class="header" href="print.html#a匹配不同的错误" id="a匹配不同的错误"><h3>匹配不同的错误</h3></a>
<p>示例 9-4 中的代码不管 <code>File::open</code> 是因为什么原因失败都会 <code>panic!</code>。我们真正希望的是对不同的错误原因采取不同的行为：如果 <code>File::open</code>因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄。如果 <code>File::open</code> 因为任何其他原因失败，例如没有打开文件的权限，我们仍然希望像示例 9-4 那样 <code>panic!</code>。让我们看看示例 9-5，其中 <code>match</code> 增加了另一个分支：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">示例 9-5：使用不同的方式处理不同类型的错误</span></p>
<p><code>File::open</code> 返回的 <code>Err</code> 成员中的值类型 <code>io::Error</code>，它是一个标准库中提供的结构体。这个结构体有一个返回 <code>io::ErrorKind</code> 值的 <code>kind</code> 方法可供调用。<code>io::ErrorKind</code> 是一个标准库提供的枚举，它的成员对应 <code>io</code> 操作可能导致的不同错误类型。我们感兴趣的成员是 <code>ErrorKind::NotFound</code>，它代表尝试打开的文件并不存在。</p>
<p>条件 <code>if error.kind() == ErrorKind::NotFound</code> 被称作 <em>match guard</em>：它是一个进一步完善 <code>match</code> 分支模式的额外的条件。这个条件必须为真才能使分支的代码被执行；否则，模式匹配会继续并考虑 <code>match</code> 中的下一个分支。模式中的 <code>ref</code> 是必须的，这样 <code>error</code> 就不会被移动到 guard 条件中而仅仅只是引用它。第十八章会详细解释为什么在模式中使用 <code>ref</code> 而不是 <code>&amp;</code> 来获取一个引用。简而言之，在模式的上下文中，<code>&amp;</code> 匹配一个引用并返回它的值，而 <code>ref</code> 匹配一个值并返回一个引用。</p>
<p>在 match guard 中我们想要检查的条件是 <code>error.kind()</code> 是否是 <code>ErrorKind</code> 枚举的 <code>NotFound</code> 成员。如果是，尝试用 <code>File::create</code> 创建文件。然而 <code>File::create</code> 也可能会失败，还需要增加一个内部 <code>match</code> 语句。当文件不能被打开，会打印出一个不同的错误信息。外部 <code>match</code> 的最后一个分支保持不变这样对任何除了文件不存在的错误会使程序 panic。</p>
<a class="header" href="print.html#a失败时-panic-的简写unwrap-和-expect" id="a失败时-panic-的简写unwrap-和-expect"><h3>失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></h3></a>
<p><code>match</code> 能够胜任它的工作，不过它可能有点冗长并且不总是能很好的表明其意图。<code>Result&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <code>unwrap</code>，它的实现就类似于示例 9-4 中的 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p><code>expect</code> 与 <code>unwrap</code> 的使用方式一样：返回文件句柄或调用 <code>panic!</code> 宏。<code>expect</code> 用来调用 <code>panic!</code> 的错误信息将会作为参数传递给 <code>expect</code> ，而不像<code>unwrap</code> 那样使用默认的 <code>panic!</code> 信息。它看起来像这样：</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>因为这个错误信息以我们指定的文本开始，<code>Failed to open hello.txt</code>，将会更容易找到代码中的错误信息来自何处。如果在多处使用 <code>unwrap</code>，则需要花更多的时间来分析到底是哪一个 <code>unwrap</code> 造成了 panic，因为所有的 <code>unwrap</code> 调用都打印相同的信息。</p>
<a class="header" href="print.html#a传播错误" id="a传播错误"><h3>传播错误</h3></a>
<p>当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 <strong>传播</strong>（<em>propagating</em>）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p>
<p>例如，示例 9-6 展示了一个从文件中读取用户名的函数。如果文件不存在或不能读取，这个函数会将这些错误返回给调用它的代码：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 9-6：一个函数使用 <code>match</code> 将错误返回给代码调用者</span></p>
<p>首先让我们看看函数的返回值：<code>Result&lt;String, io::Error&gt;</code>。这意味着函数返回一个 <code>Result&lt;T, E&gt;</code> 类型的值，其中泛型参数 <code>T</code> 的具体类型是 <code>String</code>，而 <code>E</code> 的具体类型是 <code>io::Error</code>。如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含 <code>String</code> 的 <code>Ok</code> 值————函数从文件中读取到的用户名。如果函数遇到任何错误，函数的调用者会收到一个 <code>Err</code> 值，它储存了一个包含更多这个问题相关信息的 <code>io::Error</code> 实例。这里选择 <code>io::Error</code> 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：<code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数体以 <code>File::open</code> 函数开头。接着使用 <code>match</code> 处理返回值 <code>Result</code>，类似于示例 9-4 中的 <code>match</code>，唯一的区别是当 <code>Err</code> 时不再调用 <code>panic!</code>，而是提早返回并将 <code>File::open</code> 返回的错误值作为函数的错误返回值传递给调用者。如果 <code>File::open</code> 成功了，我们将文件句柄储存在变量 <code>f</code> 中并继续。</p>
<p>接着我们在变量 <code>s</code> 中创建了一个新 <code>String</code> 并调用文件句柄 <code>f</code> 的 <code>read_to_string</code> 方法来将文件的内容读取到 <code>s</code> 中。<code>read_to_string</code> 方法也返回一个 <code>Result</code> 因为它也可能会失败：哪怕是 <code>File::open</code> 已经成功了。所以我们需要另一个 <code>match</code> 来处理这个 <code>Result</code>：如果 <code>read_to_string</code> 成功了，那么这个函数就成功了，并返回文件中的用户名，它现在位于被封装进 <code>Ok</code> 的 <code>s</code> 中。如果<code>read_to_string</code> 失败了，则像之前处理 <code>File::open</code> 的返回值的 <code>match</code> 那样返回错误值。不过并不需要显式的调用 <code>return</code>，因为这是函数的最后一个表达式。</p>
<p>调用这个函数的代码最终会得到一个包含用户名的 <code>Ok</code> 值，或者一个包含 <code>io::Error</code> 的 <code>Err</code> 值。我们无从得知调用者会如何处理这些值。例如，如果他们得到了一个 <code>Err</code> 值，他们可能会选择 <code>panic!</code> 并使程序崩溃、使用一个默认的用户名或者从文件之外的地方寻找用户名。我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法。</p>
<p>这种传播错误的模式在 Rust 是如此的常见，以至于有一个更简便的专用语法：<code>?</code>。</p>
<a class="header" href="print.html#a传播错误的简写" id="a传播错误的简写"><h3>传播错误的简写：<code>?</code></h3></a>
<p>示例 9-7 展示了一个 <code>read_username_from_file</code> 的实现，它实现了与示例 9-6 中的代码相同的功能，不过这个实现使用了问号运算符：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">示例 9-6：一个使用 <code>?</code> 向调用者返回错误的函数</span></p>
<p><code>Result</code> 值之后的 <code>?</code> 被定义为与示例 9-6 中定义的处理 <code>Result</code> 值的 <code>match</code> 表达式有着完全相同的工作方式。如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 中的值将作为整个函数的返回值，就好像使用了 <code>return</code> 关键字一样，这样错误值就被传播给了调用者。</p>
<p>示例 9-6 中的 <code>match</code> 表达式与问号运算符所做的有一点不同：<code>?</code> 所使用的错误值被传递给了 <code>from</code> 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。到问号运算符调用 <code>from</code> 函数时，收到的错误类型被转换为定义为当前函数返回的错误类型。这在当一个函数返回一个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 <code>from</code> 函数来定义如将其转换为返回的错误类型，问号运算符会自动处理这些转换。</p>
<p>在示例 9-7 的上下文中，<code>File::open</code> 调用结尾的 <code>?</code> 将会把 <code>Ok</code> 中的值返回给变量 <code>f</code>。如果出现了错误，<code>?</code> 会提早返回整个函数并将一些 <code>Err</code> 值传播给调用者。同理也适用于 <code>read_to_string</code> 调用结尾的 <code>?</code>。</p>
<p><code>?</code> 消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 <code>?</code> 之后直接使用链式方法调用来进一步缩短代码，如示例 9-8 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">示例 9-8：问号运算符之后的链式方法调用</span></p>
<p>在 <code>s</code> 中创建新的 <code>String</code> 被放到了函数开头；这一部分没有变化。我们对 <code>File::open(&quot;hello.txt&quot;)?</code> 的结果直接链式调用了 <code>read_to_string</code>，而不再创建变量 <code>f</code>。仍然需要 <code>read_to_string</code> 调用结尾的 <code>?</code>，而且当 <code>File::open</code> 和 <code>read_to_string</code> 都成功没有失败时返回包含用户名 <code>s</code> 的 <code>Ok</code> 值。其功能再一次与示例 9-6 和示例 9-7 保持一致，不过这是一个与众不同且更符合工程学的写法。</p>
<a class="header" href="print.html#a-只能被用于返回-result-的函数" id="a-只能被用于返回-result-的函数"><h3><code>?</code> 只能被用于返回 <code>Result</code> 的函数</h3></a>
<p><code>?</code> 只能被用于返回值类型为 <code>Result</code> 的函数，因为他被定义为与示例 9-6 中的 <code>match</code> 表达式有着完全相同的工作方式。<code>match</code> 的 <code>return Err(e)</code> 部分要求返回值类型是 <code>Result</code>，所以函数的返回值必须是 <code>Result</code> 才能与这个 <code>return</code> 相兼容。</p>
<p>让我们看看在 <code>main</code> 函数中使用 <code>?</code> 会发生什么，如果你还记得的话其返回值类型是<code>()</code>：</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>当编译这些代码，会得到如下错误信息：</p>
<pre><code class="language-text">error[E0277]: the trait bound `(): std::ops::Try` is not satisfied
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             the `?` operator can only be used in a function that returns
  `Result` (or another type that implements `std::ops::Try`)
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>错误指出只能在返回 <code>Result</code> 的函数中使用问号运算符。在不返回 <code>Result</code> 的函数中，当调用其他返回 <code>Result</code> 的函数时，需要使用 <code>match</code> 或 <code>Result</code> 的方法之一来处理，而不能用 <code>?</code> 将潜在的错误传播给调用者。</p>
<p>现在我们讨论过了调用 <code>panic!</code> 或返回 <code>Result</code> 的细节，是时候回到他们各自适合哪些场景的话题了。</p>
<a class="header" href="print.html#panic-还是不-panic" id="panic-还是不-panic"><h2><code>panic!</code> 还是不 <code>panic!</code></h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch09-03-to-panic-or-not-to-panic.md">ch09-03-to-panic-or-not-to-panic.md</a>
<br>
commit 609909ec443042399858d1f679b0df1d6d0eba22</p>
</blockquote>
<p>那么，该如何决定何时应该 <code>panic!</code> 以及何时应该返回 <code>Result</code> 呢？如果代码 panic，就没有恢复的可能。你可以选择对任何错误场景都调用 <code>panic!</code>，不管是否有可能恢复，不过这样就是你代替调用者决定了这是不可恢复的。选择返回 <code>Result</code> 值的话，就将选择权交给了调用者，而不是代替他们做出决定。调用者可能会选择以符合他们场景的方式尝试恢复，或者也可能干脆就认为 <code>Err</code> 是不可恢复的，所以他们也可能会调用 <code>panic!</code> 并将可恢复的错误变成了不可恢复的错误。因此返回 <code>Result</code> 是定义可能会失败的函数的一个好的默认选择。</p>
<p>有一些情况 panic 比返回 <code>Result</code> 更为合适，不过他们并不常见。让我们讨论一下为何在示例、代码原型和测试中，以及那些人们认为不会失败而编译器不这么看的情况下， panic 是合适的，最后会总结一些在库代码中如何决定是否要 panic 的通用指导原则。</p>
<a class="header" href="print.html#a示例代码原型和测试都非常适合-panic" id="a示例代码原型和测试都非常适合-panic"><h3>示例、代码原型和测试都非常适合 panic</h3></a>
<p>当你编写一个示例来展示一些概念时，在拥有健壮的错误处理代码的同时也会使得例子不那么明确。例如，调用一个类似 <code>unwrap</code> 这样可能 <code>panic!</code> 的方法可以被理解为一个你实际希望程序处理错误方式的占位符，它根据其余代码运行方式可能会各不相同。</p>
<p>类似地，在我们准备好决定如何处理错误之前，<code>unwrap</code>和<code>expect</code>方法在原型设计时非常方便。当我们准备好让程序更加健壮时，它们会在代码中留下清晰的标记。</p>
<p>如果方法调用在测试中失败了，我们希望这个测试都失败，即便这个方法并不是需要测试的功能。因为 <code>panic!</code> 是测试如何被标记为失败的，调用 <code>unwrap</code> 或 <code>expect</code> 就是应该发生的事情。</p>
<a class="header" href="print.html#a当你比编译器知道更多的情况" id="a当你比编译器知道更多的情况"><h3>当你比编译器知道更多的情况</h3></a>
<p>当你有一些其他的逻辑来确保 <code>Result</code> 会是 <code>Ok</code> 值时，调用 <code>unwrap</code> 也是合适的，虽然编译器无法理解这种逻辑。你仍然需要处理一个 <code>Result</code> 值：即使在你的特定情况下逻辑上是不可能的，你所调用的任何操作仍然有可能失败。如果通过人工检查代码来确保永远也不会出现 <code>Err</code> 值，那么调用 <code>unwrap</code> 也是完全可以接受的，这里是一个例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
#}</code></pre></pre>
<p>我们通过解析一个硬编码的字符来创建一个 <code>IpAddr</code> 实例。可以看出 <code>127.0.0.1</code> 是一个有效的 IP 地址，所以这里使用 <code>unwrap</code> 是可以接受的。然而，拥有一个硬编码的有效的字符串也不能改变 <code>parse</code> 方法的返回值类型：它仍然是一个 <code>Result</code> 值，而编译器仍然就好像还是有可能出现 <code>Err</code> 成员那样要求我们处理 <code>Result</code>，因为编译器还没有智能到可以识别出这个字符串总是一个有效的 IP 地址。如果 IP 地址字符串来源于用户而不是硬编码进程序中的话，那么就 <strong>确实</strong> 有失败的可能性，这时就绝对需要我们以一种更健壮的方式处理 <code>Result</code> 了。</p>
<a class="header" href="print.html#a错误处理指导原则" id="a错误处理指导原则"><h3>错误处理指导原则</h3></a>
<p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code> —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况：</p>
<ul>
<li>有害状态并不包含 <strong>预期</strong> 会偶尔发生的错误</li>
<li>之后的代码的运行依赖于处于这种有害状态</li>
<li>当没有可行的手段来将有害状态信息编码进所使用的类型中的情况</li>
</ul>
<p>如果别人调用你的代码并传递了一个没有意义的值，最好的情况也许就是 <code>panic!</code> 并警告使用你的库的人他的代码中有 bug 以便他能在开发时就修复它。类似的，<code>panic!</code> 通常适合调用不能够控制的外部代码时，这时无法修复其返回的无效状态。</p>
<p>无论代码编写的多么好，当有害状态是预期会出现时，返回 <code>Result</code> 仍要比调用 <code>panic!</code> 更为合适。这样的例子包括解析器接收到错误数据，或者 HTTP 请求返回一个表明触发了限流的状态。在这些例子中，应该通过返回 <code>Result</code> 来表明失败预期是可能的，这样将有害状态向上传播，调用者就可以决定该如何处理这个问题。使用 <code>panic!</code> 来处理这些情况就不是最好的选择。</p>
<p>当代码对值进行操作时，应该首先验证值是有效的，并在其无效时 <code>panic!</code>。这主要是出于安全的原因：尝试操作无效数据会暴露代码漏洞，这就是标准库在尝试越界访问数组时会 <code>panic!</code> 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全隐患。函数通常都遵循 <strong>契约</strong>（<em>contracts</em>）：他们的行为只有在输入满足特定条件时才能得到保证。当违反契约时 panic 是有道理的，因为这通常代表调用方的 bug，而且这也不是那种你希望调用方必须处理的错误。事实上也没有合理的方式来恢复调用方的代码：调用方的 <strong>程序员</strong> 需要修复其代码。函数的契约，尤其是当违反它会造成 panic 的契约，应该在函数的 API 文档中得到解释。</p>
<p>虽然在所有函数中都拥有许多错误检查是冗长而烦人的。幸运的是，可以利用 Rust 的类型系统（以及编译器的类型检查）为你进行很多检查。如果函数有一个特定类型的参数，可以在知晓编译器已经确保其拥有一个有效值的前提下进行你的代码逻辑。例如，如果你使用了一个不同于 <code>Option</code> 的类型，而且程序期望它是 <strong>有值</strong> 的并且不是 <strong>空值</strong>。你的代码无需处理 <code>Some</code> 和 <code>None</code> 这两种情况，它只会有一种情况就是绝对会有一个值。尝试向函数传递空值的代码甚至根本不能编译，所以你的函数在运行时没有必要判空。另外一个例子是使用像 <code>u32</code> 这样的无符号整型，也会确保它永远不为负。</p>
<a class="header" href="print.html#a创建自定义类型作为验证" id="a创建自定义类型作为验证"><h3>创建自定义类型作为验证</h3></a>
<p>让我们使用 Rust 类型系统的思想来进一步确保值的有效性，并尝试创建一个自定义类型以进行验证。回忆一下第二章的猜猜看游戏，我们的代码要求用户猜测一个 1 到 100 之间的数字，在将其与秘密数字做比较之前我们从未验证用户的猜测是位于这两个数字之间的，我们只验证它是否为正。在这种情况下，其影响并不是很严重：“Too high” 或 “Too low” 的输出仍然是正确的。但是这是一个很好的引导用户得出有效猜测的辅助，例如当用户猜测一个超出范围的数字或者输入字母时采取不同的行为。</p>
<p>一种实现方式是将猜测解析成 <code>i32</code> 而不仅仅是 <code>u32</code>，来默许输入负数，接着检查数字是否在范围内：</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<p><code>if</code> 表达式检查了值是否超出范围，告诉用户出了什么问题，并调用 <code>continue</code> 开始下一次循环，请求另一个猜测。<code>if</code> 表达式之后，就可以在知道 <code>guess</code> 在 1 到 100 之间的情况下与秘密数字作比较了。</p>
<p>然而，这并不是一个理想的解决方案：程序只处理 1 到 100 之间的值是绝对不可取的，而且如果有很多函数都有这样的要求，在每个函数中都有这样的检查将是非常冗余的（并可能潜在的影响性能）。</p>
<p>相反我们可以创建一个新类型来将验证放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全的在函数签名中使用新类型并相信他们接收到的值。示例 9-9 中展示了一个定义 <code>Guess</code> 类型的方法，只有在 <code>new</code> 函数接收到 1 到 100 之间的值时才会创建 <code>Guess</code> 的实例：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 9-9：一个 <code>Guess</code> 类型，它只在值位于 1 和 100 之间时才继续</span></p>
<p>首先，我们定义了一个包含 <code>u32</code> 类型字段 <code>value</code> 的结构体 <code>Guess</code>。这里是储存猜测值的地方。</p>
<p>接着在 <code>Guess</code> 上实现了一个叫做 <code>new</code> 的关联函数来创建 <code>Guess</code> 的实例。<code>new</code> 定义为接收一个 <code>u32</code> 类型的参数 <code>value</code> 并返回一个 <code>Guess</code>。<code>new</code> 函数中代码的测试确保了其值是在 1 到 100 之间的。如果 <code>value</code> 没有通过测试则调用 <code>panic!</code>，这会警告调用这个函数的程序员有一个需要修改的 bug，因为创建一个 <code>value</code> 超出范围的 <code>Guess</code> 将会违反 <code>Guess::new</code> 所遵循的契约。<code>Guess::new</code> 会出现 panic 的条件应该在其公有 API 文档中被提及；第十四章会涉及到在 API 文档中表明 <code>panic!</code> 可能性的相关规则。如果 <code>value</code> 通过了测试，我们新建一个 <code>Guess</code>，其字段 <code>value</code> 将被设置为参数 <code>value</code> 的值，接着返回这个 <code>Guess</code>。</p>
<p>接着，我们实现了一个借用了 <code>self</code> 的方法 <code>value</code>，它没有任何其他参数并返回一个 <code>u32</code>。这类方法有时被称为 <em>getter</em>，因为它的目的就是返回对应字段的数据。这样的公有方法是必要的，因为 <code>Guess</code> 结构体的 <code>value</code> 字段是私有的。私有的字段 <code>value</code> 是很重要的，这样使用 <code>Guess</code> 结构体的代码将不允许直接设置 <code>value</code> 的值：调用者 <strong>必须</strong> 使用 <code>Guess::new</code> 方法来创建一个 <code>Guess</code> 的实例，这就确保了不会存在一个 <code>value</code> 没有通过 <code>Guess::new</code> 函数的条件检查的 <code>Guess</code>。</p>
<p>如此获取一个参数并只返回 1 到 100 之间数字的函数就可以声明为获取或返回一个 <code>Guess</code>，而不是 <code>u32</code>，同时其函数体中也无需进行任何额外的检查。</p>
<a class="header" href="print.html#a总结-8" id="a总结-8"><h2>总结</h2></a>
<p>Rust 的错误处理功能被设计为帮助你编写更加健壮的代码。<code>panic!</code> 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。Rust 类型系统的 <code>Result</code> 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 <code>Result</code> 来告诉代码调用者他需要处理潜在的成功或失败。在适当的场景使用 <code>panic!</code> 和 <code>Result</code> 将会使你的代码在面对无处不在的错误时显得更加可靠。</p>
<p>现在我们已经见识过了标准库中 <code>Option</code> 和 <code>Result</code> 泛型枚举的能力了，在下一章让我们聊聊泛型是如何工作的，以及如何在你的代码中使用他们。</p>
<a class="header" href="print.html#a泛型trait-和生命周期" id="a泛型trait-和生命周期"><h1>泛型、trait 和生命周期</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch10-00-generics.md">ch10-00-generics.md</a>
<br>
commit 9e8d1ed7a1732d9cc09606a9b62ee8838998502f</p>
</blockquote>
<p>每一个编程语言都有高效的处理重复概念的工具；在 Rust 中其工具之一就是 <strong>泛型</strong>（<em>generics</em>）。泛型是具体类型或其他属性的抽象替代。我们可以表达泛型的属性，比如他们的行为或如何与其他泛型相关联，而不需要在编写和编译代码时知道他们在这里实际上代表什么。</p>
<p>同理为了编写一份可以用于多种具体值的代码，函数并不知道其参数为何值，这时就可以让函数获取泛型而不是像 <code>i32</code> 或 <code>String</code> 这样的具体值。我们已经使用过第六章的 <code>Option&lt;T&gt;</code>，第八章的 <code>Vec&lt;T&gt;</code> 和 <code>HashMap&lt;K, V&gt;</code>，以及第九章的 <code>Result&lt;T, E&gt;</code> 这些泛型了。本章会探索如何使用泛型定义我们自己的类型、函数和方法！</p>
<p>首先，我们将回顾一下提取函数以减少代码重复的机制。接着使用一个只在参数类型上不同的泛型函数来实现相同的功能。我们也会讲到结构体和枚举定义中的泛型。</p>
<p>之后，我们讨论 <em>trait</em>，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。</p>
<p>最后介绍 <strong>生命周期</strong>（<em>lifetimes</em>），它是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。</p>
<a class="header" href="print.html#a提取函数来减少重复" id="a提取函数来减少重复"><h2>提取函数来减少重复</h2></a>
<p>在介绍泛型语法之前，首先来回顾一个不使用泛型的处理重复的技术：提取一个函数。当熟悉了这个技术以后，我们将使用相同的机制来提取一个泛型函数！如同你识别出可以提取到函数中重复代码那样，你也会开始识别出能够使用泛型的重复代码。</p>
<p>考虑一下这个寻找列表中最大值的小程序，如示例 10-1 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
#  assert_eq!(largest, 100);
}
</code></pre></pre>
<p><span class="caption">示例 10-1：在一个数字列表中寻找最大值的函数</span></p>
<p>这段代码获取一个整型列表，存放在变量 <code>number_list</code> 中。它将列表的第一项放入了变量 <code>largest</code> 中。接着遍历了列表中的所有数字，如果当前值大于 <code>largest</code> 中储存的值，将 <code>largest</code> 替换为这个值。如果当前值小于目前为止的最大值，<code>largest</code> 保持不变。当列表中所有值都被考虑到之后，<code>largest</code> 将会是最大值，在这里也就是 100。</p>
<p>如果需要在两个不同的列表中寻找最大值，我们可以重复示例 10-1 中的代码，这样程序中就会存在两段相同逻辑的代码，如示例 10-2 所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">示例 10-2：寻找 <strong>两个</strong> 数字列表最大值的代码</span></p>
<p>虽然代码能够执行，但是重复的代码是冗余且容易出错的，并且意味着当更新逻辑时需要修改多处地方的代码。</p>
<!-- Are we safe assuming the reader will be familiar with the term
"abstraction" in this context, or do we want to give a brief definition? -->
<!-- Yes, our audience will be familiar with this term. /Carol -->
<p>为了消除重复，我们可以创建一层抽象，在这个例子中将表现为一个获取任意整型列表作为参数并对其进行处理的函数。这将增加代码的简洁性并让我们将表达和推导寻找列表中最大值的这个概念与使用这个概念的特定位置相互独立。</p>
<p>在示例 10-3 的程序中将寻找最大值的代码提取到了一个叫做 <code>largest</code> 的函数中。这个程序可以找出两个不同数字列表的最大值，不过示例 10-1 中的代码只存在于一个位置：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 6000);
}
</code></pre></pre>
<p><span class="caption">示例 10-3：抽象后的寻找两个数字列表最大值的代码</span></p>
<p>这个函数有一个参数 <code>list</code>，它代表会传递给函数的任何具体的 <code>i32</code>值的 slice。函数定义中的 <code>list</code> 代表任何 <code>&amp;[i32]</code>。当调用 <code>largest</code> 函数时，其代码实际上运行于我们传递的特定值上。</p>
<p>从示例 10-2 到示例 10-3 中涉及的机制经历了如下几步：</p>
<ol>
<li>我们注意到了重复代码。</li>
<li>我们将重复代码提取到了一个函数中，并在函数签名中指定了代码中的输入和返回值。</li>
<li>我们将重复代码的两个实例，改为调用函数。</li>
</ol>
<p>在不同的场景使用不同的方式，我们也可以利用相同的步骤和泛型来减少重复代码。与函数体可以在抽象<code>list</code>而不是特定值上操作的方式相同，泛型允许代码对抽象类型进行操作。</p>
<p>如果我们有两个函数，一个寻找一个 <code>i32</code> 值的 slice 中的最大项而另一个寻找 <code>char</code> 值的 slice 中的最大项该怎么办？该如何消除重复呢？让我们拭目以待！</p>
<a class="header" href="print.html#a泛型数据类型" id="a泛型数据类型"><h2>泛型数据类型</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch10-01-syntax.md">ch10-01-syntax.md</a>
<br>
commit 9e8d1ed7a1732d9cc09606a9b62ee8838998502f</p>
</blockquote>
<p>泛型用于为函数签名或结构体等创建定义，允许我们创建许多不同的具体数据类型。让我们看看如何使用泛型定义函数、结构体、枚举和方法，然后我们将讨论泛型如何影响代码性能。</p>
<a class="header" href="print.html#a在函数定义中使用泛型" id="a在函数定义中使用泛型"><h3>在函数定义中使用泛型</h3></a>
<p>定义函数时可以在函数签名的参数数据类型和返回值中使用泛型。以这种方式编写的代码将更灵活并能向函数调用者提供更多功能，同时不引入重复代码。</p>
<p>回到 <code>largest</code> 函数上，示例 10-4 中展示了两个提供了相同的寻找 slice 中最大值功能的函数。第一个是从示例 10-3 中提取的寻找 slice 中 <code>i32</code> 最大值的函数。第二个函数寻找 slice 中 <code>char</code> 的最大值：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
#    assert_eq!(result, 'y');
}
</code></pre></pre>
<p><span class="caption">示例 10-4：两个只在名称和签名中类型有所不同的函数</span></p>
<p>这里 <code>largest_i32</code> 和 <code>largest_char</code> 有着完全相同的函数体，所以如果能够将这两个函数变成一个来减少重复就太好了。所幸通过引入一个泛型参数就能实现！</p>
<p>为了参数化要定义的函数的签名中的类型，我们需要像给函数的值参数起名那样为这类型参数起一个名字。这里选择了名称 <code>T</code>。任何标识符都可以作为类型参数名，选择 <code>T</code> 是因为 Rust 的类型命名规范是骆驼命名法（CamelCase）。另外泛型类型参数的规范也倾向于简短，经常仅仅是一个字母。<code>T</code> 作为 “type” 的缩写是大部分 Rust 程序员的首选。</p>
<p>当需要在函数体中使用一个参数时，必须在函数签名中声明这个参数以便编译器能知道函数体中这个名称的意义。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。类型参数声明位于函数名称与参数列表中间的尖括号中。</p>
<p>我们将要定义的泛型版本的 <code>largest</code> 函数的签名看起来像这样：</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>这可以理解为：函数 <code>largest</code> 有泛型类型 <code>T</code>。它有一个参数 <code>list</code>，它的类型是一个 <code>T</code> 值的 slice。<code>largest</code> 函数将会返回一个与 <code>T</code> 相同类型的值。</p>
<p>示例 10-5 展示一个在签名中使用了泛型的统一的 <code>largest</code> 函数定义，并向我们展示了如何对 <code>i32</code> 值的 slice 或 <code>char</code> 值的 slice 调用 <code>largest</code> 函数。注意这些代码还不能编译！</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">示例 10-5：一个还不能编译的使用泛型参数的 <code>largest</code> 函数定义</span></p>
<p>如果现在就尝试编译这些代码，会出现如下错误：</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; largest {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>注释中提到了 <code>std::cmp::PartialOrd</code>，这是一个 <em>trait</em>。下一部分会讲到 trait，不过简单来说，这个错误表明 <code>largest</code> 的函数体不能适用于 <code>T</code> 的所有可能的类型；因为在函数体需要比较 <code>T</code> 类型的值，不过它只能用于我们知道如何排序的类型。标准库中定义的 <code>std::cmp::PartialOrd</code> trait 可以实现类型的比较功能。在下一部分会再次回到 trait 并讲解如何为泛型指定一个 trait，不过让我们先把这个例子放在一边并探索其他那些可以使用泛型类型参数的地方。</p>
<!-- Liz: this is the reason we had the topics in the order we did in the first
draft of this chapter; it's hard to do anything interesting with generic types
in functions unless you also know about traits and trait bounds. I think this
ordering could work out okay, though, and keep a stronger thread with the
`longest` function going through the whole chapter, but we do pause with a
not-yet-compiling example here, which I know isn't ideal either. Let us know
what you think. /Carol -->
<a class="header" href="print.html#a结构体定义中的泛型" id="a结构体定义中的泛型"><h3>结构体定义中的泛型</h3></a>
<p>同样也可以使用 <code>&lt;&gt;</code> 语法来定义拥有一个或多个泛型参数类型字段的结构体。示例 10-6 展示了如何定义和使用一个可以存放任何类型的 <code>x</code> 和 <code>y</code> 坐标值的结构体 <code>Point</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">示例 10-6：<code>Point</code> 结构体存放了两个 <code>T</code> 类型的值 <code>x</code> 和 <code>y</code></span></p>
<p>其语法类似于函数定义中使用泛型。首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以指定具体数据类型的位置使用泛型类型。</p>
<p>注意 <code>Point</code> 的定义中只使用了一个泛型类型，我们想要表达的是结构体 <code>Point</code> 对于一些类型 <code>T</code> 是泛型的，而且字段 <code>x</code> 和 <code>y</code> <strong>都是</strong> 相同类型的，无论它具体是何类型。如果尝试创建一个有不同类型值的 <code>Point</code> 的实例，像示例 10-7 中的代码就不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">示例 10-7：字段 <code>x</code> 和 <code>y</code> 必须是相同类型，因为他们都有相同的泛型类型 <code>T</code></span></p>
<p>尝试编译会得到如下错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
  floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>当我们将 5 赋值给 <code>x</code>，编译器就知道这个 <code>Point</code> 实例的泛型类型 <code>T</code> 是一个整型。接着我们将 <code>y</code> 指定为 4.0，而它被定义为与 <code>x</code> 有着相同的类型，所以出现了类型不匹配的错误。</p>
<p>如果想要定义一个 <code>x</code> 和 <code>y</code> 可以有不同类型且仍然是泛型的 <code>Point</code> 结构体，我们可以使用多个泛型类型参数。在示例 10-8 中，我们修改 <code>Point</code> 的定义为拥有两个泛型类型 <code>T</code> 和 <code>U</code>。其中字段 <code>x</code> 是 <code>T</code> 类型的，而字段 <code>y</code> 是 <code>U</code> 类型的：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">示例 10-8：使用两个泛型的 <code>Point</code>，这样 <code>x</code> 和 <code>y</code> 可能是不同类型</span></p>
<p>现在所有这些 <code>Point</code> 实例都是被允许的了！你可以在定义中使用任意多的泛型类型参数，不过太多的话代码将难以阅读和理解。当你的代码中需要许多泛型类型时，它可能表明你的代码需要重组为更小的部分。</p>
<a class="header" href="print.html#a枚举定义中的泛型数据类型" id="a枚举定义中的泛型数据类型"><h3>枚举定义中的泛型数据类型</h3></a>
<p>类似于结构体，枚举也可以在其成员中存放泛型数据类型。第六章我们使用过了标准库提供的 <code>Option&lt;T&gt;</code> 枚举，现在这个定义看起来就更容易理解了。让我们再看看：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>换句话说 <code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举。它有两个成员：<code>Some</code>，它存放了一个类型 <code>T</code> 的值，和不存在任何值的<code>None</code>。标准库中只有这一个定义来支持创建任何具体类型的枚举值。“一个可能的值” 是一个比具体类型的值更抽象的概念，而 Rust 允许我们不引入重复代码就能表现抽象的概念。</p>
<p>枚举也可以拥有多个泛型类型。第九章使用过的 <code>Result</code> 枚举定义就是一个这样的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>Result</code> 枚举有两个泛型类型，<code>T</code> 和 <code>E</code>。<code>Result</code> 有两个成员：<code>Ok</code>，它存放一个类型 <code>T</code> 的值，而 <code>Err</code> 则存放一个类型 <code>E</code> 的值。这个定义使得 <code>Result</code> 枚举能很方便的表达任何可能成功（返回 <code>T</code> 类型的值）也可能失败（返回 <code>E</code> 类型的值）的操作。回忆一下示例 9-2 中打开一个文件的场景：当文件被成功打开 <code>T</code> 被放入了 <code>std::fs::File</code> 类型而当打开文件出现问题时 <code>E</code> 被放入了 <code>std::io::Error</code> 类型。</p>
<p>当发现代码中有多个只有存放的值的类型有所不同的结构体或枚举定义时，你就应该像之前的函数定义中那样引入泛型类型来减少重复代码。</p>
<a class="header" href="print.html#a方法定义中的枚举数据类型" id="a方法定义中的枚举数据类型"><h3>方法定义中的枚举数据类型</h3></a>
<p>可以像第五章介绍的那样来为其定义中带有泛型的结构体或枚举实现方法。示例 10-9 中展示了示例 10-6 中定义的结构体 <code>Point&lt;T&gt;</code>。接着我们在 <code>Point&lt;T&gt;</code> 上定义了一个叫做 <code>x</code> 的方法来返回字段 <code>x</code> 中数据的引用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">示例 10-9：在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用</span></p>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。示例 10-10 展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 10-10：构建一个只用于拥有泛型参数 <code>T</code> 的结构体的具体类型的 <code>impl</code> 块</span></p>
<p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code> 实例则没有定义此方法。这个方法计算点实例与另一个点坐标之间的距离，它使用了只能用于浮点型的数学运算符。</p>
<p>结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。示例 10-11 中在示例 10-8 中的结构体 <code>Point&lt;T, U&gt;</code> 上定义了一个方法 <code>mixup</code>。这个方法获取另一个 <code>Point</code> 作为参数，而它可能与调用 <code>mixup</code> 的 <code>self</code> 是不同的 <code>Point</code> 类型。这个方法用 <code>self</code> 的 <code>Point</code> 类型的 <code>x</code> 值（类型 <code>T</code>）和参数的 <code>Point</code> 类型的 <code>y</code> 值（类型 <code>W</code>）来创建一个新 <code>Point</code> 类型的实例：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">示例 10-11：方法使用了与结构体定义中不同类型的泛型</span></p>
<p>在 <code>main</code> 函数中，定义了一个有 <code>i32</code> 类型的 <code>x</code>（其值为 <code>5</code>）和 <code>f64</code> 的 <code>y</code>（其值为 <code>10.4</code>）的 <code>Point</code>。<code>p2</code> 则是一个有着字符串 slice 类型的 <code>x</code>（其值为 <code>&quot;Hello&quot;</code>）和 <code>char</code> 类型的 <code>y</code>（其值为<code>c</code>）的 <code>Point</code>。在 <code>p1</code> 上以 <code>p2</code> 作为参数调用 <code>mixup</code> 会返回一个 <code>p3</code>，它会有一个 <code>i32</code> 类型的 <code>x</code>，因为 <code>x</code> 来自 <code>p1</code>，并拥有一个 <code>char</code> 类型的 <code>y</code>，因为 <code>y</code> 来自 <code>p2</code>。<code>println!</code> 会打印出 <code>p3.x = 5, p3.y = c</code>。</p>
<p>注意泛型参数 <code>T</code> 和 <code>U</code> 声明于 <code>impl</code> 之后，因为他们与结构体定义相对应。而泛型参数 <code>V</code> 和 <code>W</code> 声明于 <code>fn mixup</code> 之后，因为他们只是相对于方法本身的。</p>
<a class="header" href="print.html#a泛型代码的性能" id="a泛型代码的性能"><h3>泛型代码的性能</h3></a>
<p>在阅读本部分内容的同时，你可能会好奇使用泛型类型参数是否会有运行时消耗。好消息是：Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失！</p>
<p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>编译器所做的工作正好与示例 10-5 中我们创建泛型函数的步骤相反。编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。</p>
<p>让我们看看一个使用标准库中 <code>Option</code> 枚举的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 <code>Option</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一个对应 <code>i32</code> 另一个对应 <code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为 <code>Option_i32</code> 和 <code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<p>编译器生成的单态化版本的代码看起来像这样，并包含将泛型 <code>Option</code> 替换为编译器创建的具体定义后的用例代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因。</p>
<a class="header" href="print.html#trait定义共享的行为" id="trait定义共享的行为"><h2>trait：定义共享的行为</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch10-02-traits.md">ch10-02-traits.md</a>
<br>
commit 131859023a0a6be67168d36dcdc8e2aa43f806fd</p>
</blockquote>
<p>trait 允许我们进行另一种抽象：他们让我们可以抽象类型所通用的行为。<em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。在使用泛型类型参数的场景中，可以使用 <em>trait bounds</em> 在编译时指定泛型可以是任何实现了某个 trait 的类型，并由此在这个场景下拥有我们希望的功能。</p>
<blockquote>
<p>注意：<em>trait</em> 类似于其他语言中的常被称为 <strong>接口</strong>（<em>interfaces</em>）的功能，虽然有一些不同。</p>
</blockquote>
<a class="header" href="print.html#a定义-trait" id="a定义-trait"><h3>定义 trait</h3></a>
<p>一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p>
<p>例如，这里有多个存放了不同类型和属性文本的结构体：结构体 <code>NewsArticle</code> 用于存放发生于世界各地的新闻故事，而结构体 <code>Tweet</code> 最多只能存放 140 个字符的内容，以及像是否转推或是否是对推友的回复这样的元数据。</p>
<p>我们想要创建一个多媒体聚合库用来显示可能储存在 <code>NewsArticle</code> 或 <code>Tweet</code> 实例中的数据的总结。每一个结构体都需要的行为是他们是能够被总结的，这样的话就可以调用实例的 <code>summary</code> 方法来请求总结。示例 10-12 中展示了一个表现这个概念的 <code>Summarizable</code> trait 的定义：</p>
<p><span class="filename">文件名: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">示例 10-12：<code>Summarizable</code> trait 定义，它包含由 <code>summary</code> 方法提供的行为</span></p>
<p>使用 <code>trait</code> 关键字来声明一个 trait，后面是 trait 的名字，在这个例子中是 <code>Summarizable</code>。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summary(&amp;self) -&gt; String</code>。在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 <code>Summarizable</code> trait 的类型都拥有与这个签名的定义完全一致的 <code>summary</code> 方法。</p>
<p>trait 体中可以有多个方法，一行一个方法签名且都以分号结尾。</p>
<a class="header" href="print.html#a为类型实现-trait" id="a为类型实现-trait"><h3>为类型实现 trait</h3></a>
<p>现在我们定义了 <code>Summarizable</code> trait，接着就可以在多媒体聚合库中需要拥有这个行为的类型上实现它了。示例 10-13 中展示了 <code>NewsArticle</code> 结构体上 <code>Summarizable</code> trait 的一个实现，它使用标题、作者和创建的位置作为 <code>summary</code> 的返回值。对于 <code>Tweet</code> 结构体，我们选择将 <code>summary</code> 定义为用户名后跟推文的全部文本作为返回值，并假设推文内容已经被限制为 140 字符以内。</p>
<p><span class="filename">文件名: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Summarizable {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summarizable for NewsArticle {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summarizable for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 10-13：在 <code>NewsArticle</code> 和 <code>Tweet</code> 类型上实现 <code>Summarizable</code> trait</span></p>
<p>在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 <code>impl</code> 关键字之后，我们提供需要实现 trait 的名称，接着是 <code>for</code> 和需要实现 trait 的类型的名称。在 <code>impl</code> 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。</p>
<p>一旦实现了 trait，我们就可以用与 <code>NewsArticle</code> 和 <code>Tweet</code> 实例的非 trait 方法一样的方式调用 trait 方法了：</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>这会打印出 <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>。</p>
<p>注意因为示例 10-13 中我们在相同的 <code>lib.rs</code> 里定义了 <code>Summarizable</code> trait 和 <code>NewsArticle</code> 与 <code>Tweet</code> 类型，所以他们是位于同一作用域的。如果这个 <code>lib.rs</code> 是对应 <code>aggregator</code> crate 的，而别人想要利用我们 crate 的功能外加为其 <code>WeatherForecast</code> 结构体实现 <code>Summarizable</code> trait，在实现 <code>Summarizable</code> trait 之前他们首先就需要将其导入其作用域中，如示例 10-14 所示：</p>
<p><span class="filename">文件名: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Summarizable;

struct WeatherForecast {
    high_temp: f64,
    low_temp: f64,
    chance_of_precipitation: f64,
}

impl Summarizable for WeatherForecast {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;The high will be {}, and the low will be {}. The chance of
        precipitation is {}%.&quot;, self.high_temp, self.low_temp,
        self.chance_of_precipitation)
    }
}
</code></pre>
<p><span class="caption">示例 10-14：在另一个 crate 中将 <code>aggregator</code> crate 的 <code>Summarizable</code> trait 引入作用域</span></p>
<p>另外这段代码假设 <code>Summarizable</code> 是一个公有 trait，这是因为示例 10-12 中 <code>trait</code> 之前使用了 <code>pub</code> 关键字。</p>
<p>trait 实现的一个需要注意的限制是：只能在 trait 或对应类型位于我们 crate 本地的时候为其实现 trait。换句话说，不允许对外部类型实现外部 trait。例如，不能在 <code>Vec</code> 上实现 <code>Display</code> trait，因为 <code>Display</code> 和 <code>Vec</code> 都定义于标准库中。允许在像 <code>Tweet</code> 这样作为我们 <code>aggregator</code>crate 部分功能的自定义类型上实现标准库中的 trait <code>Display</code>。也允许在 <code>aggregator</code>crate 中为 <code>Vec</code> 实现 <code>Summarizable</code>，因为 <code>Summarizable</code> 定义于此。这个限制是我们称为 <strong>孤儿规则</strong>（<em>orphan rule</em>）的一部分，如果你感兴趣的可以在类型理论中找到它。简单来说，它被称为 orphan rule 是因为其父类型不存在。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，因而这两个实现会相互冲突：Rust 将无从得知应该使用哪一个。因为 Rust 强制执行 orphan rule，其他人编写的代码不会破坏你代码，反之亦是如此。</p>
<a class="header" href="print.html#a默认实现" id="a默认实现"><h3>默认实现</h3></a>
<p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p>
<p>示例 10-15 中展示了如何为 <code>Summarize</code> trait 的 <code>summary</code> 方法指定一个默认的字符串值，而不是像示例 10-12 中那样只是定义方法签名：</p>
<p><span class="filename">文件名: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 10-15：<code>Summarizable</code> trait 的定义，带有一个 <code>summary</code> 方法的默认实现</span></p>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是像示例 10-13 中那样定义一个自己的实现，则可以指定一个空的 <code>impl</code> 块：</p>
<pre><code class="language-rust ignore">impl Summarizable for NewsArticle {}
</code></pre>
<p>即便选择不再直接为 <code>NewsArticle</code> 定义 <code>summary</code> 方法了，因为 <code>summary</code> 方法有一个默认实现而且 <code>NewsArticle</code> 被指定为实现了 <code>Summarizable</code> trait，我们仍然可以对 <code>NewsArticle</code> 的实例调用 <code>summary</code> 方法：</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summary());
</code></pre>
<p>这段代码会打印 <code>New article available! (Read more...)</code>。</p>
<p>将 <code>Summarizable</code> trait 改变为拥有默认 <code>summary</code> 实现并不要求对示例 10-13 中 <code>Tweet</code> 和示例 10-14 中 <code>WeatherForecast</code> 的 <code>Summarizable</code> 实现做任何改变：重载一个默认实现的语法与实现没有默认实现的 trait 方法时完全一样的。</p>
<p>默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。通过这种方法，trait 可以实现很多有用的功能而只需实现一小部分特定内容。我们可以选择让<code>Summarizable</code> trait 也拥有一个要求实现的<code>author_summary</code> 方法，接着 <code>summary</code> 方法则提供默认实现并调用 <code>author_summary</code> 方法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn author_summary(&amp;self) -&gt; String;

    fn summary(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.author_summary())
    }
}
#}</code></pre></pre>
<p>为了使用这个版本的 <code>Summarizable</code>，只需在实现 trait 时定义 <code>author_summary</code> 即可：</p>
<pre><code class="language-rust ignore">impl Summarizable for Tweet {
    fn author_summary(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>一旦定义了 <code>author_summary</code>，我们就可以对 <code>Tweet</code> 结构体的实例调用 <code>summary</code> 了，而 <code>summary</code> 的默认实现会调用我们提供的 <code>author_summary</code> 定义。</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>这会打印出 <code>1 new tweet: (Read more from @horse_ebooks...)</code>。</p>
<p>注意在重载过的实现中调用默认实现是不可能的。</p>
<a class="header" href="print.html#trait-bounds" id="trait-bounds"><h3>Trait Bounds</h3></a>
<p>现在我们定义了 trait 并在类型上实现了这些 trait，也可以对泛型类型参数使用 trait。我们可以限制泛型不再适用于任何类型，编译器会确保其被限制为那些实现了特定 trait 的类型，由此泛型就会拥有我们希望其类型所拥有的功能。这被称为指定泛型的 <em>trait bounds</em>。</p>
<p>例如在示例 10-13 中为 <code>NewsArticle</code> 和 <code>Tweet</code> 类型实现了 <code>Summarizable</code> trait。我们可以定义一个函数 <code>notify</code> 来调用 <code>summary</code> 方法，它拥有一个泛型类型 <code>T</code> 的参数 <code>item</code>。为了能够在 <code>item</code> 上调用 <code>summary</code> 而不出现错误，我们可以在 <code>T</code> 上使用 trait bounds 来指定 <code>item</code> 必须是实现了 <code>Summarizable</code> trait 的类型：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summarizable&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summary());
}
</code></pre>
<p>trait bounds 连同泛型类型参数声明一同出现，位于尖括号中的冒号后面。由于 <code>T</code> 上的 trait bounds，我们可以传递任何 <code>NewsArticle</code> 或 <code>Tweet</code> 的实例来调用 <code>notify</code> 函数。示例 10-14 中使用我们 <code>aggregator</code> crate 的外部代码也可以传递一个 <code>WeatherForecast</code> 的实例来调用 <code>notify</code> 函数，因为 <code>WeatherForecast</code> 同样也实现了 <code>Summarizable</code>。使用任何其他类型，比如 <code>String</code> 或 <code>i32</code>，来调用 <code>notify</code> 的代码将不能编译，因为这些类型没有实现 <code>Summarizable</code>。</p>
<p>可以通过 <code>+</code> 来为泛型指定多个 trait bounds。如果我们需要能够在函数中使用 <code>T</code> 类型的显示格式的同时也能使用 <code>summary</code> 方法，则可以使用 trait bounds <code>T: Summarizable + Display</code>。这意味着 <code>T</code> 可以是任何实现了 <code>Summarizable</code> 和 <code>Display</code> 的类型。</p>
<p>对于拥有多个泛型类型参数的函数，每一个泛型都可以有其自己的 trait bounds。在函数名和参数列表之间的尖括号中指定很多的 trait bound 信息将是难以阅读的，所以有另外一个指定 trait bounds 的语法，它将其移动到函数签名后的 <code>where</code> 从句中。所以相比这样写：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>我们也可以使用 <code>where</code> 从句：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>这就显得不那么杂乱，同时也使这个函数看起来更像没有很多 trait bounds 的函数。这时函数名、参数列表和返回值类型都离得很近。</p>
<a class="header" href="print.html#a使用-trait-bounds-来修复-largest-函数" id="a使用-trait-bounds-来修复-largest-函数"><h3>使用 trait bounds 来修复 <code>largest</code> 函数</h3></a>
<p>所以任何想要对泛型使用 trait 定义的行为的时候，都需要在泛型参数类型上指定 trait bounds。现在我们就可以修复示例 10-5 中那个使用泛型类型参数的 <code>largest</code> 函数定义了！当我们将其放置不管的时候，它会出现这个错误：</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; largest {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>在 <code>largest</code> 函数体中我们想要使用大于运算符比较两个 <code>T</code> 类型的值。这个运算符被定义为标准库中 trait <code>std::cmp::PartialOrd</code> 的一个默认方法。所以为了能够使用大于运算符，需要在 <code>T</code> 的 trait bounds 中指定 <code>PartialOrd</code>，这样 <code>largest</code> 函数可以用于任何可以比较大小的类型的 slice。因为 <code>PartialOrd</code> 位于 prelude 中所以并不需要手动将其引入作用域。</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>但是如果编译代码的话，会出现不同的错误：</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut largest = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref largest` or `ref mut largest`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>错误的核心是 <code>cannot move out of type [T], a non-copy array</code>，对于非泛型版本的 <code>largest</code> 函数，我们只尝试了寻找最大的 <code>i32</code> 和 <code>char</code>。正如第四章讨论过的，像 <code>i32</code> 和 <code>char</code> 这样的类型是已知大小的并可以储存在栈上，所以他们实现了 <code>Copy</code> trait。当我们将 <code>largest</code> 函数改成使用泛型后，现在 <code>list</code> 参数的类型就有可能是没有实现 <code>Copy</code> trait 的，这意味着我们可能不能将 <code>list[0]</code> 的值移动到 <code>largest</code> 变量中。</p>
<p>如果只想对实现了 <code>Copy</code> 的类型调用这些代码，可以在 <code>T</code> 的 trait bounds 中增加 <code>Copy</code>！示例 10-16 中展示了一个可以编译的泛型版本的 <code>largest</code> 函数的完整代码，只要传递给 <code>largest</code> 的 slice 值的类型实现了 <code>PartialOrd</code> 和 <code>Copy</code> 这两个 trait，例如 <code>i32</code> 和 <code>char</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">示例 10-16：一个可以用于任何实现了 <code>PartialOrd</code> 和 <code>Copy</code> trait 的泛型的 <code>largest</code> 函数</span></p>
<p>如果并不希望限制 <code>largest</code> 函数只能用于实现了 <code>Copy</code> trait 的类型，我们可以在 <code>T</code> 的 trait bounds 中指定 <code>Clone</code> 而不是 <code>Copy</code>，并克隆 slice 的每一个值使得 <code>largest</code> 函数拥有其所有权。但是使用 <code>clone</code> 函数潜在意味着更多的堆分配，而且堆分配在涉及大量数据时可能会相当缓慢。另一种 <code>largest</code> 的实现方式是返回 slice 中一个 <code>T</code> 值的引用。如果我们将函数返回值从 <code>T</code> 改为 <code>&amp;T</code> 并改变函数体使其能够返回一个引用，我们将不需要任何 <code>Clone</code> 或 <code>Copy</code> 的 trait bounds 而且也不会有任何的堆分配。尝试自己实现这种替代解决方式吧！</p>
<a class="header" href="print.html#a使用-trait-bound-有条件的实现方法" id="a使用-trait-bound-有条件的实现方法"><h3>使用 trait bound 有条件的实现方法</h3></a>
<p>通过使用带有 trait bound 的泛型 <code>impl</code> 块，可以有条件的只为实现了特定 trait 的类型实现方法。例如，示例 10-17 中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有 <code>Pair&lt;T&gt;</code> 内部的 <code>T</code> 类型实现了 <code>PartialOrd</code> trait 来允许比较和 <code>Display</code> trait 来启用打印，才会实现 <code>cmp_display</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 10-17：根据 trait bound 在泛型上有条件的实现方法</span></p>
<p>也可以对任何实现了特定 trait 的类型有条件的实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>，他们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>因为标准库有了这些 blanket implementation，我们可以对任何实现了 <code>Display</code> trait 的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>blanket implementation 会出现在 trait 文档的 “Implementers” 部分。</p>
<p>trait 和 trait bound 让我们使用泛型类型参数来减少重复，并仍然能够向编译器明确指定泛型类型需要拥有哪些行为。因为我们向编译器提供了 trait bound 信息，它就可以检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们尝试调用一个类型并没有实现的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复错误。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了，这样相比其他那些不愿放弃泛型灵活性的语言有更好的性能。</p>
<p>这里还有一种泛型，我们一直在使用它甚至都没有察觉它的存在，这就是 <strong>生命周期</strong>（<em>lifetimes</em>）。不同于其他泛型帮助我们确保类型拥有期望的行为，生命周期则有助于确保引用在我们需要他们的时候一直有效。让我们学习生命周期是如何做到这些的。</p>
<a class="header" href="print.html#a生命周期与引用有效性" id="a生命周期与引用有效性"><h2>生命周期与引用有效性</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch10-03-lifetime-syntax.md">ch10-03-lifetime-syntax.md</a>
<br>
commit fa0e4403f8350287b034c5b64af752f647ebb5a2</p>
</blockquote>
<p>当在第四章讨论引用时，我们遗漏了一个重要的细节：Rust 中的每一个引用都有其 <strong>生命周期</strong>（<em>lifetime</em>），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p>
<p>好吧，这有点不太寻常，而且也不同于其他语言中使用的工具。生命周期，从某种意义上说，是 Rust 最与众不同的功能。</p>
<p>生命周期是一个很广泛的话题，本章不可能涉及到它全部的内容，所以这里我们会讲到一些通常你可能会遇到的生命周期语法以便你熟悉这个概念。第十九章会包含生命周期所有功能的更高级的内容。</p>
<a class="header" href="print.html#a生命周期避免了悬垂引用" id="a生命周期避免了悬垂引用"><h3>生命周期避免了悬垂引用</h3></a>
<p>生命周期的主要目标是避免悬垂引用，它会导致程序引用了非预期引用的数据。考虑一下示例 10-18 中的程序，它有一个外部作用域和一个内部作用域，外部作用域声明了一个没有初值的变量 <code>r</code>，而内部作用域声明了一个初值为 5 的变量<code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 的值设置为一个 <code>x</code> 的引用。接着在内部作用域结束后，尝试打印出 <code>r</code> 的值：</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">示例 10-18：尝试使用离开作用域的值的引用</span></p>
<blockquote>
<a class="header" href="print.html#a未初始化变量不能被使用" id="a未初始化变量不能被使用"><h4>未初始化变量不能被使用</h4></a>
<p>接下来的一些例子中声明了没有初始值的变量，以便这些变量存在于外部作用域。这看起来好像和 Rust 不允许存在空值相冲突。然而这是可以的，如果我们尝试在给它一个值之前使用这个变量，会出现一个编译时错误。请自行尝试！</p>
</blockquote>
<p>当编译这段代码时会得到一个错误：</p>
<pre><code class="language-text">error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>变量 <code>x</code> 并没有 “存在的足够久”。为什么呢？好吧，<code>x</code> 在到达第 7 行的大括号的结束时就离开了作用域，这也是内部作用域的结尾。不过 <code>r</code> 在外部作用域也是有效的；作用域越大我们就说它 “存在的越久”。如果 Rust 允许这段代码工作，<code>r</code> 将会引用在 <code>x</code> 离开作用域时被释放的内存，这时尝试对 <code>r</code> 做任何操作都会不能正常工作。那么 Rust 是如何决定这段代码是不被允许的呢？</p>
<a class="header" href="print.html#a借用检查器" id="a借用检查器"><h4>借用检查器</h4></a>
<p>编译器的这一部分叫做 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。示例 10-19 展示了与示例 10-18 相同的例子不过带有变量生命周期的注释：</p>
<pre><code class="language-rust ignore">{
    let r;                // -------+-- 'a
                          //        |
    {                     //        |
        let x = 5;        // -+-----+-- 'b
        r = &amp;x;           //  |     |
    }                     // -+     |
                          //        |
    println!(&quot;r: {}&quot;, r); //        |
}                         // -------+
</code></pre>
<p><span class="caption">示例 10-19：<code>r</code> 和 <code>x</code> 的生命周期注解，分别叫做 <code>'a</code> 和 <code>'b</code></span></p>
<!-- Just checking I'm reading this right: the inside block is the b lifetime,
correct? I want to leave a note for production, make sure we can make that
clear -->
<!-- Yes, the inside block for the `'b` lifetime starts with the `let x = 5;`
line and ends with the first closing curly brace on the 7th line. Do you think
the text art comments work or should we make an SVG diagram that has nicer
looking arrows and labels? /Carol -->
<p>我们将 <code>r</code> 的生命周期标记为 <code>'a</code> 并将 <code>x</code> 的生命周期标记为 <code>'b</code>。如你所见，内部的 <code>'b</code> 块要比外部的生命周期 <code>'a</code> 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 <code>r</code> 拥有生命周期 <code>'a</code>，不过它引用了一个拥有生命周期 <code>'b</code> 的对象。程序被拒绝编译，因为生命周期 <code>'b</code> 比生命周期 <code>'a</code> 要小：被引用的对象比它的引用者存在的时间更短。</p>
<p>让我们看看示例 10-20 中这个并没有产生悬垂引用且可以正确编译的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // -----+-- 'b
                          //      |
    let r = &amp;x;           // --+--+-- 'a
                          //   |  |
    println!(&quot;r: {}&quot;, r); //   |  |
                          // --+  |
}                         // -----+
#}</code></pre></pre>
<p><span class="caption">示例 10-20：一个有效的引用，因为数据比引用有着更长的生命周期</span></p>
<p>这里 <code>x</code> 拥有生命周期 <code>'b</code>，比 <code>'a</code> 要大。这就意味着 <code>r</code> 可以引用 <code>x</code>：Rust 知道 <code>r</code> 中的引用在 <code>x</code> 有效的时候也总是有效的。</p>
<p>现在我们已经在一个具体的例子中展示了引用的生命周期位于何处，并讨论了 Rust 如何分析生命周期来保证引用总是有效的，接下来让我们聊聊在函数的上下文中参数和返回值的泛型生命周期。</p>
<a class="header" href="print.html#a函数中的泛型生命周期" id="a函数中的泛型生命周期"><h3>函数中的泛型生命周期</h3></a>
<p>让我们来编写一个返回两个字符串 slice 中较长者的函数。我们希望能够通过传递两个字符串 slice 来调用这个函数，并希望返回一个字符串 slice。一旦我们实现了 <code>longest</code> 函数，示例 10-21 中的代码应该会打印出 <code>The longest string is abcd</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">示例 10-21：<code>main</code> 函数调用 <code>longest</code> 函数来寻找两个字符串 slice 中较长的一个</span></p>
<p>注意函数期望获取字符串 slice（如第四章所讲到的这是引用）因为我们并不希望<code>longest</code> 函数获取其参数的所有权。我们希望函数能够接受 <code>String</code> 的 slice（也就是变量 <code>string1</code> 的类型）以及字符串字面值（也就是变量 <code>string2</code> 包含的值）。</p>
<!-- why is `a` a slice and `b` a literal? You mean "a" from the string "abcd"? -->
<!-- I've changed the variable names to remove ambiguity between the variable
name `a` and the "a" from the string "abcd". `string1` is not a slice, it's a
`String`, but we're going to pass a slice that refers to that `String` to the
`longest` function (`string1.as_str()` creates a slice that references the
`String` stored in `string1`). We chose to have `string2` be a literal since
the reader might have code with both `String`s and string literals, and the way
most readers first get into problems with lifetimes is involving string slices,
so we wanted to demonstrate the flexibility of taking string slices as
arguments but the issues you might run into because string slices are
references.
All of the `String`/string slice/string literal concepts here are covered
thoroughly in Chapter 4, which is why we put two back references here (above
and below). If these topics are confusing you in this context, I'd be
interested to know if rereading Chapter 4 clears up that confusion.
/Carol -->
<p>参考之前第四章中的 “字符串 slice 作为参数” 部分中更多关于为什么上面例子中的参数正符合我们期望的讨论。</p>
<p>如果尝试像示例 10-22 中那样实现 <code>longest</code> 函数，它并不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">示例 10-22：一个 <code>longest</code> 函数的实现，它返回两个字符串 slice 中较长者，现在还不能编译</span></p>
<p>将会出现如下有关生命周期的错误：</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   |
1  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>提示文本告诉我们返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code>。事实上我们也不知道，因为函数体中 <code>if</code> 块返回一个 <code>x</code> 的引用而 <code>else</code> 块返回一个 <code>y</code> 的引用。</p>
<p>虽然我们定义了这个函数，但是并不知道传递给函数的具体值，所以也不知道到底是 <code>if</code> 还是 <code>else</code> 会被执行。我们也不知道传入的引用的具体生命周期，所以也就不能像示例 10-19 和 10-20 那样通过观察作用域来确定返回的引用是否总是有效。借用检查器自身同样也无法确定，因为它不知道 <code>x</code> 和 <code>y</code> 的生命周期是如何与返回值的生命周期相关联的。接下来我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。</p>
<a class="header" href="print.html#a生命周期注解语法" id="a生命周期注解语法"><h3>生命周期注解语法</h3></a>
<p>生命周期注解并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期注解所做的就是将多个引用的生命周期联系起来。</p>
<p>生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（<code>'</code>）开头。生命周期参数的名称通常全是小写，而且类似于泛型类型，其名称通常非常短。<code>'a</code> 是大多数人默认使用的名称。生命周期参数注解位于引用的 <code>&amp;</code> 之后，并有一个空格来将引用类型与生命周期注解分隔开。</p>
<p>这里有一些例子：我们有一个没有生命周期参数的 <code>i32</code> 的引用，一个有叫做 <code>'a</code> 的生命周期参数的 <code>i32</code> 的引用，和一个生命周期也是 <code>'a</code> 的 <code>i32</code> 的可变引用：</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>单个的生命周期注解本身没有多少意义：生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系。如果函数有一个生命周期 <code>'a</code> 的 <code>i32</code> 的引用的参数 <code>first</code>，还有另一个同样是生命周期 <code>'a</code> 的 <code>i32</code> 的引用的参数 <code>second</code>，这两个生命周期注解有相同的名称意味着 <code>first</code> 和 <code>second</code> 必须与这相同的泛型生命周期存在得一样久。</p>
<a class="header" href="print.html#a函数签名中的生命周期注解" id="a函数签名中的生命周期注解"><h3>函数签名中的生命周期注解</h3></a>
<p>来看看我们编写的 <code>longest</code> 函数的上下文中的生命周期。就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中。这里我们想要告诉 Rust 关于参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期，就像示例 10-23 中在每个引用中都加上了 <code>'a</code> 那样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 10-23：<code>longest</code> 函数定义指定了签名中所有的引用必须有相同的生命周期 <code>'a</code></span></p>
<p>这段代码能够编译并会产生我们希望得到的示例 10-21 中的 <code>main</code> 函数的结果。</p>
<p>现在函数签名表明对于某些生命周期 <code>'a</code>，函数会获取两个参数，他们都是与生命周期 <code>'a</code> 存在的一样长的字符串 slice。函数会返回一个同样也与生命周期 <code>'a</code> 存在的一样长的字符串 slice。这就是我们告诉 Rust 需要其保证的契约。</p>
<p>通过在函数签名中指定生命周期参数，我们并没有改变任何传入后返回的值的生命周期，而是指出任何不遵守这个协议的传入值都将被借用检查器拒绝。这个函数并不知道（或需要知道）<code>x</code> 和 <code>y</code> 具体会存在多久，而只需要知道有某个可以被 <code>'a</code> 替代的作用域将会满足这个签名。</p>
<p>当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。这是因为 Rust 能够分析函数中代码而不需要任何协助，不过当函数引用或被函数之外的代码引用时，参数或返回值的生命周期可能在每次函数被调用时都不同。这可能会产生惊人的消耗并且对于 Rust 来说通常是不可能分析的。在这种情况下，我们需要自己标注生命周期。</p>
<p>当具体的引用被传递给 <code>longest</code> 时，被 <code>'a</code> 所替代的具体生命周期是 <code>x</code> 的作用域与 <code>y</code> 的作用域相重叠的那一部分。因为作用域总是嵌套的，所以换一种说法就是泛型生命周期 <code>'a</code> 的具体生命周期等同于 <code>x</code> 和 <code>y</code> 的生命周期中较小的那一个。因为我们用相同的生命周期参数 <code>'a</code> 标注了返回的引用值，所以返回的引用值就能保证在 <code>x</code> 和 <code>y</code> 中较短的那个生命周期结束之前保持有效。</p>
<p>让我们看看如何通过传递拥有不同具体生命周期的引用来限制 <code>longest</code> 函数的使用。示例 10-24 是一个应该在任何编程语言中都很直观的例子：<code>string1</code> 直到外部作用域结束都是有效的，<code>string2</code> 则在内部作用域中是有效的，而 <code>result</code> 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 <code>The longest string is long string is long</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">示例 10-24：通过拥有不同的具体生命周期的 <code>String</code> 值调用 <code>longest</code> 函数</span></p>
<p>接下来，让我们尝试一个 <code>result</code> 的引用的生命周期肯定比两个参数的要短的例子。将 <code>result</code> 变量的声明从内部作用域中移动出来，但是将 <code>result</code> 和 <code>string2</code> 变量的赋值语句一同留在内部作用域里。接下来，我们将使用 <code>result</code> 的 <code>println!</code> 移动到内部作用域之外，就在其结束之后。注意示例 10-25 中的代码不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">示例 10-25：在 <code>string2</code> 离开作用域之后使用 <code>result</code> 的尝试不能编译</span></p>
<p>如果尝试编译会出现如下错误：</p>
<pre><code class="language-text">error: `string2` does not live long enough
   |
6  |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!(&quot;The longest string is {}&quot;, result);
9  | }
   | - borrowed value needs to live until here
</code></pre>
<p>错误表明为了保证 <code>println!</code> 中的 <code>result</code> 是有效的，<code>string2</code> 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（<code>longest</code>）函数的参数和返回值都使用了相同的生命周期参数 <code>'a</code>。</p>
<p>以人类的理解 <code>string1</code> 更长，因此 <code>result</code> 会包含指向 <code>string1</code> 的引用。因为 <code>string1</code> 尚未离开作用域，对于 <code>println!</code> 来说 <code>string1</code> 的引用仍然是有效的。然而，我们通过生命周期参数告诉 Rust 的是 <code>longest</code> 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许示例 10-25 中的代码，因为它可能会存在无效的引用。</p>
<p>请尝试更多采用不同的值和不同生命周期的引用作为 <code>longest</code> 函数的参数和返回值的实验。并在开始编译前猜想你的实验能否通过借用检查器，接着编译一下看看你的理解是否正确！</p>
<a class="header" href="print.html#a深入理解生命周期" id="a深入理解生命周期"><h3>深入理解生命周期</h3></a>
<p>指定生命周期参数的正确方式依赖函数具体的功能。例如，如果将 <code>longest</code> 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 <code>y</code> 指定一个生命周期。如下代码将能够编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>在这个例子中，我们为参数 <code>x</code> 和返回值指定了生命周期参数 <code>'a</code>，不过没有为参数 <code>y</code> 指定，因为 <code>y</code> 的生命周期与参数 <code>x</code> 和返回值的生命周期没有任何关系。</p>
<p>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 <strong>没有</strong> 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。尝试考虑这个并不能编译的 <code>longest</code> 函数实现：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>即便我们为返回值指定了生命周期参数 <code>'a</code>，这个实现却编译失败了，因为返回值的生命周期与参数完全没有关联。这里是会出现的错误信息：</p>
<pre><code class="language-text">error: `result` does not live long enough
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |                                             ^
</code></pre>
<p>出现的问题是 <code>result</code> 在 <code>longest</code> 函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个 <code>result</code> 的引用。无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。在这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。</p>
<p>从结果上看，生命周期语法是关于如何联系函数不同参数和返回值的生命周期的。一旦他们形成了某种联系，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p>
<a class="header" href="print.html#a结构体定义中的生命周期注解" id="a结构体定义中的生命周期注解"><h3>结构体定义中的生命周期注解</h3></a>
<p>目前为止，我们只定义过有所有权类型的结构体。也可以定义存放引用的结构体，不过需要为结构体定义中的每一个引用添加生命周期注解。示例 10-26 中有一个存放了一个字符串 slice 的结构体 <code>ImportantExcerpt</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p><span class="caption">示例 10-26：一个存放引用的结构体，所以其定义需要生命周期注解</span></p>
<p>这个结构体有一个字段，<code>part</code>，它存放了一个字符串 slice，这是一个引用。类似于泛型参数类型，必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。</p>
<p>这里的 <code>main</code> 函数创建了一个 <code>ImportantExcerpt</code> 的实例，它存放了变量 <code>novel</code> 所拥有的 <code>String</code> 的第一个句子的引用。</p>
<a class="header" href="print.html#a生命周期省略lifetime-elision" id="a生命周期省略lifetime-elision"><h3>生命周期省略（Lifetime Elision）</h3></a>
<p>在这一部分，我们知道了每一个引用都有一个生命周期，而且需要为使用了引用的函数或结构体指定生命周期。然而，第四章的 “字符串 slice” 部分有一个函数，我们在示例 10-27 中再次展示出来，它没有生命周期注解却能成功编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">示例 10-27：第四章定义了一个没有使用生命周期注解的函数，即便其参数和返回值都是引用</span></p>
<p>这个函数没有生命周期注解却能编译是由于一些历史原因：在早期 pre-1.0 版本的 Rust 中，这的确是不能编译的。每一个引用都必须有明确的生命周期。那时的函数签名将会写成这样：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>在编写了很多 Rust 代码后，Rust 团队发现在特定情况下 Rust 程序员们总是重复地编写一模一样的生命周期注解。这些场景是可预测的并且遵循几个明确的模式。接着 Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。</p>
<p>这里我们提到一些 Rust 的历史是因为更多的明确的模式被合并和添加到编译器中是完全可能的。未来只会需要更少的生命周期注解。</p>
<p>被编码进 Rust 引用分析的模式被称为 <strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p>
<p>省略规则并不提供完整的推断：如果 Rust 在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，它不会猜测剩余引用的生命周期应该是什么。在这种情况，编译器会给出一个错误，这可以通过增加对应引用之间相联系的生命周期注解来解决。</p>
<p>首先，介绍一些定义：函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>现在介绍编译器用于判断引用何时不需要明确生命周期注解的规则。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。</p>
<ol>
<li>
<p>每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，依此类推。</p>
</li>
<li>
<p>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
</li>
<li>
<p>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。这使得方法编写起来更简洁。</p>
</li>
</ol>
<p>假设我们自己就是编译器并来计算示例 10-25 <code>first_word</code> 函数的签名中的引用的生命周期。开始时签名中的引用并没有关联任何生命周期：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>接着我们（作为编译器）应用第一条规则，也就是每个引用参数都有其自己的生命周期。我们像往常一样称之为 <code>'a</code>，所以现在签名看起来像这样：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p>
<p>让我们再看看另一个例子，这次我们从示例 10-22 中没有生命周期参数的 <code>longest</code> 函数开始：</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>再次假设我们自己就是编译器并应用第一条规则：每个引用参数都有其自己的生命周期。这次有两个参数，所以就有两个（不同的）生命周期：</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>再来应用第二条规则，它并不适用因为存在多于一个输入生命周期。再来看第三条规则，它同样也不适用因为没有 <code>self</code> 参数。然后我们就没有更多规则了，不过还没有计算出返回值的类型的生命周期。这就是为什么在编译示例 10-22 的代码时会出现错误的原因：编译器使用所有已知的生命周期省略规则，不过仍不能计算出签名中所有引用的生命周期。</p>
<p>因为第三条规则真正能够适用的就只有方法签名，现在就让我们看看那种情况中的生命周期，并看看为什么这条规则意味着我们经常不需要在方法签名中标注生命周期。</p>
<a class="header" href="print.html#a方法定义中的生命周期注解" id="a方法定义中的生命周期注解"><h3>方法定义中的生命周期注解</h3></a>
<!-- Is this different to the reference lifetime annotations, or just a
finalized explanation? -->
<!-- This is about lifetimes on references in method signatures, which is where
the 3rd lifetime elision rule kicks in. It can also be confusing where lifetime
parameters need to be declared and used since the lifetime parameters could go
with the struct's fields or with references passed into or returned from
methods. /Carol -->
<p>当为带有生命周期的结构体实现方法时，其语法依然类似示例 10-11 中展示的泛型类型参数的语法：声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段或方法参数和返回值相关。</p>
<p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p>
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。让我们看看一些使用示例 10-26 中定义的结构体 <code>ImportantExcerpt</code> 的例子。</p>
<p>首先，这里有一个方法 <code>level</code>。其唯一的参数是 <code>self</code> 的引用，而且返回值只是一个 <code>i32</code>，并不引用任何值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<p>这里是一个适用于第三条生命周期省略规则的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<p>这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 <code>&amp;self</code> 和 <code>announcement</code> 他们各自的生命周期。接着，因为其中一个参数是 <code>&amp;self</code>，返回值类型被赋予了 <code>&amp;self</code> 的生命周期，这样所有的生命周期都被计算出来了。</p>
<a class="header" href="print.html#a静态生命周期" id="a静态生命周期"><h3>静态生命周期</h3></a>
<p>这里有 <strong>一种</strong> 特殊的生命周期值得讨论：<code>'static</code>。<code>'static</code> 生命周期存活于整个程序期间。所有的字符串字面值都拥有 <code>'static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 <code>'static</code> 的。</p>
<!-- How would you add a static lifetime (below)? -->
<!-- Just like you'd specify any lifetime, see above where it shows `&'static str`. /Carol -->
<p>你可能在错误信息的帮助文本中见过使用 <code>'static</code> 生命周期的建议，不过将引用指定为 <code>'static</code> 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效（或者哪怕你希望它一直有效，如果可能的话）。大部分情况，代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配，请解决这些问题而不是指定一个 <code>'static</code> 的生命周期。</p>
<a class="header" href="print.html#a结合泛型类型参数trait-bounds-和生命周期" id="a结合泛型类型参数trait-bounds-和生命周期"><h3>结合泛型类型参数、trait bounds 和生命周期</h3></a>
<p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>这个是示例 10-23 中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann</code> 的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>
<a class="header" href="print.html#a总结-9" id="a总结-9"><h2>总结</h2></a>
<p>这一章介绍了很多的内容！现在你知道了泛型类型参数、trait 和 trait bounds 以及泛型生命周期类型，你已经准备好编写既不重复又能适用于多种场景的代码了。泛型类型参数意味着代码可以适用于不同的类型。trait 和 trait bounds 保证了即使类型是泛型的，这些类型也会拥有所需要的行为。由生命周期注解所指定的引用生命周期之间的关系保证了这些灵活多变的代码不会出现悬垂引用。而所有的这一切发生在编译时所以不会影响运行时效率！</p>
<p>你可能不会相信，这个领域还有更多需要学习的内容：第十七章会讨论 trait 对象，这是另一种使用 trait 的方式。第十九章会涉及到生命周期注解更复杂的场景。第二十章讲解一些高级的类型系统功能。不过接下来，让我们聊聊如何在 Rust 中编写测试，来确保代码的所有功能能像我们希望的那样工作！</p>
<a class="header" href="print.html#a测试" id="a测试"><h1>测试</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch11-00-testing.md">ch11-00-testing.md</a>
<br>
commit 4464eab0892297b83db7134b7ace12762a89b389</p>
</blockquote>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
<p>软件测试是证明 bug 存在的有效方法，而证明其不存在时则显得令人绝望的不足。</p>
<p>Edsger W. Dijkstra，【谦卑的程序员】（1972）</p>
</blockquote>
<p>这并不意味着我们不该尽可能测试软件！程序的正确性意味着代码如我们期望的那样运行。Rust 是一个相当注重正确性的编程语言，不过正确性是一个难以证明的复杂主题。Rust 的类型系统在此问题上下了很大的功夫，不过它不可能捕获所有种类的错误。为此，Rust 也在语言本身包含了编写软件测试的支持。</p>
<p>例如，我们可以编写一个叫做 <code>add_two</code> 的将传递给它的值加二的函数。它的签名有一个整型参数并返回一个整型值。当实现和编译这个函数时，Rust 会进行所有目前我们已经见过的类型检查和借用检查，例如，这些检查会确保我们不会传递 <code>String</code> 或无效的引用给这个函数。Rust 所 <strong>不能</strong> 检查的是这个函数是否会准确的完成我们期望的工作：返回参数加二后的值，而不是比如说参数加 10 或减 50 的值！这也就是测试出场的地方。</p>
<p>我们可以编写测试断言，比如说，当传递 <code>3</code> 给 <code>add_two</code> 函数时，返回值是 <code>5</code>。无论何时对代码进行修改，都可以运行测试来确保任何现存的正确行为没有被改变。</p>
<p>测试是一项复杂的技能：虽然不能在一个章节的篇幅中介绍如何编写好的测试的每个细节，但我们还是会讨论 Rust 测试功能的机制。我们会讲到编写测试时会用到的注解和宏，运行测试的默认行为和选项，以及如何将测试组织成单元测试和集成测试。</p>
<a class="header" href="print.html#a如何编写测试" id="a如何编写测试"><h2>如何编写测试</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch11-01-writing-tests.md">ch11-01-writing-tests.md</a>
<br>
commit 4464eab0892297b83db7134b7ace12762a89b389</p>
</blockquote>
<p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ol>
<li>设置任何所需的数据或状态</li>
<li>运行需要测试的代码</li>
<li>断言其结果是我们所期望的</li>
</ol>
<p>让我们看看 Rust 提供的专门用来编写测试的功能：<code>test</code> 属性、一些宏和 <code>should_panic</code> 属性。</p>
<a class="header" href="print.html#a测试函数剖析" id="a测试函数剖析"><h3>测试函数剖析</h3></a>
<p>作为最简单例子，Rust 中的测试就是一个带有 <code>test</code> 属性注解的函数。属性（attribute）是关于 Rust 代码片段的元数据；第五章中结构体中用到的 <code>derive</code> 属性就是一个例子。为了将一个函数变成测试函数，需要在 <code>fn</code> 行之前加上 <code>#[test]</code>。当使用 <code>cargo test</code> 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 <code>test</code> 属性的函数，并报告每一个测试是通过还是失败。</p>
<p>第七章当使用 Cargo 新建一个库项目时，它会自动为我们生成一个测试模块和一个测试函数。这有助于我们开始编写测试，因为这样每次开始新项目时不必去查找测试函数的具体结构和语法了。当然你也可以额外增加任意多的测试函数以及测试模块！</p>
<p>为了理清测试是如何工作的，我们将通过观察那些自动生成的测试模版——尽管它们实际上没有测试任何代码。接着，我们会写一些真正的测试，调用我们编写的代码并断言他们的行为的正确性。</p>
<p>让我们创建一个新的库项目 <code>adder</code>：</p>
<pre><code class="language-text">$ cargo new adder
     Created library `adder` project
$ cd adder
</code></pre>
<p>adder 库中 <code>src/lib.rs</code> 的内容应该看起来如示例 11-1 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-1：由 <code>cargo new</code> 自动生成的测试模块和函数</span></p>
<p>现在让我们暂时忽略 <code>tests</code> 模块和 <code>#[cfg(test)]</code> 注解，并只关注函数来了解其如何工作。注意 <code>fn</code> 行之前的 <code>#[test]</code>：这个属性表明这是一个测试函数，这样测试执行者就知道将其作为测试处理。因为也可以在 <code>tests</code> 模块中拥有非测试的函数来帮助我们建立通用场景或进行常见操作，所以需要使用 <code>#[test]</code> 属性标明哪些函数是测试。</p>
<p>函数体通过使用 <code>assert_eq!</code> 宏来断言 2 加 2 等于 4。一个典型的测试的格式，就是像这个例子中的断言一样。接下来运行就可以看到测试通过。</p>
<p><code>cargo test</code> 命令会运行项目中所有的测试，如示例 11-2 所示：</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">示例 11-2：运行自动生成测试的输出</span></p>
<p>Cargo 编译并运行了测试。在 <code>Compiling</code>、<code>Finished</code> 和 <code>Running</code> 这几行之后，可以看到 <code>running 1 test</code> 这一行。下一行显示了生成的测试函数的名称，它是 <code>it_works</code>，以及测试的运行结果，<code>ok</code>。接着可以看到全体测试运行结果的摘要：<code>test result: ok.</code> 意味着所有测试都通过了。<code>1 passed; 0 failed</code> 表示通过或失败的测试数量。</p>
<p>因为之前我们并没有将任何测试标记为忽略，所以摘要中会显示 <code>0 ignored</code>。我们也没有过滤需要运行的测试，所以摘要中会显示<code>0 filtered out</code>。在下一部分 “控制测试如何运行” 会讨论忽略和过滤测试。</p>
<p><code>0 measured</code> 统计是针对性能测试的。性能测试（benchmark tests）在编写本书时，仍只能用于 Rust 开发版（nightly Rust）。请查看第一章来了解更多 Rust 开发版的信息。</p>
<p>测试输出中以 <code>Doc-tests adder</code> 开头的这一部分是所有文档测试的结果。我们现在并没有任何文档测试，不过 Rust 会编译任何在 API 文档中的代码示例。这个功能帮助我们使文档和代码保持同步！在第十四章的 “文档注释” 部分会讲到如何编写文档测试。现在我们将忽略 <code>Doc-tests</code> 部分的输出。</p>
<p>让我们改变测试的名称并看看这如何改变测试的输出。给 <code>it_works</code> 函数起个不同的名字，比如 <code>exploration</code>，像这样：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>并再次运行 <code>cargo test</code>。现在输出中将出现 <code>exploration</code> 而不是 <code>it_works</code>：</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>让我们增加另一个测试，不过这一次是一个会失败的测试！当测试函数中出现 panic 时测试就失败了。每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败。第九章讲到了最简单的造成 panic 的方法：调用 <code>panic!</code> 宏。写入新测试 <code>another</code> 后， <code>src/lib.rs</code> 现在看起来如示例 11-3 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-3：增加第二个因调用了 <code>panic!</code> 而失败的测试</span></p>
<p>再次 <code>cargo test</code> 运行测试。输出应该看起来像示例 11-4，它表明 <code>exploration</code> 测试通过了而 <code>another</code> 失败了：</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed
</code></pre>
<p><span class="caption">示例 11-4：一个测试通过和一个测试失败的测试结果</span></p>
<p><code>test tests::another</code> 这一行是 <code>FAILED</code> 而不是 <code>ok</code> 了。在单独测试结果和摘要之间多了两个新的部分：第一个部分显示了测试失败的详细原因。在这个例子中，<code>another</code> 因为在<em>src/lib.rs</em> 的第 10 行 <code>panicked at 'Make this test fail'</code> 而失败。下一部分列出了所有失败的测试，这在有很多测试和很多失败测试的详细输出时很有帮助。我们可以通过使用失败测试的名称来只运行这个测试，以便调试；下一部分 “控制测试如何运行” 会讲到更多运行测试的方法。</p>
<p>最后是摘要行：总体上讲，测试结果是 <code>FAILED</code>。有一个测试通过和一个测试失败。</p>
<p>现在我们见过不同场景中测试结果是什么样子的了，再来看看除 <code>panic!</code> 之外的一些在测试中有帮助的宏吧。</p>
<a class="header" href="print.html#a使用-assert-宏来检查结果" id="a使用-assert-宏来检查结果"><h3>使用 <code>assert!</code> 宏来检查结果</h3></a>
<p><code>assert!</code> 宏由标准库提供，在希望确保测试中一些条件为 <code>true</code> 时非常有用。需要向 <code>assert!</code> 宏提供一个求值为布尔值的参数。如果值是 <code>true</code>，<code>assert!</code> 什么也不做，同时测试会通过。如果值为 <code>false</code>，<code>assert!</code> 调用 <code>panic!</code> 宏，这会导致测试失败。<code>assert!</code> 宏帮助我们检查代码是否以期望的方式运行。</p>
<p>回忆一下第五章中，示例 5-15 中有一个 <code>Rectangle</code> 结构体和一个 <code>can_hold</code> 方法，在示例 11-5 中再次使用他们。将他们放进 <em>src/lib.rs</em> 并使用 <code>assert!</code> 宏编写一些测试。</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-5：第五章中 <code>Rectangle</code> 结构体和其 <code>can_hold</code> 方法</span></p>
<p><code>can_hold</code> 方法返回一个布尔值，这意味着它完美符合 <code>assert!</code> 宏的使用场景。在示例 11-6 中，让我们编写一个 <code>can_hold</code> 方法的测试来作为练习，这里创建一个长为 8 宽为 7 的 <code>Rectangle</code> 实例，并假设它可以放得下另一个长为 5 宽为 1 的 <code>Rectangle</code> 实例：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-6：一个 <code>can_hold</code> 的测试，检查一个较大的矩形确实能放得下一个较小的矩形</span></p>
<p>注意在 <code>tests</code> 模块中新增加了一行：<code>use super::*;</code>。<code>tests</code> 是一个普通的模块，它遵循第七章 “私有性规则” 部分介绍的可见性规则。因为这是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域中。这里选择使用全局导入，以便在 <code>tests</code> 模块中使用所有在外部模块定义的内容。</p>
<p>我们将测试命名为 <code>larger_can_hold_smaller</code>，并创建所需的两个 <code>Rectangle</code> 实例。接着调用 <code>assert!</code> 宏并传递 <code>larger.can_hold(&amp;smaller)</code> 调用的结果作为参数。这个表达式预期会返回 <code>true</code>，所以测试应该通过。让我们拭目以待！</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>它确实通过了！再来增加另一个测试，这一回断言一个更小的矩形不能放下一个更大的矩形：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
#}</code></pre></pre>
<p>因为这里 <code>can_hold</code> 函数的正确结果是 <code>false</code> ，我们需要将这个结果取反后传递给 <code>assert!</code> 宏。因此 <code>can_hold</code> 返回 <code>false</code> 时测试就会通过：</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>两个通过的测试！现在让我们看看如果引入一个 bug 的话测试结果会发生什么。将 <code>can_hold</code> 方法中比较长度时本应使用大于号的地方改成小于号：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# pub struct Rectangle {
#     length: u32,
#     width: u32,
# }
// --snip--

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p>现在运行测试会产生：</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>我们的测试捕获了 bug！因为 <code>larger.length</code> 是 8 而 <code>smaller.length</code> 是 5，<code>can_hold</code> 中的长度比较现在因为 8 不小于 5 而返回 <code>false</code>。</p>
<a class="header" href="print.html#a使用-assert_eq-和-assert_ne-宏来测试相等" id="a使用-assert_eq-和-assert_ne-宏来测试相等"><h3>使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏来测试相等</h3></a>
<p>测试功能的一个常用方法是将需要测试代码的值与期望值做比较，并检查是否相等。可以通过向 <code>assert!</code> 宏传递一个使用 <code>==</code> 运算符的表达式来做到。不过这个操作实在是太常见了，以至于标准库提供了一对宏来更方便的处理这些操作：<code>assert_eq!</code> 和 <code>assert_ne!</code>。这两个宏分别比较两个值是相等还是不相等。当断言失败时他们也会打印出这两个值具体是什么，以便于观察测试 <strong>为什么</strong> 失败，而 <code>assert!</code> 只会打印出它从 <code>==</code> 表达式中得到了 <code>false</code> 值，而不是导致 <code>false</code> 的两个值。</p>
<p>示例 11-7 中，让我们编写一个对其参数加二并返回结果的函数 <code>add_two</code>。接着使用 <code>assert_eq!</code> 宏测试这个函数：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-7：使用 <code>assert_eq!</code> 宏测试 <code>add_two</code></span></p>
<p>测试通过了！</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>传递给 <code>assert_eq!</code> 宏的第一个参数 <code>4</code> ，等于调用 <code>add_two(2)</code> 的结果。测试中的这一行 <code>test tests::it_adds_two ... ok</code> 中 <code>ok</code> 表明测试通过！</p>
<p>在代码中引入一个 bug 来看看使用 <code>assert_eq!</code> 的测试失败是什么样的。修改 <code>add_two</code> 函数的实现使其加 3：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
#}</code></pre></pre>
<p>再次运行测试：</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
        thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>测试捕获到了 bug！<code>it_adds_two</code> 测试失败，显示信息 <code>assertion failed: `(left == right)`</code> 并表明 <code>left</code> 是 <code>4</code> 而 <code>right</code> 是 <code>5</code>。这个信息有助于我们开始调试：它说 <code>assert_eq!</code> 的 <code>left</code> 参数是 <code>4</code>，而 <code>right</code> 参数，也就是 <code>add_two(2)</code> 的结果，是 <code>5</code>。</p>
<p>需要注意的是，在一些语言和测试框架中，断言两个值相等的函数的参数叫做 <code>expected</code> 和 <code>actual</code>，而且指定参数的顺序是很关键的。然而在 Rust 中，他们则叫做 <code>left</code> 和 <code>right</code>，同时指定期望的值和被测试代码产生的值的顺序并不重要。这个测试中的断言也可以写成 <code>assert_eq!(add_two(2), 4)</code>，这时失败信息会变成 <code>assertion failed: `(left == right)`</code> 其中 <code>left</code> 是 <code>5</code> 而 <code>right</code> 是 <code>4</code>。</p>
<p><code>assert_ne!</code> 宏在传递给它的两个值不相等时通过，而在相等时失败。在代码按预期运行，我们不确定值 <strong>会</strong> 是什么，不过能确定值绝对 <strong>不会</strong> 是什么的时候，这个宏最有用处。例如，如果一个函数保证会以某种方式改变其输出，不过这种改变方式是由运行测试时是星期几来决定的，这时最好的断言可能就是函数的输出不等于其输入。</p>
<p><code>assert_eq!</code> 和 <code>assert_ne!</code> 宏在底层分别使用了 <code>==</code> 和 <code>!=</code>。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必需实现了 <code>PartialEq</code> 和 <code>Debug</code> trait。所有的基本类型和大部分标准库类型都实现了这些 trait。对于自定义的结构体和枚举，需要实现 <code>PartialEq</code> 才能断言他们的值是否相等。需要实现 <code>Debug</code> 才能在断言失败时打印他们的值。因为这两个 trait 都是派生 trait，如第五章示例 5-12 所提到的，通常可以直接在结构体或枚举上添加 <code>#[derive(PartialEq, Debug)]</code> 注解。附录 C 中有更多关于这些和其他派生 trait 的详细信息。</p>
<a class="header" href="print.html#a自定义失败信息" id="a自定义失败信息"><h3>自定义失败信息</h3></a>
<p>你也可以向 <code>assert!</code>、<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。任何在 <code>assert!</code> 的一个必需参数和 <code>assert_eq!</code> 和 <code>assert_ne!</code> 的两个必需参数之后指定的参数都会传递给 <code>format!</code> 宏（在第八章的“使用 <code>+</code> 运算符或 <code>format!</code> 宏连接字符串”部分讨论过），所以可以传递一个包含 <code>{}</code> 占位符的格式字符串和需要放入占位符的值。自定义信息有助于记录断言的意义；当测试失败时就能更好的理解代码出了什么问题。</p>
<p>例如，比如说有一个根据人名进行问候的函数，而我们希望测试将传递给函数的人名显示在输出中：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
#}</code></pre></pre>
<p>这个程序的需求还没有被确定，因此问候文本开头的 <code>Hello</code> 文本很可能会改变。然而我们并不想在需求改变时不得不更新测试，所以相比检查 <code>greeting</code> 函数返回的确切值，我们将仅仅断言输出的文本中包含输入参数。</p>
<p>让我们通过将 <code>greeting</code> 改为不包含 <code>name</code> 来在代码中引入一个 bug 来测试失败时是怎样的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
#}</code></pre></pre>
<p>运行测试会产生：</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains(&quot;Carol&quot;)', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>这仅仅告诉了我们断言失败了和失败的行号。一个更有用的失败信息应该打印出 <code>greeting</code> 函数的值。让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 <code>greeting</code> 函数的值：</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>现在如果再次运行测试，将会看到更有价值的信息：</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'Greeting did not
contain name, value was `Hello!`', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>可以在测试输出中看到所取得的确切的值，这会帮助我们理解真正发生了什么，而不是期望发生什么。</p>
<a class="header" href="print.html#a使用-should_panic-检查-panic" id="a使用-should_panic-检查-panic"><h3>使用 <code>should_panic</code> 检查 panic</h3></a>
<p>除了检查代码是否返回期望的正确的值之外，检查代码是否按照期望处理错误也是很重要的。例如，考虑第九章示例 9-9 创建的 <code>Guess</code> 类型。其他使用 <code>Guess</code> 的代码都是基于 <code>Guess</code> 实例仅有的值范围在 1 到 100 的前提。可以编写一个测试来确保创建一个超出范围的值的 <code>Guess</code> 实例会 panic。</p>
<p>可以通过对函数增加另一个属性 <code>should_panic</code> 来实现这些。这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败。</p>
<p>示例 11-8 展示了一个检查 <code>Guess::new</code> 是否按照我们的期望出错的测试：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-8：测试会造成 <code>panic!</code> 的条件</span></p>
<p><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前。让我们看看测试通过时它是什么样子：</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>看起来不错！现在在代码中引入 bug，移除 <code>new</code> 函数在值大于 100 时会 panic 的条件：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Guess {
#     value: u32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
#}</code></pre></pre>
<p>如果运行示例 11-8 的测试，它会失败：</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>这回并没有得到非常有用的信息，不过一旦我们观察测试函数，会发现它标注了 <code>#[should_panic]</code>。这个错误意味着代码中函数 <code>Guess::new(200)</code> 并没有产生 panic。</p>
<p>然而 <code>should_panic</code> 测试结果可能会非常含糊不清，因为它只是告诉我们代码并没有产生 panic。<code>should_panic</code> 甚至在一些不是我们期望的原因而导致 panic 时也会通过。为了使 <code>should_panic</code> 测试结果更精确，我们可以给 <code>should_panic</code> 属性增加一个可选的 <code>expected</code> 参数。测试工具会确保错误信息中包含其提供的文本。例如，考虑示例 11-9 中修改过的 <code>Guess</code>，这里 <code>new</code> 函数根据其值是过大还或者过小而提供不同的 panic 信息：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Guess {
#     value: u32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-9：一个会带有特定错误信息的 <code>panic!</code> 条件的测试</span></p>
<p>这个测试会通过，因为 <code>should_panic</code> 属性中 <code>expected</code> 参数提供的值是 <code>Guess::new</code> 函数 panic 信息的子串。我们可以指定期望的整个 panic 信息，在这个例子中是 <code>Guess value must be less than or equal to 100, got 200.</code> 。 <code>expected</code> 信息的选择取决于 panic 信息有多独特或动态，和你希望测试有多准确。在这个例子中，错误信息的子字符串足以确保函数在 <code>else if value &gt; 100</code> 的情况下运行。</p>
<p>为了观察带有 <code>expected</code> 信息的 <code>should_panic</code> 测试失败时会发生什么，让我们再次引入一个 bug，将 <code>if value &lt; 1</code> 和 <code>else if value &gt; 100</code> 的代码块对换：</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>这一次运行 <code>should_panic</code> 测试，它会失败：</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
        thread 'tests::greater_than_100' panicked at 'Guess value must be
greater than or equal to 1, got 200.', src/lib.rs:11:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>失败信息表明测试确实如期望 panic 了，不过 panic 信息中并没有包含 <code>expected</code> 信息 <code>'Guess value must be less than or equal to 100'</code>。而我们得到的 panic 信息是 <code>'Guess value must be greater than or equal to 1, got 200.'</code>。这样就可以开始寻找 bug 在哪了！</p>
<p>现在你知道了几种编写测试的方法，让我们看看运行测试时会发生什么，和可以用于 <code>cargo test</code> 的不同选项。</p>
<a class="header" href="print.html#a控制测试如何运行" id="a控制测试如何运行"><h2>控制测试如何运行</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch11-02-running-tests.md">ch11-02-running-tests.md</a>
<br>
commit 550c8ea6f74060ff1f7b67e7e1878c4da121682d</p>
</blockquote>
<p>就像 <code>cargo run</code> 会编译代码并运行生成的二进制文件一样，<code>cargo test</code> 在测试模式下编译代码并运行生成的测试二进制文件。可以指定命令行参数来改变 <code>cargo test</code> 的默认行为。例如，<code>cargo test</code> 生成的二进制文件的默认行为是并行的运行所有测试，并截获测试运行过程中产生的输出，阻止他们被显示出来，使得阅读测试结果相关的内容变得更容易。</p>
<p>这些选项的一部分可以传递给 <code>cargo test</code>，而另一些则需要传递给生成的测试二进制文件。为了分隔两种类型的参数，首先列出传递给 <code>cargo test</code> 的参数，接着是分隔符 <code>--</code>，再之后是传递给测试二进制文件的参数。运行 <code>cargo test --help</code> 会告诉你 <code>cargo test</code> 的相关参数，而运行 <code>cargo test -- --help</code> 则会告诉你可以在分隔符 <code>--</code> 之后使用的相关参数。</p>
<a class="header" href="print.html#a并行或连续的运行测试" id="a并行或连续的运行测试"><h3>并行或连续的运行测试</h3></a>
<p>当运行多个测试时，他们默认使用线程来并行的运行。这意味着测试会更快的运行完毕，所以你可以更快的得到代码能否工作的反馈。因为测试是在同时运行的，你应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境，比如当前工作目录或者环境变量。</p>
<p>举个例子，每一个测试都运行一些代码，假设这些代码都在硬盘上创建一个 <em>test-output.txt</em> 文件并写入一些数据。接着每一个测试都读取文件中的数据并断言这个文件包含特定的值，而这个值在每个测试中都是不同的。因为所有测试都是同时运行的，一个测试可能会在另一个测试读写文件过程中修改了文件。那么第二个测试就会失败，并不是因为代码不正确，而是因为测试并行运行时相互干扰。一个解决方案是使每一个测试读写不同的文件；另一个解决方案是一次运行一个测试。</p>
<p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 <code>--test-threads</code> 参数和希望使用线程的数量给测试二进制文件。例如：</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>这里将测试线程设置为 1，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<a class="header" href="print.html#a显示函数输出" id="a显示函数输出"><h3>显示函数输出</h3></a>
<p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。比如在测试中调用了 <code>println!</code> 而测试通过了，我们将不会在终端看到 <code>println!</code> 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息。</p>
<p>例如，示例 11-10 有一个无意义的函数，它打印出其参数的值并接着返回 10。接着还有一个会通过的测试和一个会失败的测试：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-10：一个调用了 <code>println!</code> 的函数的测试</span></p>
<p>运行 <code>cargo test</code> 将会看到这些测试的输出：</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>注意输出中不会出现测试通过时打印的内容，即 <code>I got the value 4</code>。因为当测试通过时，这些输出会被截获。失败测试的输出 <code>I got the value 8</code> ，则出现在输出的测试摘要部分，同时也显示了测试失败的原因。</p>
<p>如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 <code>--nocapture</code> 参数来禁用：</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>使用 <code>--nocapture</code> 参数再次运行示例 11-10 中的测试会显示如下输出：</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>注意测试的输出和测试结果的输出是相互交叉的；这是由于测试是并行运行的，也就是上一部分讲到的。尝试一同使用 <code>--test-threads=1</code> 和 <code>--nocapture</code> 功能来看看输出是什么样子！</p>
<a class="header" href="print.html#a通过名称来运行测试的子集" id="a通过名称来运行测试的子集"><h3>通过名称来运行测试的子集</h3></a>
<p>有时运行整个测试集会耗费很长时间。如果你负责特定位置的代码，你可能会希望只运行这些代码相关的测试。你可以向 <code>cargo test</code> 传递希望运行的测试的部分名称作为参数来选择运行哪些测试。</p>
<p>为了展示如何运行测试的子集，示例 11-11 为 <code>add_two</code> 函数创建了三个测试，我们可以选择具体运行哪一个：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-11：不同名称的三个测试</span></p>
<p>如果没有传递任何参数就运行测试，如你所见，所有测试都会并行运行：</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#a运行单个测试" id="a运行单个测试"><h4>运行单个测试</h4></a>
<p>可以向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试：</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>只有名称为 <code>one_hundred</code> 的测试被运行了；因为其余两个测试并不匹配这个名称。测试输出在摘要行的结尾显示了 <code>2 filtered out</code> 表明还存在比本次所运行的测试更多的测试被过滤掉了。</p>
<p>不能像这样指定多个测试名称；只有传递给 <code>cargo test</code> 的第一个值才会被使用。不过有运行多个测试的方法。</p>
<a class="header" href="print.html#a过滤运行多个测试" id="a过滤运行多个测试"><h4>过滤运行多个测试</h4></a>
<p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 <code>add</code>，可以通过 <code>cargo test add</code> 来运行这两个测试：</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>这运行了所有名字中带有 <code>add</code> 的测试，也过滤掉了名为 <code>one_hundred</code> 的测试。同时注意测试所在的模块也是测试名称的一部分，所以可以通过模块名来运行一个模块中的所有测试。</p>
<a class="header" href="print.html#a忽略某些测试" id="a忽略某些测试"><h3>忽略某些测试</h3></a>
<p>有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 <code>cargo test</code> 的时候希望能排除他们。虽然可以通过参数列举出所有希望运行的测试来做到，也可以使用 <code>ignore</code> 属性来标记耗时的测试并排除他们，如下所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#}</code></pre></pre>
<p>对于想要排除的测试，我们在 <code>#[test]</code> 之后增加了 <code>#[ignore]</code> 行。现在如果运行测试，就会发现 <code>it_works</code> 运行了，而 <code>expensive_test</code> 没有运行：</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>expensive_test</code> 被列为 <code>ignored</code>，如果我们只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code>：</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>通过控制运行哪些测试，你可以确保能够快速地运行 <code>cargo test</code> 。当某个时刻需要检查 <code>ignored</code> 测试的结果，而且你也有时间等待这个结果的话，就可以选择执行 <code>cargo test -- --ignored</code>。</p>
<a class="header" href="print.html#a测试的组织结构" id="a测试的组织结构"><h2>测试的组织结构</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch11-03-test-organization.md">ch11-03-test-organization.md</a>
<br>
commit b3eddb8edc0c3f83647143673d18efac0a44083a</p>
</blockquote>
<p>本章一开始就提到，测试是一个复杂的概念，而且不同的开发者也采用不同的技术和组织。Rust 社区倾向于根据测试的两个主要分类来考虑问题：<strong>单元测试</strong>（<em>unit tests</em>）与 <strong>集成测试</strong>（<em>integration tests</em>）。单元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口。而集成测试对于你的库来说则完全是外部的。它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。</p>
<p>为了保证你的库能够按照你的预期运行，从独立和整体的角度编写这两类测试都是非常重要的。</p>
<a class="header" href="print.html#a单元测试" id="a单元测试"><h3>单元测试</h3></a>
<p>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。单元测试与他们要测试的代码共同存放在位于 <em>src</em> 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块。</p>
<a class="header" href="print.html#a测试模块和-cfgtest" id="a测试模块和-cfgtest"><h4>测试模块和 <code>cfg(test)</code></h4></a>
<p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，而在运行 <code>cargo build</code> 时不这么做。这在只希望构建库的时候可以节省编译时间，并且因为它们并没有包含测试，所以能减少编译产生的文件的大小。与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 <code>#[cfg(test)]</code> 注解。然而单元测试位于与源码相同的文件中，所以你需要使用 <code>#[cfg(test)]</code> 来指定他们不应该被包含进编译结果中。</p>
<p>还记得本章第一部分新建的 <code>adder</code> 项目吗？Cargo 为我们生成了如下代码：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>上述代码就是自动生成的测试模块。<code>cfg</code> 属性代表 <em>configuration</em> ，它告诉 Rust 其之后的项只应该被包含进特定配置选项中。在这个例子中，配置选项是 <code>test</code>，即 Rust 所提供的用于编译和运行测试的配置选项。通过使用 <code>cfg</code> 属性，Cargo 只会在我们主动使用 <code>cargo test</code> 运行测试时才编译测试代码。需要编译的不仅仅有标注为 <code>#[test]</code> 的函数之外，还包括测试模块中可能存在的帮助函数。</p>
<a class="header" href="print.html#a测试私有函数" id="a测试私有函数"><h4>测试私有函数</h4></a>
<p>测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的，甚至是不可能的事。不过无论你坚持哪种测试意识形态，Rust 的私有性规则确实允许你测试私有函数。考虑示例 11-12 中带有私有函数 <code>internal_adder</code> 的代码：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 11-12：测试私有函数</span></p>
<p>注意 <code>internal_adder</code> 函数并没有标记为 <code>pub</code>，不过因为测试也不过是 Rust 代码同时 <code>tests</code> 也仅仅是另一个模块，我们完全可以在测试中导入和调用 <code>internal_adder</code>。如果你并不认为应该测试私有函数，Rust 也不会强迫你这么做。</p>
<a class="header" href="print.html#a集成测试" id="a集成测试"><h3>集成测试</h3></a>
<p>在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。为了创建集成测试，你需要先创建一个 <em>tests</em> 目录。</p>
<a class="header" href="print.html#tests-目录" id="tests-目录"><h4><em>tests</em> 目录</h4></a>
<p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。</p>
<p>让我们来创建一个集成测试。保留示例 11-12 中 <em>src/lib.rs</em> 的代码。创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>，并输入示例 11-13 中的代码。</p>
<p><span class="filename">文件名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">示例 11-13：一个 <code>adder</code> crate 中函数的集成测试</span></p>
<p>我们在顶部增加了 <code>extern crate adder</code>，这在单元测试中是不需要的。这是因为每一个 <code>tests</code> 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。</p>
<p>并不需要将 <em>tests/integration_test.rs</em> 中的任何代码标注为 <code>#[cfg(test)]</code>。Cargo 对 <code>tests</code> 文件夹特殊处理并只会在运行 <code>cargo test</code> 时编译这个目录中的文件。现在就运行 <code>cargo test</code> 试试：</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>现在有了三个部分的输出：单元测试、集成测试和文档测试。第一部分单元测试与我们之前见过的一样：每个单元测试一行（示例 11-12 中有一个叫做 <code>internal</code> 的测试），接着是一个单元测试的摘要行。</p>
<p>集成测试部分以行 <code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code>（在输出最后的哈希值可能不同）开头。接下来每一行是一个集成测试中的测试函数，以及一个位于 <code>Doc-tests adder</code> 部分之前的集成测试的摘要行。</p>
<p>我们已经知道，单元测试函数越多，单元测试部分的结果行就会越多。同样的，在集成文件中增加的测试函数越多，也会在对应的测试结果部分增加越多的结果行。每一个集成测试文件有对应的测试结果部分，所以如果在 <em>tests</em> 目录中增加更多文件，测试结果中就会有更多集成测试结果部分。</p>
<p>我们仍然可以通过指定测试函数的名称作为 <code>cargo test</code> 的参数来运行特定集成测试。也可以使用 <code>cargo test</code> 的 <code>--test</code> 后跟文件的名称来运行某个特定集成测试文件中的所有测试：</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>这个命令只运行了 <em>tests</em> 目录中我们指定的文件 <code>integration_test.rs</code> 中的测试。</p>
<a class="header" href="print.html#a集成测试中的子模块" id="a集成测试中的子模块"><h4>集成测试中的子模块</h4></a>
<p>随着集成测试的增加，你可能希望在 <code>tests</code> 目录增加更多文件以便更好的组织他们，例如根据测试的功能来将测试分组。正如我们之前提到的，每一个 <em>tests</em> 目录中的文件都被编译为单独的 crate。</p>
<p>将每个集成测试文件当作其自己的 crate 来对待，这更有助于创建单独的作用域，这种单独的作用域能提供更类似与最终使用者使用 crate 的环境。然而，正如你在第七章中学习的如何将代码分为模块和文件的知识，<em>tests</em> 目录中的文件不能像 <em>src</em> 中的文件那样共享相同的行为。</p>
<p>当你有一些在多个集成测试文件都会用到的帮助函数，而你尝试按照第七章 “将模块移动到其他文件” 部分的步骤将他们提取到一个通用的模块中时， <em>tests</em> 目录中不同文件的行为就会显得很明显。例如，如果我们创建了 <em>tests/common.rs</em> 文件并将一个名叫 <code>setup</code> 的函数放入其中，这里将放入一些我们希望能够在多个测试文件的多个测试函数中调用的代码：</p>
<p><span class="filename">文件名: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // setup code specific to your library's tests would go here
}
#}</code></pre></pre>
<p>如果再次运行测试，将会在测试结果中看到一个新的对应 <em>common.rs</em> 文件的测试结果部分，即便这个文件并没有包含任何测试函数，也没有任何地方调用了 <code>setup</code> 函数：</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>我们并不希望 <code>common</code> 出现在测试结果中并显示 <code>running 0 tests</code> 。我们只是希望能够在其他集成测试文件中分享一些代码罢了。</p>
<p>为了避免 <code>common</code> 出现在测试输出中，我们将创建 <em>tests/common/mod.rs</em> ，而不是创建 <em>tests/common.rs</em> 。在第七章的 “模块文件系统规则” 部分，对于拥有子模块的模块文件使用了 <em>module_name/mod.rs</em> 命名规范，虽然这里 <code>common</code> 并没有子模块，但是这样命名告诉 Rust 不要将 <code>common</code> 看作一个集成测试文件。当将 <code>setup</code> 函数代码移动到 <em>tests/common/mod.rs</em> 并删除 <em>tests/common.rs</em> 文件之后，测试输出中将不会出现这一部分。<em>tests</em> 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中。</p>
<p>一旦拥有了 <em>tests/common/mod.rs</em>，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 <em>tests/integration_test.rs</em> 中调用 <code>setup</code> 函数的 <code>it_adds_two</code> 测试的例子：</p>
<p><span class="filename">文件名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>注意 <code>mod common;</code> 声明与示例 7-4 中展示的模块声明相同。接着在测试函数中就可以调用 <code>common::setup()</code> 了。</p>
<a class="header" href="print.html#a二进制-crate-的集成测试" id="a二进制-crate-的集成测试"><h4>二进制 crate 的集成测试</h4></a>
<p>如果项目是二进制 crate 并且只包含 <em>src/main.rs</em> 而没有 <em>src/lib.rs</em>，这样就不可能在 <em>tests</em> 目录创建集成测试并使用 <code>extern crate</code> 导入 <em>src/main.rs</em> 中定义的函数。只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数；二进制 crate 只意在单独运行。</p>
<p>为什么 Rust 二进制项目的结构明确采用 <em>src/main.rs</em> 调用 <em>src/lib.rs</em> 中的逻辑的方式？因为通过这种结构，集成测试 <strong>就可以</strong> 通过 <code>extern crate</code> 测试库 crate 中的主要功能了，而如果这些重要的功能没有问题的话，<em>src/main.rs</em> 中的少量代码也就会正常工作且不需要测试。</p>
<a class="header" href="print.html#a总结-10" id="a总结-10"><h2>总结</h2></a>
<p>Rust 的测试功能提供了一个确保即使你改变了函数的实现方式，也能继续以期望的方式运行的途径。单元测试独立地验证库的不同部分，也能够测试私有函数实现细节。集成测试则检查多个部分是否能结合起来正确地工作，并像其他外部代码那样测试库的公有 API。即使 Rust 的类型系统和所有权规则可以帮助避免一些 bug，不过测试对于减少代码中不符合期望行为的逻辑 bug 仍然是很重要的。</p>
<p>让我们将本章和其他之前章节所学的知识组合起来，在下一章一起编写一个项目！</p>
<a class="header" href="print.html#a一个-io-项目构建一个命令行程序" id="a一个-io-项目构建一个命令行程序"><h1>一个 I/O 项目：构建一个命令行程序</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-00-an-io-project.md">ch12-00-an-io-project.md</a>
<br>
commit 97e60b3cb623d4a5b85419212b085ade8a11cbe1</p>
</blockquote>
<p>本章既是一个目前所学的很多技能的概括，也是一个更多标准库功能的探索。我们将构建一个与文件和命令行输入/输出交互的命令行工具来练习现在一些你已经掌握的 Rust 技能。</p>
<p>Rust 的运行速度、安全性、<strong>单二进制文件</strong> 输出和跨平台支持使其成为创建命令行程序的绝佳选择，所以我们的项目将创建一个我们自己版本的经典命令行工具：<code>grep</code>。grep 是 “<strong>G</strong>lobally search a <strong>R</strong>egular <strong>E</strong>xpression and <strong>P</strong>rint.” 的首字母缩写。<code>grep</code> 最简单的使用场景是在特定文件中搜索指定字符串。为此，<code>grep</code> 获取一个文件名和一个字符串作为参数，接着读取文件并找到其中包含字符串参数的行，然后打印出这些行。</p>
<p>在这个过程中，我们会展示如何让我们的命令行工具利用很多命令行工具中用到的终端功能。读取环境变量来使得用户可以配置工具的行为。打印到标准错误控制流（<code>stderr</code>） 而不是标准输出（<code>stdout</code>），例如这样用户可以选择将成功输出重定向到文件中的同时仍然在屏幕上显示错误信息。</p>
<p>一位 Rust 社区的成员，Andrew Gallant，已经创建了一个功能完整且非常快速的 <code>grep</code> 版本，叫做 <code>ripgrep</code>。相比之下，我们的 <code>grep</code> 版本将非常简单，本章将教会你一些帮助理解像 <code>ripgrep</code> 这样真实项目的背景知识。</p>
<p>我们的 <code>grep</code> 项目将会结合之前所学的一些内容：</p>
<ul>
<li>代码组织（使用第七章学习的模块）</li>
<li>vector 和字符串（第八章，集合）</li>
<li>错误处理（第九章）</li>
<li>合理的使用 trait 和生命周期（第十章）</li>
<li>测试（第十一章）</li>
</ul>
<p>另外还会简要的讲到闭包、迭代器和 trait 对象，他们分别会在第十三章和第十七章中详细介绍。</p>
<a class="header" href="print.html#a接受命令行参数" id="a接受命令行参数"><h2>接受命令行参数</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-01-accepting-command-line-arguments.md">ch12-01-accepting-command-line-arguments.md</a>
<br>
commit 97e60b3cb623d4a5b85419212b085ade8a11cbe1</p>
</blockquote>
<p>一如之前使用 <code>cargo new</code> 新建一个项目，我们称之为 <code>minigrep</code> 以便与可能已经安装在系统上的<code>grep</code>工具相区别：</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>第一个任务是让 <code>minigrep</code> 能够接受两个命令行参数：文件名和要搜索的字符串。也就是说我们希望能够使用 <code>cargo run</code>、要搜索的字符串和被搜索的文件的路径来运行程序，像这样：</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>现在 <code>cargo new</code> 生成的程序忽略任何传递给它的参数。<a href="https://crates.io/">Crates.io</a> 上有一些现成的库可以帮助我们接受命令行参数，不过我们正在学习这些内容，让我们自己来实现一个。</p>
<a class="header" href="print.html#a读取参数值" id="a读取参数值"><h3>读取参数值</h3></a>
<p>为了确保 <code>minigrep</code> 能够获取传递给它的命令行参数的值，我们需要一个 Rust 标准库提供的函数，也就是 <code>std::env::args</code>。这个函数返回一个传递给程序的命令行参数的 <strong>迭代器</strong>（<em>iterator</em>）。我们还未讨论到迭代器（第十三章会全面的介绍他们），但是现在只需理解迭代器的两个细节：迭代器生成一系列的值，可以在迭代器上调用 <code>collect</code> 方法将其转换为一个集合，比如包含所有迭代器产生元素的 vector。</p>
<p>使用示例 12-1 中的代码来读取任何传递给 <code>minigrep</code> 的命令行参数并将其收集到一个 vector 中。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">示例 12-1：将命令行参数收集到一个 vector 中并打印出来</span></p>
<p>首先使用 <code>use</code> 语句来将 <code>std::env</code> 模块引入作用域以便可以使用它的 <code>args</code> 函数。注意 <code>std::env::args</code> 函数被嵌套进了两层模块中。正如第七章讲到的，当所需函数嵌套了多于一层模块时，通常将父模块引入作用域，而不是其自身。这便于我们利用 <code>std::env</code> 中的其他函数。这比增加了 <code>use std::env::args;</code> 后仅仅使用 <code>args</code> 调用函数要更明确一些，因为 <code>args</code> 容易被错认成一个定义于当前模块的函数。</p>
<blockquote>
<a class="header" href="print.html#args-函数和无效的-unicode" id="args-函数和无效的-unicode"><h3><code>args</code> 函数和无效的 Unicode</h3></a>
<p>注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。这个函数返回 <code>OsString</code> 值而不是 <code>String</code> 值。这里出于简单考虑使用了 <code>std::env::args</code>，因为 <code>OsString</code> 值每个平台都不一样而且比 <code>String</code> 值处理起来更为复杂。</p>
</blockquote>
<p>在 <code>main</code> 函数的第一行，我们调用了 <code>env::args</code>，并立即使用 <code>collect</code> 来创建了一个包含迭代器所有值的 vector。<code>collect</code> 可以被用来创建很多类型的集合，所以这里显式注明 <code>args</code> 的类型来指定我们需要一个字符串 vector。虽然在 Rust 中我们很少会需要注明类型，<code>collect</code> 就是一个经常需要注明类型的函数，因为 Rust 不能推断出你想要什么类型的集合。</p>
<p>最后，我们使用调试格式 <code>:?</code> 打印出 vector。让我们尝试不用参数运行代码，接着用两个参数：</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>注意 vector 的第一个值是 <code>&quot;target/debug/minigrep&quot;</code>，它是我们二进制文件的名称。这与 C 中的参数列表的行为相匹配，让程序使用在执行时调用它们的名称。如果要在消息中打印它或者根据用于调用程序的命令行别名更改程序的行为，通常可以方便地访问程序名称，不过考虑到本章的目的，我们将忽略它并只保存所需的两个参数。</p>
<a class="header" href="print.html#a将参数值保存进变量" id="a将参数值保存进变量"><h3>将参数值保存进变量</h3></a>
<p>打印出参数 vector 中的值展示了程序可以访问指定为命令行参数的值。现在需要将这两个参数的值保存进变量这样就可以在程序的余下部分使用这些值了。让我们如示例 12-2 这样做：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">示例 12-2：创建变量来存放查询参数和文件名参数</span></p>
<p>正如之前打印出 vector 时所所看到的，程序的名称占据了 vector 的第一个值 <code>args[0]</code>，所以我们从索引 <code>1</code> 开始。<code>minigrep</code> 获取的第一个参数是需要搜索的字符串，所以将其将第一个参数的引用存放在变量 <code>query</code> 中。第二个参数将是文件名，所以将第二个参数的引用放入变量 <code>filename</code> 中。</p>
<p>我们将临时打印出这些变量的值来证明代码如我们期望的那样工作。使用参数 <code>test</code> 和 <code>sample.txt</code> 再次运行这个程序：</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>好的，它可以工作！我们将所需的参数值保存进了对应的变量中。之后会增加一些错误处理来应对类似用户没有提供参数的情况，不过现在我们将忽略他们并开始增加读取文件功能。</p>
<a class="header" href="print.html#a读取文件" id="a读取文件"><h2>读取文件</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-02-reading-a-file.md">ch12-02-reading-a-file.md</a>
<br>
commit 97e60b3cb623d4a5b85419212b085ade8a11cbe1</p>
</blockquote>
<p>接下来我们将读取由命令行文件名参数指定的文件。首先，需要一个用来测试的示例文件——用来确保 <code>minigrep</code> 正常工作的最好的文件是拥有多行少量文本且有一些重复单词的文件。示例 12-3 是一首艾米莉·狄金森（Emily Dickinson）的诗，它正适合这个工作！在项目根目录创建一个文件 <code>poem.txt</code>，并输入诗 &quot;I'm nobody! Who are you?&quot;：</p>
<p><span class="filename">文件名: poem.txt</span></p>
<pre><code class="language-text">I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">示例 12-3：艾米莉·狄金森的诗 “I’m nobody! Who are you?”，一个好的测试用例</span></p>
<p>创建完这个文件之后，修改 <em>src/main.rs</em> 并增加如示例 12-4 所示的打开文件的代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">示例 12-4：读取第二个参数所指定的文件内容</span></p>
<p>首先，我们增加了更多的 <code>use</code> 语句来引入标准库中的相关部分：需要 <code>std::fs::File</code> 来处理文件，而 <code>std::io::prelude::*</code> 则包含许多对于 I/O（包括文件 I/O）有帮助的 trait。类似于 Rust 有一个通用的 prelude 来自动引入特定内容，<code>std::io</code> 也有其自己的 prelude 来引入处理 I/O 时所需的通用内容。不同于默认的 prelude，必须显式 <code>use</code> 位于 <code>std::io</code> 中的 prelude。</p>
<p>在 <code>main</code> 中，我们增加了三点内容：第一，通过传递变量 <code>filename</code> 的值调用 <code>File::open</code> 函数来获取文件的可变句柄。创建了叫做 <code>contents</code> 的变量并将其设置为一个可变的，空的 <code>String</code>。它将会存放之后读取的文件的内容。第三，对文件句柄调用 <code>read_to_string</code> 并传递 <code>contents</code> 的可变引用作为参数。</p>
<p>在这些代码之后，我们再次增加了临时的 <code>println!</code> 打印出读取文件后 <code>contents</code> 的值，这样就可以检查目前为止的程序能否工作。</p>
<p>尝试运行这些代码，随意指定一个字符串作为第一个命令行参数（因为还未实现搜索功能的部分）而将 <em>poem.txt</em> 文件将作为第二个参数：</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>好的！代码读取并打印出了文件的内容。虽然它还有一些瑕疵：<code>main</code> 函数有着多个职能，通常函数只负责一个功能的话会更简洁并易于维护。另一个问题是没有尽可能的处理错误。虽然我们的程序还很小，这些瑕疵并不是什么大问题，不过随着程序功能的丰富，将会越来越难以用简单的方法修复他们。在开发程序时，及早开始重构是一个最佳实践，因为重构少量代码时要容易的多，所以让我们现在就开始吧。</p>
<a class="header" href="print.html#a重构改进模块性和错误处理" id="a重构改进模块性和错误处理"><h2>重构改进模块性和错误处理</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-03-improving-error-handling-and-modularity.md">ch12-03-improving-error-handling-and-modularity.md</a>
<br>
commit c1fb695e6c9091c9a5145320498ef80a649af33c</p>
</blockquote>
<p>为了改善我们的程序这里有四个问题需要修复，而且他们都与程序的组织方式和如何处理潜在错误有关。</p>
<p>第一，<code>main</code> 现在进行了两个任务：它解析了参数并打开了文件。对于一个这样的小函数，这并不是一个大问题。然而如果 <code>main</code> 中的功能持续增加，<code>main</code> 函数处理的独立任务也会增加。当函数承担了更多责任，它就更难以推导，更难以测试，并且更难以在不破坏其他部分的情况下做出修改。最好能分离出功能以便每个函数就负责一个任务。</p>
<p>这同时也关系到第二个问题：<code>search</code> 和 <code>filename</code> 是程序中的配置变量，而像 <code>f</code> 和 <code>contents</code> 则用来执行程序逻辑。随着 <code>main</code> 函数的增长，就需要引入更多的变量到作用域中，而当作用域中有更多的变量时，将更难以追踪每个变量的目的。最好能将配置变量组织进一个结构，这样就能使他们的目的更明确了。</p>
<p>第三个问题是如果打开文件失败我们使用 <code>expect</code> 来打印出错误信息，不过这个错误信息只是说 <code>file not found</code>。除了缺少文件之外还有很多打开文件可能失败的方式：例如，文件可能存在，不过可能没有打开它的权限。如果我们现在就出于这种情况，打印出的 <code>file not found</code> 错误信息就给了用户错误的建议！</p>
<p>第四，我们不停的使用 <code>expect</code> 来处理不同的错误，如果用户没有指定足够的参数来运行程序，他们会从 Rust 得到 &quot;index out of bounds&quot; 错误，而这并不能明确的解释问题。如果所有的错误处理都位于一处这样将来的维护者在需要修改错误处理逻辑时就只需要考虑这一处代码。将所有的错误处理都放在一处也有助于确保我们打印的错误信息对终端用户来说是有意义的。</p>
<p>让我们通过重构项目来解决这些问题。</p>
<a class="header" href="print.html#a二进制项目的关注分离" id="a二进制项目的关注分离"><h3>二进制项目的关注分离</h3></a>
<p><code>main</code> 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p>
<ol>
<li>将程序拆分成 <em>main.rs</em> 和 <em>lib.rs</em> 并将程序的逻辑放入 <em>lib.rs</em> 中。</li>
<li>当命令行解析逻辑比较小时，可以保留在 <em>main.rs</em> 中。</li>
<li>当命令行解析开始变得复杂时，也同样将其从 <em>main.rs</em> 提取到 <em>lib.rs</em> 中。</li>
<li>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>设置任何其他的配置</li>
<li>调用 <em>lib.rs</em> 中的 <code>run</code> 函数</li>
<li>如果 <code>run</code> 返回错误，则处理这个错误</li>
</ul>
</li>
</ol>
<p>这个模式的一切就是为了关注分离：<em>main.rs</em> 处理程序运行，而 <em>lib.rs</em> 处理所有的真正的任务逻辑。因为不能直接测试 <code>main</code> 函数，这个结构通过将所有的程序逻辑移动到 <em>lib.rs</em> 的函数中使得我们可以测试他们。仅仅保留在 <em>main.rs</em> 中的代码将足够小以便阅读就可以验证其正确性。让我们遵循这些步骤来重构程序。</p>
<a class="header" href="print.html#a提取参数解析器" id="a提取参数解析器"><h3>提取参数解析器</h3></a>
<p>首先，我们将解析参数的功能提取到一个 <code>main</code> 将会调用的函数中，为将命令行解析逻辑移动到 <em>src/lib.rs</em> 中做准备。示例 12-5 中展示了新 <code>main</code> 函数的开头，它调用了新函数 <code>parse_config</code>。目前它仍将定义在 <em>src/main.rs</em> 中：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">示例 12-5：从 <code>main</code> 中提取出 <code>parse_config</code> 函数</span></p>
<p>我们仍然将命令行参数收集进一个 vector，不过不同于在 <code>main</code> 函数中将索引 1 的参数值赋值给变量 <code>query</code> 和将索引 2 的值赋值给变量 <code>filename</code>，我们将整个 vector 传递给 <code>parse_config</code> 函数。接着 <code>parse_config</code> 函数将包含决定哪个参数该放入哪个变量的逻辑，并将这些值返回到 <code>main</code>。仍然在 <code>main</code> 中创建变量 <code>query</code> 和 <code>filename</code>，不过 <code>main</code> 不再负责处理命令行参数与变量如何对应。</p>
<p>这对重构我们这小程序可能有点大材小用，不过我们将采用小的、增量的步骤进行重构。在做出这些改变之后，再次运行程序并验证参数解析是否仍然正常。经常验证你的进展是一个好习惯，这样在遇到问题时能帮助你定位问题的成因。</p>
<a class="header" href="print.html#a组合配置值" id="a组合配置值"><h3>组合配置值</h3></a>
<p>我们可以采取另一个小的步骤来进一步改善这个函数。现在函数返回一个元组，不过立刻又将元组拆成了独立的部分。这是一个我们可能没有进行正确抽象的信号。</p>
<p>另一个表明还有改进空间的迹象是 <code>parse_config</code> 名称的 <code>config</code> 部分，它暗示了我们返回的两个值是相关的并都是一个配置值的一部分。目前除了将这两个值组合进元组之外并没有表达这个数据结构的意义：我们可以将这两个值放入一个结构体并给每个字段一个有意义的名字。这会让未来的维护者更容易理解不同的值如何相互关联以及他们的目的。</p>
<blockquote>
<p>注意：一些同学将这种在复杂类型更为合适的场景下使用基本类型的反模式称为 <strong>基本类型偏执</strong>（<em>primitive obsession</em>）。</p>
</blockquote>
<p>示例 12-6 展示了新定义的结构体 <code>Config</code>，它有字段 <code>query</code> 和 <code>filename</code>。我们也改变了 <code>parse_config</code> 函数来返回一个 <code>Config</code> 结构体的实例，并更新 <code>main</code> 来使用结构体字段而不是单独的变量：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">示例 12-6：重构 <code>parse_config</code> 返回一个 <code>Config</code> 结构体实例</span></p>
<p><code>parse_config</code> 的签名表明它现在返回一个 <code>Config</code> 值。在 <code>parse_config</code> 的函数体中，之前返回引用了 <code>args</code> 中 <code>String</code> 值的字符串 slice，现在我们选择定义 <code>Config</code> 来包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者并只允许 <code>parse_config</code> 函数借用他们，这意味着如果 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权将违反 Rust 的借用规则。</p>
<p>还有许多不同的方式可以处理 <code>String</code> 的数据，而最简单但有些不太高效的方式是调用这些值的 <code>clone</code> 方法。这会生成 <code>Config</code> 实例可以拥有的数据的完整拷贝，不过会比储存字符串数据的引用消耗更多的时间和内存。不过拷贝数据使得代码显得更加直白因为无需管理引用的生命周期，所以在这种情况下牺牲一小部分性能来换取简洁性的取舍是值得的。</p>
<blockquote>
<a class="header" href="print.html#a使用-clone-的权衡取舍" id="a使用-clone-的权衡取舍"><h4>使用 <code>clone</code> 的权衡取舍</h4></a>
<p>由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 <code>clone</code> 来解决所有权问题。在关于迭代器的第十三章中，我们将会学习如何更有效率的处理这种情况，不过现在，复制一些字符串来取得进展是没有问题的，因为只会进行一次这样的拷贝，而且文件名和要搜索的字符串都比较短。在第一轮编写时拥有一个可以工作但有点低效的程序要比尝试过度优化代码更好一些。随着你对 Rust 更加熟练，将能更轻松的直奔合适的方法，不过现在调用 <code>clone</code> 是完全可以接受的。</p>
</blockquote>
<p>我们更新 <code>main</code> 将 <code>parse_config</code> 返回的 <code>Config</code> 实例放入变量 <code>config</code> 中，并将之前分别使用 <code>search</code> 和 <code>filename</code> 变量的代码更新为现在的使用 <code>Config</code> 结构体的字段的代码。</p>
<p>现在代码更明确的表现了我们的意图，<code>query</code> 和 <code>filename</code> 是相关联的并且他们的目的是配置程序如何工作。任何使用这些值的代码就知道在 <code>config</code> 实例中对应目的的字段名中寻找他们。</p>
<a class="header" href="print.html#a创建一个-config-构造函数" id="a创建一个-config-构造函数"><h3>创建一个 <code>Config</code> 构造函数</h3></a>
<p>目前为止，我们将负责解析命令行参数的逻辑从 <code>main</code> 提取到了 <code>parse_config</code> 函数中，这有助于我们看清值 <code>query</code> 和 <code>filename</code> 是相互关联的并应该在代码中表现这种关系。接着我们增加了 <code>Config</code> 结构体来描述 <code>query</code> 和 <code>filename</code> 的相关性，并能够从 <code>parse_config</code> 函数中将这些值的名称作为结构体字段名称返回。</p>
<p>所以现在 <code>parse_config</code> 函数的目的是创建一个 <code>Config</code> 实例，我们可以将 <code>parse_config</code> 从一个普通函数变为一个叫做 <code>new</code> 的与结构体关联的函数。做出这个改变使得代码更符合习惯：可以像标准库中的 <code>String</code> 调用 <code>String::new</code> 来创建一个该类型的实例那样，将 <code>parse_config</code> 变为一个与 <code>Config</code> 关联的 <code>new</code> 函数。示例 12-7 展示了需要做出的修改：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">示例 12-7：将 <code>parse_config</code> 变为 <code>Config::new</code></span></p>
<p>这里将 <code>main</code> 中调用 <code>parse_config</code> 的地方更新为调用 <code>Config::new</code>。我们将 <code>parse_config</code> 的名字改为 <code>new</code> 并将其移动到 <code>impl</code> 块中，这使得 <code>new</code> 函数与 <code>Config</code> 相关联。再次尝试编译并确保它可以工作。</p>
<a class="header" href="print.html#a修复错误处理" id="a修复错误处理"><h3>修复错误处理</h3></a>
<p>现在我们开始修复错误处理。回忆一下之前提到过如果 <code>args</code> vector 包含少于 3 个项并尝试访问 vector 中索引 <code>1</code> 或索引 <code>2</code> 的值会造成程序 panic。尝试不带任何参数运行程序；这将看起来像这样：</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code> 是一个针对程序员的错误信息，然而这并不能真正帮助终端用户理解发生了什么和他们应该做什么。现在就让我们修复它吧。</p>
<a class="header" href="print.html#a改善错误信息" id="a改善错误信息"><h4>改善错误信息</h4></a>
<p>在示例 12-8 中，在 <code>new</code> 函数中增加了一个检查在访问索引 1 和 2 之前检查 slice 是否足够长。如果 slice 不够长，我们使用一个更好的错误信息 panic 而不是 <code>index out of bounds</code> 信息：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">示例 12-8：增加一个参数数量检查</span></p>
<p>这类似于示例 9-9 中的 <code>Guess::new</code> 函数，那里如果 <code>value</code> 参数超出了有效值的范围就调用 <code>panic!</code>。不同于检查值的范围，这里检查 <code>args</code> 的长度至少是 3，而函数的剩余部分则可以在假设这个条件成立的基础上运行。如果
<code>args</code> 少于 3 个项，则这个条件将为真，并调用 <code>panic!</code> 立即终止程序。</p>
<p>有了 <code>new</code> 中这几行额外的代码，再次不带任何参数运行程序并看看现在错误看起来像什么：</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>这个输出就好多了，现在有了一个合理的错误信息。然而，还是有一堆额外的信息我们不希望提供给用户。所以在这里使用示例 9-9 中的技术可能不是最好的；正如第九章所讲到的一样，<code>panic!</code> 的调用更趋向于程序上的问题而不是使用上的问题。相反我们可以使用第九章学习的另一个技术：返回一个可以表明成功或错误的 <code>Result</code>。</p>
<a class="header" href="print.html#a从-new-中返回-result-而不是调用-panic" id="a从-new-中返回-result-而不是调用-panic"><h4>从 <code>new</code> 中返回 <code>Result</code> 而不是调用 <code>panic!</code></h4></a>
<p>我们可以选择返回一个 <code>Result</code> 值，它在成功时会包含一个 <code>Config</code> 的实例，而在错误时会描述问题。当 <code>Config::new</code> 与 <code>main</code> 交流时，可以使用 <code>Result</code> 类型来表明这里存在问题。接着修改 <code>main</code> 将 <code>Err</code> 成员转换为对用户更友好的错误，而不是 <code>panic!</code> 调用产生的关于 <code>thread 'main'</code> 和 <code>RUST_BACKTRACE</code> 的文本。</p>
<p>示例 12-9 展示了为了返回 <code>Result</code> 在 <code>Config::new</code> 的返回值和函数体中所需的改变：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">示例 12-9：从 <code>Config::new</code> 中返回 <code>Result</code></span></p>
<p>现在 <code>new</code> 函数返回一个 <code>Result</code>，在成功时带有一个 <code>Config</code> 实例而在出现错误时带有一个 <code>&amp;'static str</code>。回忆一下第十章 “静态生命周期” 中讲到 <code>&amp;'static str</code> 是字符串字面值的类型，也是目前的错误信息。</p>
<p><code>new</code> 函数体中有两处修改：当没有足够参数时不再调用 <code>panic!</code>，而是返回 <code>Err</code> 值。同时我们将 <code>Config</code> 返回值包装进 <code>Ok</code> 成员中。这些修改使得函数符合其新的类型签名。</p>
<p>通过让 <code>Config::new</code> 返回一个 <code>Err</code> 值，这就允许 <code>main</code> 函数处理 <code>new</code> 函数返回的 <code>Result</code> 值并在出现错误的情况更明确的结束进程。</p>
<a class="header" href="print.html#confignew-调用并处理错误" id="confignew-调用并处理错误"><h4><code>Config::new</code> 调用并处理错误</h4></a>
<p>为了处理错误情况并打印一个对用户友好的信息，我们需要像示例 12-10 那样更新 <code>main</code> 函数来处理现在 <code>Config::new</code> 返回的 <code>Result</code>。另外还需要负责手动实现 <code>panic!</code> 的使用非零错误码退出命令行工具的工作。非零的退出状态是一个告诉调用程序的进程我们的程序以错误状态退出的惯例信号。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">示例 12-10：如果新建 <code>Config</code> 失败则使用错误码退出</span></p>
<p>在上面的示例中，使用了一个之前没有涉及到的方法：<code>unwrap_or_else</code>，它定义于标准库的 <code>Result&lt;T, E&gt;</code> 上。使用 <code>unwrap_or_else</code> 可以进行一些自定义的非 <code>panic!</code> 的错误处理。当 <code>Result</code> 是 <code>Ok</code> 时，这个方法的行为类似于 <code>unwrap</code>：它返回 <code>Ok</code> 内部封装的值。然而，当其值是 <code>Err</code> 时，该方法会调用一个 <strong>闭包</strong>（<em>closure</em>），也就是一个我们定义的作为参数传递给 <code>unwrap_or_else</code> 的匿名函数。第十三章会更详细的介绍闭包。现在你需要理解的是 <code>unwrap_or_else</code> 会将 <code>Err</code> 的内部值，也就是示例 12-9 中增加的 <code>not enough arguments</code> 静态字符串的情况，传递给闭包中位于两道竖线间的参数 <code>err</code>。闭包中的代码在其运行时可以使用这个 <code>err</code> 值。</p>
<p>我们新增了一个 <code>use</code> 行来从标准库中导入 <code>process</code>。在错误的情况闭包中将被运行的代码只有两行：我们打印出了 <code>err</code> 值，接着调用了 <code>std::process::exit</code>。<code>process::exit</code> 会立即停止程序并将传递给它的数字作为退出状态码。这类似于示例 12-8 中使用的基于 <code>panic!</code> 的错误处理，除了不会再得到所有的额外输出了。让我们试试：</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>非常好！现在输出对于用户来说就友好多了。</p>
<a class="header" href="print.html#a从-main-提取逻辑" id="a从-main-提取逻辑"><h3>从 <code>main</code> 提取逻辑</h3></a>
<p>现在我们完成了配置解析的重构：让我们转向程序的逻辑。正如 “二进制项目的关注分离” 部分所展开的讨论，我们将提取一个叫做 <code>run</code> 的函数来存放目前 <code>main</code>函数中不属于设置配置或处理错误的所有逻辑。一旦完成这些，<code>main</code> 函数将简明的足以通过观察来验证，而我们将能够为所有其他逻辑编写测试。</p>
<p>示例 12-11 展示了提取出来的 <code>run</code> 函数。目前我们只进行小的增量式的提取函数的改进。我们仍将在 <em>src/main.rs</em> 中定义这个函数：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">示例 12-11：提取 <code>run</code> 函数来包含剩余的程序逻辑</span></p>
<p>现在 <code>run</code> 函数包含了 <code>main</code> 中从读取文件开始的剩余的所有逻辑。<code>run</code> 函数获取一个 <code>Config</code> 实例作为参数。</p>
<a class="header" href="print.html#a从-run-函数中返回错误" id="a从-run-函数中返回错误"><h4>从 <code>run</code> 函数中返回错误</h4></a>
<p>通过将剩余的逻辑分离进 <code>run</code> 函数而不是留在 <code>main</code> 中，就可以像示例 12-9 中的 <code>Config::new</code> 那样改进错误处理。不再通过 <code>expect</code> 允许程序 panic，<code>run</code> 函数将会在出错时返回一个 <code>Result&lt;T, E&gt;</code>。这让我们进一步以一种对用户友好的方式统一 <code>main</code> 中的错误处理。示例 12-12 展示了 <code>run</code> 签名和函数体中的改变：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">示例 12-12：修改 <code>run</code> 函数返回 <code>Result</code></span></p>
<p>这里我们做出了三个明显的修改。首先，将 <code>run</code> 函数的返回类型变为 <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>。之前这个函数返回 unit 类型 <code>()</code>，现在它仍然保持作为 <code>Ok</code> 时的返回值。</p>
<p>对于错误类型，使用了 <strong>trait 对象</strong> <code>Box&lt;Error&gt;</code>（在开头使用了 <code>use</code> 语句将 <code>std::error::Error</code> 引入作用域）。第十七章会涉及 trait 对象。目前只需知道 <code>Box&lt;Error&gt;</code> 意味着函数会返回实现了 <code>Error</code> trait 的类型，不过无需指定具体将会返回的值的类型。这提供了在不同的错误场景可能有不同类型的错误返回值的灵活性。</p>
<p>第二个改变是去掉了 <code>expect</code> 调用并替换为第九章讲到的 <code>?</code>。不同于遇到错误就 <code>panic!</code>，这会从函数中返回错误值并让调用者来处理它。</p>
<p>第三个修改是现在成功时这个函数会返回一个 <code>Ok</code> 值。因为 <code>run</code> 函数签名中声明成功类型返回值是 <code>()</code>，这意味着需要将 unit 类型值包装进 <code>Ok</code> 值中。<code>Ok(())</code> 一开始看起来有点奇怪，不过这样使用 <code>()</code> 是表明我们调用 <code>run</code> 只是为了它的副作用的惯用方式；它并没有返回什么有意义的值。</p>
<p>上述代码能够编译，不过会有一个警告：</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust 提示我们的代码忽略了 <code>Result</code> 值，它可能表明这里存在一个错误。虽然我们没有检查这里是否有一个错误，而编译器提醒我们这里应该有一些错误处理代码！现在就让我们修正他们。</p>
<a class="header" href="print.html#a处理-main-中-run-返回的错误" id="a处理-main-中-run-返回的错误"><h4>处理 <code>main</code> 中 <code>run</code> 返回的错误</h4></a>
<p>我们将检查错误并使用类似示例 12-10 中 <code>Config::new</code> 处理错误的技术来处理他们，不过有一些细微的不同：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>我们使用 <code>if let</code> 来检查 <code>run</code> 是否返回一个 <code>Err</code> 值，不同于 <code>unwrap_or_else</code>，并在出错时调用 <code>process::exit(1)</code>。<code>run</code> 并不返回像 <code>Config::new</code> 返回的 <code>Config</code> 实例那样需要 <code>unwrap</code> 的值。因为 <code>run</code> 在成功时返回 <code>()</code>，而我们只关心检测错误，所以并不需要 <code>unwrap_or_else</code> 来返回未封装的值，因为它只会是 <code>()</code>。</p>
<p>不过两个例子中 <code>if let</code> 和 <code>unwrap_or_else</code> 的函数体都一样：打印出错误并退出。</p>
<a class="header" href="print.html#a将代码拆分到库-crate" id="a将代码拆分到库-crate"><h3>将代码拆分到库 crate</h3></a>
<p>现在我们的 <code>minigrep</code> 项目看起来好多了！现在我们将要拆分 <em>src/main.rs</em> 并将一些代码放入 <em>src/lib.rs</em>，这样就能测试他们并拥有一个含有更少功能的 <code>main</code> 函数。</p>
<p>让我们将所有不是 <code>main</code> 函数的代码从 <em>src/main.rs</em> 移动到新文件 <em>src/lib.rs</em> 中：</p>
<ul>
<li><code>run</code> 函数定义</li>
<li>相关的 <code>use</code> 语句</li>
<li><code>Config</code> 的定义</li>
<li><code>Config::new</code> 函数定义</li>
</ul>
<p>现在 <em>src/lib.rs</em> 的内容应该看起来像示例 12-13（为了简洁省略了函数体）。注意直到下一个示例修改完 <em>src/main.rs</em> 之后，代码还不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">示例 12-13：将 <code>Config</code> 和 <code>run</code> 移动到 <em>src/lib.rs</em></span></p>
<p>这里使用了公有的 <code>pub</code>：在 <code>Config</code>、其字段和其 <code>new</code> 方法，以及 <code>run</code> 函数上。现在我们有了一个拥有可以测试的公有 API 的库 crate 了。</p>
<p>现在需要在 <em>src/main.rs</em> 中将移动到 <em>src/lib.rs</em> 的代码引入二进制 crate 的作用域中，如示例 12-14 所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">示例 12-14：将 <code>minigrep</code> crate 引入 <em>src/main.rs</em> 的作用域中</span></p>
<p>为了将库 crate 引入二进制 crate，我们使用 <code>extern crate minigrep</code>。接着增加 <code>use minigrep::Config</code> 将 <code>Config</code> 类型引入作用域，并使用 crate 名作为 <code>run</code> 函数的前缀。通过这些重构，所有功能应该能够联系在一起并运行了。运行 <code>cargo run</code> 来确保一切都正确的衔接在一起。</p>
<p>哇哦！这可有很多的工作，不过我们为将来的成功打下了基础。现在处理错误将更容易，同时代码也更加模块化。从现在开始几乎所有的工作都将在 <em>src/lib.rs</em> 中进行。</p>
<p>让我们利用这些新创建的模块的优势来进行一些在旧代码中难以展开的工作，他们在新代码中却很简单：编写测试！</p>
<a class="header" href="print.html#a采用测试驱动开发完善库的功能" id="a采用测试驱动开发完善库的功能"><h2>采用测试驱动开发完善库的功能</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-04-testing-the-librarys-functionality.md">ch12-04-testing-the-librarys-functionality.md</a>
<br>
commit 1fe78a83f37ecc69b840fdc8dcfc727f88a3a3d4</p>
</blockquote>
<p>现在我们将逻辑提取到了 <em>src/lib.rs</em> 并将所有的参数解析和错误处理留在了 <em>src/main.rs</em> 中，为代码的核心功能编写测试将更加容易。我们可以直接使用多种参数调用函数并检查返回值而无需从命令行运行二进制文件了。如果你愿意的话，请自行为 <code>Config::new</code> 和 <code>run</code> 函数的功能编写一些测试。</p>
<p>在这一部分，我们将遵循测试驱动开发（Test Driven Development, TDD）的模式来逐步增加 <code>minigrep</code> 的搜索逻辑。这是一个软件开发技术，它遵循如下步骤：</p>
<ol>
<li>编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。</li>
<li>编写或修改刚好足够的代码来使得新的测试通过。</li>
<li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li>
<li>从步骤 1 开始重复！</li>
</ol>
<p>这只是众多编写软件的方法之一，不过 TDD 有助于驱动代码的设计。在编写能使测试通过的代码之前编写测试有助于在开发过程中保持高测试覆盖率。</p>
<p>我们将测试驱动实现实际在文件内容中搜索查询字符串并返回匹配的行示例的功能。我们将在一个叫做 <code>search</code> 的函数中增加这些功能。</p>
<a class="header" href="print.html#a编写失败测试" id="a编写失败测试"><h3>编写失败测试</h3></a>
<p>去掉 <em>src/lib.rs</em> 和 <em>src/main.rs</em> 中用于检查程序行为的 <code>println!</code> 语句，因为不再真正需要他们了。接着我们会像第十一章那样增加一个 <code>test</code> 模块和一个测试函数。测试函数指定了 <code>search</code> 函数期望拥有的行为：它会获取一个需要查询的字符串和用来查询的文本，并只会返回包含请求的文本行。示例 12-15 展示了这个测试，它还不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 12-15：创建一个我们期望的 <code>search</code> 函数的失败测试</span></p>
<p>这里选择使用 &quot;duct&quot; 作为这个测试中需要搜索的字符串。用来搜索的文本有三行，其中只有一行包含 &quot;duct&quot;。我们断言 <code>search</code> 函数的返回值只包含期望的那一行。</p>
<p>我们还不能运行这个测试并看到它失败，因为它甚至都还不能编译！我们将增加足够的代码来使其能够编译：一个总是会返回空 vector 的 <code>search</code> 函数定义，如示例 12-16 所示。然后这个测试应该能够编译并因为空 vector 并不匹配一个包含一行 <code>&quot;safe, fast, productive.&quot;</code> 的 vector 而失败。</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
#}</code></pre></pre>
<p><span class="caption">示例 12-16：刚好足够使测试通过编译的 <code>search</code> 函数定义</span></p>
<p>注意需要在 <code>search</code> 的签名中定义一个显式生命周期 <code>'a</code> 并用于 <code>contents</code> 参数和返回值。回忆一下第十章中讲到生命周期参数指定哪个参数的生命周期与返回值的生命周期相关联。在这个例子中，我们表明返回的 vector 中应该包含引用参数 <code>contents</code>（而不是参数<code>query</code>） slice 的字符串 slice。</p>
<p>换句话说，我们告诉 Rust 函数 <code>search</code> 返回的数据将与 <code>search</code> 函数中的参数 <code>contents</code> 的数据存在的一样久。这是非常重要的！为了使这个引用有效那么 <strong>被</strong> slice 引用的数据也需要保持有效；如果编译器认为我们是在创建 <code>query</code> 而不是 <code>contents</code> 的字符串 slice，那么安全检查将是不正确的。</p>
<p>如果尝试不用生命周期编译的话，我们将得到如下错误：</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust 不可能知道我们需要的是哪一个参数，所以需要告诉它。因为参数 <code>contents</code> 包含了所有的文本而且我们希望返回匹配的那部分文本，所以我们知道 <code>contents</code> 是应该要使用生命周期语法来与返回值相关联的参数。</p>
<p>其他语言中并不需要你在函数签名中将参数与返回值相关联，所以这么做可能仍然感觉有些陌生，随着时间的推移这将会变得越来越容易。你可能想要将这个例子与第十章中生命周期语法部分做对比。</p>
<p>现在运行测试：</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>好的，测试失败了，这正是我们所期望的。修改代码来让测试通过吧！</p>
<a class="header" href="print.html#a编写使测试通过的代码" id="a编写使测试通过的代码"><h3>编写使测试通过的代码</h3></a>
<p>目前测试之所以会失败是因为我们总是返回一个空的 vector。为了修复并实现 <code>search</code>，我们的程序需要遵循如下步骤：</p>
<ul>
<li>遍历内容的每一行文本。</li>
<li>查看这一行是否包含要搜索的字符串。</li>
<li>如果有，将这一行加入列表返回值中。</li>
<li>如果没有，什么也不做。</li>
<li>返回匹配到的结果列表</li>
</ul>
<p>让我们一步一步的来，从遍历每行开始。</p>
<a class="header" href="print.html#a使用-lines-方法遍历每一行" id="a使用-lines-方法遍历每一行"><h4>使用 <code>lines</code> 方法遍历每一行</h4></a>
<p>Rust 有一个有助于一行一行遍历字符串的方法，出于方便它被命名为 <code>lines</code>，它如示例 12-17 这样工作。注意这还不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">示例 12-17：遍历 <code>contents</code> 的每一行</span></p>
<p><code>lines</code> 方法返回一个迭代器。第十三章会深入了解迭代器，不过我们已经在示例 3-4 中见过使用迭代器的方法了，在那里使用了一个 <code>for</code> 循环和迭代器在一个集合的每一项上运行了一些代码。</p>
<a class="header" href="print.html#a用查询字符串搜索每一行" id="a用查询字符串搜索每一行"><h4>用查询字符串搜索每一行</h4></a>
<p>接下来将会增加检查当前行是否包含查询字符串的功能。幸运的是，字符串类型为此也有一个叫做 <code>contains</code> 的实用方法！如示例 12-18 所示在 <code>search</code> 函数中加入 <code>contains</code> 方法调用。注意这仍然不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">示例 12-18：增加检查文本行是否包含 <code>query</code> 中字符串的功能</span></p>
<a class="header" href="print.html#a存储匹配的行" id="a存储匹配的行"><h4>存储匹配的行</h4></a>
<p>我们还需要一个方法来存储包含查询字符串的行。为此可以在 <code>for</code> 循环之前创建一个可变的 vector 并调用 <code>push</code> 方法在 vector 中存放一个 <code>line</code>。在 <code>for</code> 循环之后，返回这个 vector，如示例 12-19 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">示例 12-19：储存匹配的行以便可以返回他们</span></p>
<p>现在 <code>search</code> 函数应该返回只包含 <code>query</code> 的那些行，而测试应该会通过。让我们运行测试：</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>测试通过了，它可以工作了！</p>
<p>到此为止，我们可以考虑一下重构 <code>search</code> 的实现并时刻保持测试通过来保持其功能不变的机会了。<code>search</code> 函数中的代码并不坏，不过并没有利用迭代器的一些实用功能。第十三章将回到这个例子并深入探索迭代器并看看如何改进代码。</p>
<a class="header" href="print.html#a在-run-函数中使用-search-函数" id="a在-run-函数中使用-search-函数"><h4>在 <code>run</code> 函数中使用 <code>search</code> 函数</h4></a>
<p>现在 <code>search</code> 函数是可以工作并测试通过了的，我们需要实际在 <code>run</code> 函数中调用 <code>search</code>。需要将 <code>config.query</code> 值和 <code>run</code> 从文件中读取的 <code>contents</code> 传递给 <code>search</code> 函数。接着 <code>run</code> 会打印出 <code>search</code> 返回的每一行：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>这里仍然使用了 <code>for</code> 循环获取了 <code>search</code> 返回的每一行并打印出来。</p>
<p>现在整个程序应该可以工作了！让我们试一试，首先使用一个只会在艾米莉·狄金森的诗中返回一行的单词 “frog”：</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>好的！现在试试一个会匹配多行的单词，比如 “body”：</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>最后，让我们确保搜索一个在诗中哪里都没有的单词时不会得到任何行，比如 &quot;monomorphization&quot;：</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>非常好！我们创建了一个属于自己的迷你版经典工具，并学习了很多如何组织程序的知识。我们还学习了一些文件输入输出、生命周期、测试和命令行解析的内容。</p>
<p>为了使这个项目更丰满，我们将简要的展示如何处理环境变量和打印到标准错误，这两者在编写命令行程序时都很有用。</p>
<a class="header" href="print.html#a处理环境变量" id="a处理环境变量"><h2>处理环境变量</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-05-working-with-environment-variables.md">ch12-05-working-with-environment-variables.md</a>
<br>
commit 1fe78a83f37ecc69b840fdc8dcfc727f88a3a3d4</p>
</blockquote>
<p>我们将增加一个额外的功能来改进 <code>minigrep</code>：一个通过环境变量启用的大小写不敏感搜索的选项。可以将其设计为一个命令行参数并要求用户每次需要时都加上它，不过相反我们将使用环境变量。这允许用户设置环境变量一次之后在整个终端会话中所有的搜索都将是大小写不敏感的。</p>
<a class="header" href="print.html#a编写一个大小写不敏感-search-函数的失败测试" id="a编写一个大小写不敏感-search-函数的失败测试"><h3>编写一个大小写不敏感 <code>search</code> 函数的失败测试</h3></a>
<p>我们希望增加一个新函数 <code>search_case_insensitive</code>，并将会在设置了环境变量时调用它。这里将继续遵循 TDD 过程，其第一步是再次编写一个失败测试。我们将为新的大小写不敏感搜索函数新增一个测试函数，并将老的测试函数从 <code>one_result</code> 改名为 <code>case_sensitive</code> 来更清楚的表明这两个测试的区别，如示例 12-20 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 12-20：为准备添加的大小写不敏感函数新增失败测试</span></p>
<p>注意我们也改变了老测试中 <code>contents</code> 的值。还新增了一个含有文本 &quot;Duct tape&quot; 的行，它有一个大写的 D，这在大小写敏感搜索时不应该匹配 &quot;duct&quot;。我们修改这个测试以确保不会意外破坏已经实现的大小写敏感搜索功能；这个测试现在应该能通过并在处理大小写不敏感搜索时应该能一直通过。</p>
<p>大小写 <strong>不敏感</strong> 搜索的新测试使用 &quot;rUsT&quot; 作为其查询字符串。在我们将要增加的 <code>search_case_insensitive</code> 函数中，“rUsT” 查询应该包含 “Rust:” 包含一个大写的 R 还有 “Trust me.” 这两行，即便他们与查询的大小写都不同。这个测试现在会编译失败因为还没有定义 <code>search_case_insensitive</code> 函数。请随意增加一个总是返回空 vector 的骨架实现，正如示例 12-16 中 <code>search</code> 函数为了使测试编译并失败时所做的那样。</p>
<a class="header" href="print.html#a实现-search_case_insensitive-函数" id="a实现-search_case_insensitive-函数"><h3>实现 <code>search_case_insensitive</code> 函数</h3></a>
<p><code>search_case_insensitive</code> 函数，如示例 12-21 所示，将与 <code>search</code> 函数基本相同。唯一的区别是它会将 <code>query</code> 变量和每一 <code>line</code> 都变为小写，这样不管输入参数是大写还是小写，在检查该行是否包含查询字符串时都会是小写。</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">示例 12-21：定义 <code>search_case_insensitive</code> 函数，它在比较查询和每一行之前将他们都转换为小写</span></p>
<p>首先我们将 <code>query</code> 字符串转换为小写，并将其覆盖到同名的变量中。对查询字符串调用 <code>to_lowercase</code> 是必需的，这样不管用户的查询是 “rust”、“RUST”、“Rust” 或者 “rUsT”，我们都将其当作 “rust” 处理并对大小写不敏感。</p>
<p>注意 <code>query</code> 现在是一个 <code>String</code> 而不是字符串 slice，因为调用 <code>to_lowercase</code> 是在创建新数据，而不是引用现有数据。如果查询字符串是 “rUsT”，这个字符串 slice 并不包含可供我们使用的小写的 “u” 或 “t”，所以必需分配一个包含 “rust” 的新 <code>String</code>。现在当我们将 <code>query</code> 作为一个参数传递给 <code>contains</code> 方法时，需要增加一个 &amp; 因为 <code>contains</code> 的签名被定义为获取一个字符串 slice。</p>
<p>接下来在检查每个 <code>line</code> 是否包含 <code>search</code> 之前增加了一个 <code>to_lowercase</code> 调用将他们都变为小写。现在我们将 <code>line</code> 和 <code>query</code> 都转换成了小写，这样就可以不管查询的大小写进行匹配了。</p>
<p>让我们看看这个实现能否通过测试：</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>好的！现在，让我们在 <code>run</code> 函数中实际调用新 <code>search_case_insensitive</code> 函数。首先，我们将在 <code>Config</code> 结构体中增加一个配置项来切换大小写敏感和大小写不敏感搜索：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<p>这里增加了 <code>case_sensitive</code> 字符来存放一个布尔值。接着我们需要 <code>run</code> 函数检查 <code>case_sensitive</code> 字段的值并使用它来决定是否调用 <code>search</code> 函数或 <code>search_case_insensitive</code> 函数，如示例 12-22 所示。注意这还不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">示例 12-22：根据 <code>config.case_sensitive</code> 的值调用 <code>search</code> 或 <code>search_case_insensitive</code></span></p>
<p>最后需要实际检查环境变量。处理环境变量的函数位于标准库的 <code>env</code> 模块中，所以我们需要在 <em>src/lib.rs</em> 的开头增加一个 <code>use std::env;</code> 行将这个模块引入作用域中。接着在 <code>Config::new</code> 中使用 <code>env</code> 模块的 <code>var</code> 方法来检查一个叫做 <code>CASE_INSENSITIVE</code> 的环境变量，如示例 12-23 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 12-23：检查叫做 <code>CASE_INSENSITIVE</code> 的环境变量</span></p>
<p>这里创建了一个新变量 <code>case_sensitive</code>。为了设置它的值，需要调用 <code>env::var</code> 函数并传递我们需要寻找的环境变量名称，<code>CASE_INSENSITIVE</code>。<code>env::var</code> 返回一个 <code>Result</code>，它在环境变量被设置时返回包含其值的 <code>Ok</code> 成员，并在环境变量未被设置时返回 <code>Err</code> 成员。</p>
<p>我们使用 <code>Result</code> 的 <code>is_err</code> 方法来检查其是否是一个 error（也就是环境变量未被设置的情况），这也就意味着我们 <strong>需要</strong> 进行一个大小写敏感搜索。如果<code>CASE_INSENSITIVE</code> 环境变量被设置为任何值，<code>is_err</code> 会返回 false 并将进行大小写不敏感搜索。我们并不关心环境变量所设置的 <strong>值</strong>，只关心它是否被设置了，所以检查 <code>is_err</code> 而不是 <code>unwrap</code>、<code>expect</code> 或任何我们已经见过的 <code>Result</code> 的方法。</p>
<p>我们将变量 <code>case_sensitive</code> 的值传递给 <code>Config</code> 实例，这样 <code>run</code> 函数可以读取其值并决定是否调用 <code>search</code> 或者示例 12-22 中实现的 <code>search_case_insensitive</code>。</p>
<p>让我们试一试吧！首先不设置环境变量并使用查询 “to” 运行程序，这应该会匹配任何全小写的单词 “to” 的行：</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>看起来程序仍然能够工作！现在将 <code>CASE_INSENSITIVE</code> 设置为 1 并仍使用相同的查询 “to”，这回应该得到包含可能有大写字母的 “to” 的行：</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>如果你使用 PowerShell，则需要用两句命令而不是一句来设置环境变量并运行程序：</p>
<pre><code class="language-text">$ $env.CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>好极了，我们也得到了包含 “To” 的行！现在 <code>minigrep</code> 程序可以通过环境变量控制进行大小写不敏感搜索了。现在你知道了如何管理由命令行参数或环境变量设置的选项了！</p>
<p>一些程序允许对相同配置同时使用参数 <strong>和</strong> 环境变量。在这种情况下，程序来决定参数和环境变量的优先级。作为一个留给你的测试，尝试通过一个命令行参数或一个环境变量来控制大小写不敏感搜索。并在运行程序时遇到矛盾值时决定命令行参数和环境变量的优先级。</p>
<p><code>std::env</code> 模块还包含了更多处理环境变量的实用功能；请查看官方文档来了解其可用的功能。</p>
<a class="header" href="print.html#a将错误信息输出到标准错误而不是标准输出" id="a将错误信息输出到标准错误而不是标准输出"><h2>将错误信息输出到标准错误而不是标准输出</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch12-06-writing-to-stderr-instead-of-stdout.md">ch12-06-writing-to-stderr-instead-of-stdout.md</a>
<br>
commit 1fe78a83f37ecc69b840fdc8dcfc727f88a3a3d4</p>
</blockquote>
<p>目前为止，我们将所有的输出都 <code>println!</code> 到了终端。大部分终端都提供了两种输出：<strong>标准输出</strong>（<em>standard output</em>，<code>stdout</code>）对应通用信息，<strong>标准错误</strong>（<em>standard error</em>，<code>stderr</code>）则用于错误信息。这种区别允许用户选择将程序正常输出定向到一个文件中并仍将错误信息打印到屏幕上。</p>
<p>但是 <code>println!</code> 函数只能够打印到标准输出，所以我们必需使用其他方法来打印到标准错误。</p>
<a class="header" href="print.html#a检查错误应该写入何处" id="a检查错误应该写入何处"><h3>检查错误应该写入何处</h3></a>
<p>首先，让我们观察一下目前 <code>minigrep</code> 打印的所有内容都被写入了标准输出，包括应该被写入标准错误的错误信息。可以通过将标准输出流重定向到一个文件同时有意产生一个错误来做到这一点。我们没有重定向标准错误流，所以任何发送到标准错误的内容将会继续显示在屏幕上。</p>
<p>命令行程序被期望将错误信息发送到标准错误流，这样即便选择将标准输出流重定向到文件中时仍然能看到错误信息。目前我们的程序并不符合期望；相反我们将看到它将错误信息输出保存到了文件中。</p>
<p>展示这种行为的方式是通过 <code>&gt;</code> 和文件名 <em>output.txt</em> 来与运行程序，这个文件是期望重定向标准输出流的位置。并不传递任何参数应该会产生一个错误：</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p><code>&gt;</code> 语法告诉 shell 将标准输出的内容写入到 <em>output.txt</em> 文件中而不是屏幕上。我们并没有看到期望的错误信息打印到屏幕上，所以这意味着它一定被写入了文件中。如下是 <em>output.txt</em> 所包含的：</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>是的，错误信息被打印到了标准输出中。像这样的错误信息被打印到标准错误中将有用的多，并在重定向标准输出时只将成功运行的信息写入文件。我们将改变他们。</p>
<a class="header" href="print.html#a将错误打印到标准错误" id="a将错误打印到标准错误"><h3>将错误打印到标准错误</h3></a>
<p>让我们如示例 12-24 所示的代码改变错误信息是如何被打印的。得益于本章早些时候的重构，所有打印错误信息的代码都位于 <code>main</code> 一个函数中。标准库提供了 <code>eprintln!</code> 宏来打印到标准错误流，所以将两个调用 <code>println!</code> 打印错误信息的位置替换为 <code>eprintln!</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">示例 12-24：使用 <code>eprintln!</code> 将错误信息写入标准错误而不是标准输出</span></p>
<p>将 <code>println!</code> 改为 <code>eprintln!</code> 之后，让我们再次尝试用同样的方式运行程序，不使用任何参数并通过 <code>&gt;</code> 重定向标准输出：</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>现在我们看到了屏幕上的错误信息，同时 <code>output.txt</code> 里什么也没有，这正是命令行程序所期望的行为。</p>
<p>如果使用不会造成错误的参数再次运行程序，不过仍然将标准输出重定向到一个文件，像这样：</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>我们并不会在终端看到任何输出，同时 <code>output.txt</code> 将会包含其结果：</p>
<p><span class="filename">文件名: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>这一部分展示了现在我们适当的使用了成功时产生的标准输出和错误时产生的标准错误。</p>
<a class="header" href="print.html#a总结-11" id="a总结-11"><h2>总结</h2></a>
<p>在这一章中，我们回顾了目前为止的一些主要章节并涉及了如何在 Rust 环境中进行常规的 I/O 操作。通过使用命令行参数、文件、环境变量和打印错误的 <code>eprintln!</code> 宏，现在你已经准备好编写命令行程序了。通过结合前几章的知识，你的代码将会是组织良好的，并能有效的将数据存储到合适的数据结构中、更好的处理错误，并且还是经过良好测试的。</p>
<p>接下来，让我们探索一些 Rust 中受函数式编程语言影响的功能：闭包和迭代器。</p>
<a class="header" href="print.html#rust-中的函数式语言功能迭代器与闭包" id="rust-中的函数式语言功能迭代器与闭包"><h1>Rust 中的函数式语言功能：迭代器与闭包</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch13-00-functional-features.md">ch13-00-functional-features.md</a>
<br>
commit 2bcb126815a381acc3d46b0d6fc382cb4c98fbc5</p>
</blockquote>
<p>Rust 的设计灵感来源于很多现存的语言和技术。其中一个显著的影响就是 <strong>函数式编程</strong>（<em>functional programming</em>）。函数式编程风格通常包含将函数作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等等。我们不会在这里讨论函数式编程是或不是什么的问题，而是展示 Rust 的一些在功能上与其他被认为是函数式语言类似的特性。</p>
<p>更具体的，我们将要涉及：</p>
<ul>
<li><strong>闭包</strong>（<em>Closures</em>），一个可以储存在变量里的类似函数的结构</li>
<li><strong>迭代器</strong>（<em>Iterators</em>），一种处理元素序列的方式</li>
<li>如何使用这些功能来改进第十二章的 I/O 项目。</li>
<li>这两个功能的性能。（<strong>剧透高能：</strong> 他们的速度超乎你的想象！）</li>
</ul>
<p>还有其它受函数式风格影响的 Rust 功能，比如模式匹配和枚举，这些已经在其他章节中讲到过了。掌握闭包和迭代器则是编写符合语言风格的高性能 Rust 代码的重要一环，所以我们将专门用一整章来讲解他们。</p>
<a class="header" href="print.html#a闭包可以捕获环境的匿名函数" id="a闭包可以捕获环境的匿名函数"><h2>闭包：可以捕获环境的匿名函数</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch13-01-closures.md">ch13-01-closures.md</a>
<br>
commit bdcba470e4a71d16242b1727bbf99b300c194c46</p>
</blockquote>
<p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。</p>
<a class="header" href="print.html#a使用闭包创建行为的抽象" id="a使用闭包创建行为的抽象"><h3>使用闭包创建行为的抽象</h3></a>
<p>让我们来看一个存储稍后要执行的闭包的示例。其间我们会讨论闭包的语法、类型推断和 trait。</p>
<p>考虑一下这个假想的情况：我们在一个通过 app 生成自定义健身计划的初创企业工作。其后端使用 Rust 编写，而生成健身计划的算法需要考虑很多不同的因素，比如用户的年龄、身体质量指数（Body Mass Index）、用户喜好、最近的健身活动和用户指定的强度系数。本例中实际的算法并不重要，重要的是这个计算只花费几秒钟。我们只希望在需要时调用算法，并且只希望调用一次，这样就不会让用户等得太久。</p>
<p>这里将通过调用 <code>simulated_expensive_calculation</code> 函数来模拟调用假象的算法，如示例 13-1 所示，它会打印出 <code>calculating slowly...</code>，等待两秒，并接着返回传递给它的数字：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<p><span class="caption">示例 13-1：一个用来代替假象计算的函数，它大约会执行两秒钟</span></p>
<p>接下来，<code>main</code> 函数中将会包含本例的健身 app 中的重要部分。这代表当用户请求健身计划时 app 会调用的代码。因为与 app 前端的交互与闭包的使用并不相关，所以我们将硬编码代表程序输入的值并打印输出。</p>
<p>所需的输入有这些：</p>
<ul>
<li><strong>一个来自用户的 intensity 数字</strong>，请求健身计划时指定，它代表用户喜好低强度还是高强度健身。</li>
<li><strong>一个随机数</strong>，其会在健身计划中生成变化。</li>
</ul>
<p>程序的输出将会是建议的锻炼计划。示例 13-2 展示了我们将要使用的 <code>main</code> 函数：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
# fn generate_workout(intensity: u32, random_number: u32) {}
</code></pre></pre>
<p><span class="caption">示例 13-2：<code>main</code> 函数包含了用于 <code>generate_workout</code> 函数的模拟用户输入和模拟随机数输入</span></p>
<p>处于简单考虑这里硬编码了 <code>simulated_user_specified_value</code> 变量的值为 10 和 <code>simulated_random_number</code> 变量的值为 7；一个实际的程序会从 app 前端获取强度系数并使用 <code>rand</code> crate 来生成随机数，正如第二章的猜猜看游戏所做的那样。<code>main</code> 函数使用模拟的输入值调用 <code>generate_workout</code> 函数：</p>
<p>现在有了执行上下文，让我们编写算法。示例 13-3 中的 <code>generate_workout</code> 函数包含本例中我们最关心的 app 业务逻辑。本例中余下的代码修改都将在这个函数中进行：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-3：程序的业务逻辑，它根据输入并调用 <code>simulated_expensive_calculation</code> 函数来打印出健身计划</span></p>
<p>示例 13-3 中的代码有多处慢计算函数的调用。第一个 <code>if</code> 块调用了 <code>simulated_expensive_calculation</code> 两次，外部 <code>else</code> 中的 <code>if</code> 完全没有调用它，第二个 <code>else</code> 中的代码调用了它一次。</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p><code>generate_workout</code> 函数的期望行为是首先检查用户需要低强度（由小于 25 的系数表示）锻炼还是高强度（25 或以上）锻炼。</p>
<p>低强度锻炼计划会根据由 <code>simulated_expensive_calculation</code> 函数所模拟的复杂算法建议一定数量的俯卧撑和仰卧起坐。</p>
<p>如果用户需要高强度锻炼，这里有一些额外的逻辑：如果 app 生成的随机数刚好是 3，app 相反会建议用户稍做休息并补充水分。如果不是，则用户会从复杂算法中得到数分钟跑步的高强度锻炼计划。</p>
<p>现在这份代码能够应对我们的需求了，但数据科学部门的同学告知我们将来会对调用 <code>simulated_expensive_calculation</code> 的方式做出一些改变。为了在要做这些改动的时候简化更新步骤，我们将重构代码来让它只调用 <code>simulated_expensive_calculation</code> 一次。同时还希望去掉目前多余的连续两次函数调用，并不希望在计算过程中增加任何其他此函数的调用。也就是说，我们不希望在完全无需其结果的情况调用函数，不过仍然希望只调用函数一次。</p>
<a class="header" href="print.html#a使用函数重构" id="a使用函数重构"><h4>使用函数重构</h4></a>
<p>有多种方法可以重构此程序。我们首先尝试的是将重复的 <code>simulated_expensive_calculation</code> 函数调用提取到一个变量中，如示例 13-4 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-4：将 <code>simulated_expensive_calculation</code> 调用提取到一个位置，并将结果储存在变量 <code>expensive_result</code> 中</span></p>
<p>这个修改统一了 <code>simulated_expensive_calculation</code> 调用并解决了第一个 <code>if</code> 块中不必要的两次调用函数的问题。不幸的是，现在所有的情况下都需要调用函数并等待结果，包括那个完全不需要这一结果的内部 <code>if</code> 块。</p>
<p>我们希望能够在程序的一个位置指定某些代码，并只在程序的某处实际需要结果的时候 <strong>执行</strong> 这些代码。这正是闭包的用武之地！</p>
<a class="header" href="print.html#a重构使用闭包储存代码" id="a重构使用闭包储存代码"><h4>重构使用闭包储存代码</h4></a>
<p>不同于总是在 <code>if</code> 块之前调用 <code>simulated_expensive_calculation</code> 函数并储存其结果，我们可以定义一个闭包并将其储存在变量中，如示例 13-5 所示。实际上可以选择将整个 <code>simulated_expensive_calculation</code> 函数体移动到这里引入的闭包中：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
# expensive_closure(5);
#}</code></pre></pre>
<p><span class="caption">示例 13-5：定义一个闭包并储存到变量 <code>expensive_closure</code> 中</span></p>
<p>闭包定义是 <code>expensive_closure</code> 赋值的 <code>=</code> 之后的部分。闭包的定义以一对竖线（<code>|</code>）开始，在竖线中指定闭包的参数；之所以选择这个语法是因为它与 Smalltalk 和 Ruby 的闭包定义类似。这个闭包有一个参数 <code>num</code>；如果有多于一个参数，可以使用逗号分隔，比如 <code>|param1, param2|</code>。</p>
<p>参数之后是存放闭包体的大括号 ———— 如果闭包体只有一行则大括号是可以省略的。大括号之后闭包的结尾，需要用于 <code>let</code> 语句的分号。闭包体的最后一行（<code>num</code>）返回的值将是调用闭包时返回的值，因为最后一行没有分号；正如函数体中的一样。</p>
<p>注意这个 <code>let</code> 语句意味着 <code>expensive_closure</code> 包含一个匿名函数的 <strong>定义</strong>，不是调用匿名函数的 <strong>返回值</strong>。回忆一下使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它；期望调用的代码现在储存在 <code>expensive_closure</code> 中。</p>
<p>定义了闭包之后，可以改变 <code>if</code> 块中的代码来调用闭包以执行代码并获取结果值。调用闭包类似于调用函数；指定存放闭包定义的变量名并后跟包含期望使用的参数的括号，如示例 13-6 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-6：调用定义的 <code>expensive_closure</code></span></p>
<p>现在耗时的计算只在一个地方被调用，并只会在需要结果的时候执行改代码。</p>
<p>然而，我们又重新引入了示例 13-3 中的问题：仍然在第一个 <code>if</code> 块中调用了闭包两次，这会调用慢计算两次并使用户多等待一倍的时间。可以通过在 <code>if</code> 块中创建一个本地变量存放闭包调用的结果来解决这个问题，不过正因为使用了闭包还有另一个解决方案。稍后会回到这个方案上；首先讨论一下为何闭包定义中和所涉及的 trait 中没有类型注解。</p>
<a class="header" href="print.html#a闭包类型推断和注解" id="a闭包类型推断和注解"><h3>闭包类型推断和注解</h3></a>
<p>闭包不要求像 <code>fn</code> 函数那样在参数和返回值上注明类型。函数中需要类型注解是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。</p>
<p>闭包通常很短并只与对应相对任意的场景较小的上下文中。在这些有限制的上下文中，编译器能可靠的推断参数和返回值的类型，类似于它是如何能够推断大部分变量的类型一样。</p>
<p>强制在这些小的匿名函数中注明类型是很恼人的，并且与编译器已知的信息存在大量的重复。</p>
<p>类似于变量，如果相比严格的必要性你更希望增加明确性并变得更啰嗦，可以选择增加类型注解；为示例 13-5 中定义的闭包标注类型将看起来像示例 13-7 中的定义：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
#}</code></pre></pre>
<p><span class="caption">示例 13-7：为闭包的参数和返回值增加可选的类型注解</span></p>
<p>有了类型注解闭包的语法就更类似函数了。如下是一个对其参数加一的函数的定义与拥有相同行为闭包语法的纵向对比。这里增加了一些空格来对齐相应部分。这展示了闭包语法如何类似于函数语法，除了使用竖线而不是括号以及几个可选的语法之外：</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>第一行展示了一个函数定义，而第二行展示了一个完整标注的闭包定义。第三行闭包定义中省略了类型注解，而第四行去掉了可选的大括号，因为闭包体只有一行。这些都是有效的闭包定义，并在调用时产生相同的行为。</p>
<p>闭包定义会为每个参数和返回值推断一个具体类型。例如，示例 13-8 中展示了仅仅将参数作为返回值的简短的闭包定义。除了作为示例的目的这个闭包并不是很实用。注意其定义并没有增加任何类型注解：如果尝试调用闭包两次，第一次使用 <code>String</code> 类型作为参数而第二次使用 <code>u32</code>，则会得到一个错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">示例 13-8：尝试调用一个被推断为两个不同类型的闭包</span></p>
<p>编译器给出如下错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<p>第一次使用 <code>String</code> 值调用 <code>example_closure</code> 时，编译器推断 <code>x</code> 和此闭包返回值的类型为 <code>String</code>。接着这些类型被锁定进闭包 <code>example_closure</code> 中，如果尝试对同一闭包使用不同类型则会得到类型错误。</p>
<a class="header" href="print.html#a使用带有泛型和-fn-trait-的闭包" id="a使用带有泛型和-fn-trait-的闭包"><h3>使用带有泛型和 <code>Fn</code> trait 的闭包</h3></a>
<p>回到我们的健身计划生成 app ，在示例 13-6 中的代码仍然调用了多于需要的慢计算闭包。解决这个问题的一个方法是在全部代码中的每一个需要多个慢计算闭包结果的地方，可以将结果保存进变量以供复用，这样就可以使用变量而不是再次调用闭包。但是这样就会有很多重复的保存结果变量的地方。</p>
<p>幸运的是，还有另一个可用的方案。可以创建一个存放闭包和调用闭包结果的结构体。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 <em>memoization</em> 或 <em>lazy evaluation</em>。</p>
<p>为了让结构体存放闭包，我们需要能够指定闭包的类型，因为结构体定义需要知道其每一个字段的类型。每一个闭包实例有其自己独有的匿名类型：也就是说，即便两个闭包有着相同的签名，他们的类型仍然可以被认为是不同。为了定义使用闭包的结构体、枚举或函数参数，需要像第十章讨论的那样使用泛型和 trait bound。</p>
<p><code>Fn</code> 系列 trait 由标准库提供。所有的闭包都实现了 trait <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 中的一个。在“闭包会捕获其环境”部分捕获环境部分我们会讨论这些 trait 的区别；在这个例子中可以使用 <code>Fn</code> trait。</p>
<p>为了满足 <code>Fn</code> trait bound 我们增加了代表闭包所必须的参数和返回值类型的类型。在这个例子中，闭包有一个 <code>u32</code> 的参数并返回一个 <code>u32</code>，这样所指定的 trait bound 就是 <code>Fn(u32) -&gt; u32</code>。</p>
<p>示例 13-9 展示了存放了闭包和一个 Option 结果值的 <code>Cacher</code> 结构体的定义：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
#}</code></pre></pre>
<p><span class="caption">示例 13-9：定义一个 <code>Cacher</code> 结构体来在 <code>calculation</code> 中存放闭包并在 <code>value</code> 中存放 Option 值</span></p>
<p>结构体 <code>Cacher</code> 有一个泛型  <code>T</code> 的字段 <code>calculation</code>。<code>T</code> 的 trait bound 指定了 <code>T</code> 是一个使用 <code>Fn</code> 的闭包。任何我们希望储存到 <code>Cacher</code> 实例的 <code>calculation</code> 字段的闭包必须有一个 <code>u32</code> 参数（由 <code>Fn</code> 之后的括号的内容指定）并必须返回一个 <code>u32</code>（由 <code>-&gt;</code> 之后的内容）。</p>
<blockquote>
<p>注意：函数也都实现了这三个 <code>Fn</code> trait。如果不需要捕获环境中的值，则在需要实现 <code>Fn</code> trait 是可以使用函数而不是闭包。</p>
</blockquote>
<p><code>value</code> 是 <code>Option&lt;i32&gt;</code> 类型的。在执行闭包之前，<code>value</code> 将是 <code>None</code>。如果使用 <code>Cacher</code> 的代码请求闭包的结果，这时会执行闭包并将结果储存在 <code>value</code> 字段的 <code>Some</code> 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 <code>Some</code> 成员中的结果。</p>
<p>刚才讨论的有关 <code>value</code> 字段逻辑定义于示例 13-10：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-10：<code>Cacher</code> 的缓存逻辑</span></p>
<p><code>Cacher</code> 结构体的字段是私有的，因为我们希望 <code>Cacher</code> 管理这些值而不是任由调用代码潜在的直接改变他们。</p>
<p><code>Cacher::new</code> 函数获取一个泛型参数 <code>T</code>，它定义于 <code>impl</code> 块上下文中并与 <code>Cacher</code>  结构体有着相同的 trait bound。<code>Cacher::new</code> 返回一个在 <code>calculation</code> 字段中存放了指定闭包和在 <code>value</code> 字段中存放了 <code>None</code> 值的 <code>Cacher</code> 实例，因为我们还未执行闭包。</p>
<p>当调用代码需要闭包的执行结果时，不同于直接调用闭包，它会调用 <code>value</code> 方法。这个方法会检查 <code>self.value</code> 是否已经有了一个 <code>Some</code> 的结果值；如果有，它返回 <code>Some</code> 中的值并不会再次执行闭包。</p>
<p>如果 <code>self.value</code> 是 <code>None</code>，则会调用 <code>self.calculation</code> 中储存的闭包，将结果保存到 <code>self.value</code> 以便将来使用，并同时返回结果值。</p>
<p>示例 13-11 展示了如何在示例 13-6 的 <code>generate_workout</code> 函数中利用 <code>Cacher</code> 结构体：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: u32) -&gt; u32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-11：在 <code>generate_workout</code> 函数中利用 <code>Cacher</code> 结构体来抽象出缓存逻辑</span></p>
<p>不同于直接将闭包保存进一个变量，我们保存一个新的 <code>Cacher</code> 实例来存放闭包。接着，在每一个需要结果的地方，调用 <code>Cacher</code> 实例的 <code>value</code> 方法。可以调用 <code>value</code> 方法任意多次，或者一次也不调用，而慢计算最多只会运行一次。</p>
<p>尝试使用示例 13-2 中的 <code>main</code> 函数来运行这段程序，并改变 <code>simulated_user_specified_value</code> 和 <code>simulated_random_number</code> 变量中的值来验证在所有情况下在多个 <code>if</code> 和 <code>else</code> 块中，闭包打印的 <code>calculating slowly...</code> 只会在需要时出现并只会出现一次。<code>Cacher</code> 负责确保不会调用超过所需的慢计算所需的逻辑，这样 <code>generate_workout</code> 就可以专注业务逻辑了。</p>
<a class="header" href="print.html#cacher-实现的限制" id="cacher-实现的限制"><h3><code>Cacher</code> 实现的限制</h3></a>
<p>值缓存是一种更加广泛的实用行为，我们可能希望在代码中的其他闭包中也使用他们。然而，目前 <code>Cacher</code> 的实现存在一些小问题，这使得在不同上下文中复用变得很困难。</p>
<p>第一个问题是 <code>Cacher</code> 实例假设对于 <code>value</code> 方法的任何 <code>arg</code> 参数值总是会返回相同的值。也就是说，这个 <code>Cacher</code> 的测试会失败：</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>这个测试使用返回传递给它的值的闭包创建了一个新的 <code>Cacher</code> 实例。使用为 1 的 <code>arg</code> 和为 2 的 <code>arg</code> 调用 <code>Cacher</code> 实例的 <code>value</code> 方法，同时我们期望使用为 2 的 <code>arg</code> 调用 <code>value</code> 会返回 2。</p>
<p>使用示例 13-9 和示例 13-10 的 <code>Cacher</code> 实现运行测试，它会在 <code>assert_eq!</code> 失败并显示如下信息：</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<p>这里的问题是第一次使用 1 调用 <code>c.value</code>，<code>Cacher</code> 实例将 <code>Some(1)</code> 保存进 <code>self.value</code>。在这之后，无论传递什么值调用 <code>value</code>，它总是会返回 1。</p>
<p>尝试修改 <code>Cacher</code> 存放一个哈希 map 而不是单独一个值。哈希 map 的 key 将是传递进来的 <code>arg</code> 值，而 value 则是对应 key 调用闭包的结果值。相比之前检查 <code>self.value</code> 直接是 <code>Some</code> 还是 <code>None</code> 值，现在 <code>value</code> 会在哈希 map 中寻找 <code>arg</code>，如果存在就返回它。如果不存在，<code>Cacher</code> 会调用闭包并将结果值保存在哈希 map 对应 <code>arg</code> 值的位置。</p>
<p>当前 <code>Cacher</code> 实现的另一个问题是它的应用被限制为只接受获取一个 <code>u32</code> 值并返回一个 <code>u32</code> 值的闭包。比如说，我们可能需要能够缓存一个获取字符串 slice 并返回 <code>usize</code> 值的闭包的结果。请尝试引入更多泛型参数来增加 <code>Cacher</code> 功能的灵活性。</p>
<a class="header" href="print.html#a闭包会捕获其环境" id="a闭包会捕获其环境"><h3>闭包会捕获其环境</h3></a>
<p>在健身计划生成器的例子中，我们只将闭包作为内联匿名函数来使用。不过闭包还有另一个函数所没有的功能：他们可以捕获其环境并访问其被定义的作用域的变量。</p>
<p>示例 13-12 有一个储存在 <code>equal_to_x</code> 变量中闭包的例子，它使用了闭包环境中的变量 <code>x</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">示例 13-12：一个引用了其周围作用域中变量的闭包示例</span></p>
<p>这里，即便 <code>x</code> 并不是 <code>equal_to_x</code> 的一个参数，<code>equal_to_x</code> 闭包也被允许使用变量 <code>x</code>，因为它与 <code>equal_to_x</code> 定义于相同的作用域。</p>
<p>函数则不能做到同样的事，如果尝试如下例子，它并不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>这会得到一个错误：</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>编译器甚至会提示我们这只能用于闭包！</p>
<p>当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用。这会使用内存并产生额外的开销，当执行不会捕获环境的更通用的代码场景中我们不希望有这些开销。因为函数从未允许捕获环境，定义和使用函数也就从不会有这些额外开销。</p>
<p>闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。这三种捕获值的方式被编码为如下三个 <code>Fn</code> trait：</p>
<ul>
<li><code>FnOnce</code> 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境</strong>，<em>environment</em>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li>
<li><code>FnMut</code> 获取可变的借用值所以可以改变其环境</li>
<li><code>Fn</code> 从其环境获取不可变的借用值</li>
</ul>
<p>当创建一个闭包时，Rust 根据其如何使用环境中变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 <code>FnOnce</code> 。那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 <code>FnMut</code> ，而不需要对被捕获的变量进行可变访问的闭包则也实现了 <code>Fn</code> 。 在示例 13-12 中，<code>equal_to_x</code> 闭包不可变的借用了 <code>x</code>（所以 <code>equal_to_x</code> 具有 <code>Fn</code> trait），因为闭包体只需要读取 <code>x</code> 的值。</p>
<p>如果你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 <code>move</code> 关键字。这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。</p>
<p>第十六章讨论并发时会展示更多 <code>move</code> 闭包的例子，不过现在这里修改了示例 13-12 中的代码（作为演示），在闭包定义中增加 <code>move</code> 关键字并使用 vector 代替整型，因为整型可以被拷贝而不是移动；注意这些代码还不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>这个例子并不能编译：</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
</code></pre>
<p><code>x</code> 被移动进了闭包，因为闭包使用 <code>move</code> 关键字定义。接着闭包获取了 <code>x</code> 的所有权，同时 <code>main</code> 就不再允许在 <code>println!</code> 语句中使用 <code>x</code> 了。去掉 <code>println!</code> 即可修复问题。</p>
<p>大部分需要指定一个 <code>Fn</code> trait bound 的时候，可以从 <code>Fn</code> 开始，而编译器会根据闭包体中的情况告诉你是否需要 <code>FnMut</code> 或 <code>FnOnce</code>。</p>
<p>为了展示闭包作为函数参数时捕获其环境的作用，让我们移动到下一个主题：迭代器。</p>
<a class="header" href="print.html#a使用迭代器处理元素序列" id="a使用迭代器处理元素序列"><h2>使用迭代器处理元素序列</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch13-02-iterators.md">ch13-02-iterators.md</a>
<br>
commit ceb31210263d49994bbf09456a35a135da690f24</p>
</blockquote>
<p>迭代器模式允许你对一个项的序列进行某些处理。<strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。</p>
<p>在 Rust 中，迭代器是 <strong>惰性的</strong>（<em>lazy</em>），这意味着直到调用方法消费迭代器之前它都不会有效果。例如，示例 13-13 中的代码通过调用定义于 <code>Vec</code> 上的 <code>iter</code> 方法在一个 vector <code>v1</code> 上创建了一个迭代器。这段代码本身没有任何用处：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<p><span class="caption">示例 13-13：创建一个迭代器</span></p>
<p>创建迭代器之后，可以选择用多种方式利用它。在示例 3-4 中，我们使用迭代器和 <code>for</code> 循环在每一个项上执行了一些代码，不过直到现在我们掩盖了 <code>iter</code> 调用做了什么。</p>
<p>示例 13-14 中的例子将迭代器的创建和 <code>for</code> 循环中的使用分开。迭代器被储存在 <code>v1_iter</code> 变量中，而这时没有进行迭代。一旦 <code>for</code> 循环开始使用 <code>v1_iter</code>，接着迭代器中的每一个元素被用于循环的一次迭代，这会打印出其每一个值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<p><span class="caption">示例 13-14：在一个 <code>for</code> 循环中使用迭代器</span></p>
<p>在标准库中没有提供迭代器的语言中，我们可能会使用一个从 0 开始的索引变量，使用这个变量索引 vector 中的值，并循环增加其值直到达到 vector 的元素数量。</p>
<p>迭代器为我们处理了所有这些逻辑，这减少了重复代码并潜在的消除了混乱。另外，迭代器的实现方式提供了对多种不同的序列使用相同逻辑的灵活性，而不仅仅是像 vector 这样可索引的数据结构.让我们看看迭代器是如何做到这些的。</p>
<a class="header" href="print.html#iterator-trait-和-next-方法" id="iterator-trait-和-next-方法"><h3><code>Iterator</code> trait 和 <code>next</code> 方法</h3></a>
<p>迭代器都实现了一个叫做 <code>Iterator</code> 的定义于标准库的 trait。这个 trait 的定义看起来像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
#}</code></pre></pre>
<p>注意这里有一下我们还未讲到的新语法：<code>type Item</code> 和 <code>Self::Item</code>，他们定义了 trait 的 <strong>关联类型</strong>（<em>associated type</em>）。第十九章会深入讲解关联类型，不过现在只需知道这段代码表明实现 <code>Iterator</code> trait 要求同时定义一个 <code>Item</code> 类型，这个 <code>Item</code> 类型被用作 <code>next</code> 方法的返回值类型。换句话说，<code>Item</code> 类型将是迭代器返回元素的类型。</p>
<p><code>next</code> 是 <code>Iterator</code> 实现者被要求定义的唯一方法。<code>next</code> 一次返回迭代器中的一个项，封装在 <code>Some</code> 中，当迭代器结束时，它返回 <code>None</code>。如果你希望的话可以直接调用迭代器的 <code>next</code> 方法；示例 13-15 有一个测试展示了重复调用由 vector 创建的迭代器的 <code>next</code> 方法所得到的值：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">示例 13-15：在迭代器上（直接）调用 <code>next</code> 方法</span></p>
<p>注意 <code>v1_iter</code> 需要是可变的：在迭代器上调用 <code>next</code> 方法改变了迭代器中用来记录序列位置的状态。换句话说，代码 <strong>消费</strong>（consume）了，或使用了迭代器。每一个 <code>next</code> 调用都会从迭代器中消费一个项。使用 <code>for</code> 循环时无需使 <code>v1_iter</code> 可变因为 <code>for</code> 循环会获取 <code>v1_iter</code> 的所有权并在后台使 <code>v1_iter</code> 可变。</p>
<p>另外需要注意到从 <code>next</code> 调用中得到的值是 vector 的不可变引用。<code>iter</code> 方法生成一个不可变引用的迭代器。如果我们需要一个获取 <code>v1</code> 所有权并返回拥有所有权的迭代器，则可以调用 <code>into_iter</code> 而不是 <code>iter</code>。类似的，如果我们希望迭代可变引用，则可以调用 <code>iter_mut</code> 而不是 <code>iter</code>。</p>
<a class="header" href="print.html#a消费迭代器的方法" id="a消费迭代器的方法"><h3>消费迭代器的方法</h3></a>
<p><code>Iterator</code> trait 有一系列不同的由标准库提供默认实现的方法；你可以在 <code>Iterator</code> trait 的标准库 API 文档中找到所有这些方法。一些方法在其定义中调用了 <code>next</code> 方法，这也就是为什么在实现 <code>Iterator</code> trait 时要求实现 <code>next</code> 方法的原因。</p>
<p>这些调用 <code>next</code> 方法的方法被称为 <strong>消费适配器</strong>（<em>consuming adaptors</em>），因为调用他们会消耗迭代器。一个消费适配器的例子是 <code>sum</code> 方法。这个方法获取迭代器的所有权并反复调用 <code>next</code> 来遍历迭代器，因而会消费迭代器。当其遍历每一个项时，它将每一个项加总到一个总和并在迭代完成时返回总和。示例 13-16 有一个展示 <code>sum</code> 方法使用的测试：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<p><span class="caption">示例 13-16：调用 <code>sum</code> 方法获取迭代器所有项的总和</span></p>
<p>调用 <code>sum</code> 之后不再允许使用 <code>v1_iter</code> 因为调用 <code>sum</code> 时它会获取迭代器的所有权。</p>
<a class="header" href="print.html#a产生其他迭代器的方法" id="a产生其他迭代器的方法"><h3>产生其他迭代器的方法</h3></a>
<p><code>Iterator</code> trait 中定义了另一类方法，被称为 <strong>迭代器适配器</strong>（<em>iterator adaptors</em>），他们允许我们将当前迭代器变为不同类型的迭代器。可以链式调用多个迭代器适配器。不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。</p>
<p>示例 13-17 展示了一个调用迭代器适配器方法 <code>map</code> 的例子，该 <code>map</code> 方法使用闭包来调用每个元素以生成新的迭代器。 这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。不过这些代码会产生一个警告：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<p><span class="caption">示例 13-17：调用迭代器适配器 <code>map</code> 来创建一个新迭代器</span></p>
<p>得到的警告是：</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>示例 13-17 中的代码实际上并没有做任何事；所指定的闭包从未被调用过。警告提醒了我们为什么：迭代器适配器是惰性的，而这里我们需要消费迭代器。</p>
<p>为了修复这个警告并消费迭代器获取有用的结果，我们将使用第十二章简要讲到的 <code>collect</code> 方法。这个方法消费迭代器并将结果收集到一个数据结构中。</p>
<p>在示例 13-18 中，我们将遍历由 <code>map</code> 调用生成的迭代器的结果收集到一个 vector 中，它将会含有原始 vector 中每个元素加一的结果：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<p><span class="caption">示例 13-18：调用 <code>map</code> 方法创建一个新迭代器，接着调用 <code>collect</code> 方法消费新迭代器并创建一个 vector</span></p>
<p>因为 <code>map</code> 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作。这是一个展示如何使用闭包来自定义行为同时又复用 <code>Iterator</code> trait 提供的迭代行为的绝佳例子。</p>
<a class="header" href="print.html#a使用闭包获取环境" id="a使用闭包获取环境"><h3>使用闭包获取环境</h3></a>
<p>现在我们介绍了迭代器，让我们展示一个通过使用 <code>filter</code> 迭代器适配器和捕获环境的闭包的常规用例。迭代器的 <code>filter</code> 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。如果闭包返回 <code>true</code>，其值将会包含在 <code>filter</code> 提供的新迭代器中。如果闭包返回 <code>false</code>，其值不会包含在结果迭代器中。</p>
<p>示例 13-19 展示了使用 <code>filter</code> 和一个捕获环境中变量 <code>shoe_size</code> 的闭包，这样闭包就可以遍历一个 <code>Shoe</code> 结构体集合以便只返回指定大小的鞋子：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<p><span class="caption">示例 13-19：使用 <code>filter</code> 方法和一个捕获 <code>shoe_size</code> 的闭包</span></p>
<p><code>shoes_in_my_size</code> 函数获取一个鞋子 vector 的所有权和一个鞋子大小作为参数。它返回一个只包含指定大小鞋子的 vector。</p>
<p>在 <code>shoes_in_my_size</code> 函数体中调用了 <code>into_iter</code> 来创建一个获取 vector 所有权的迭代器。接着调用 <code>filter</code> 将这个迭代器适配成只含有闭包返回 <code>true</code> 元素的新迭代器。</p>
<p>闭包从环境中捕获了 <code>shoe_size</code> 变量并使用其值与每一只鞋的大小作比较，只保留指定大小的鞋子。最终，调用 <code>collect</code> 将迭代器适配器返回的值收集进一个 vector 并返回。</p>
<p>这个测试展示当调用 <code>shoes_in_my_size</code> 时，我们只会得到与指定值相同大小的鞋子。</p>
<a class="header" href="print.html#a实现-iterator-trait-来创建自定义迭代器" id="a实现-iterator-trait-来创建自定义迭代器"><h3>实现 <code>Iterator</code> trait 来创建自定义迭代器</h3></a>
<p>我们已经展示了可以通过在 vector 上调用 <code>iter</code>、<code>into_iter</code> 或 <code>iter_mut</code> 来创建一个迭代器。也可以用标准库中其他的集合类型创建迭代器，比如哈希 map。另外，可以实现 <code>Iterator</code> trait 来创建任何我们希望的迭代器。正如之前提到的，定义中唯一要求提供的方法就是 <code>next</code> 方法。一旦定义了它，就可以使用所有其他由 <code>Iterator</code> trait 提供的拥有默认实现的方法来创建自定义迭代器了！</p>
<p>作为展示，让我们创建一个只会从 1 数到 5 的迭代器。首先，创建一个结构体来存放一些值，接着实现 <code>Iterator</code> trait 将这个结构体放入迭代器中并在此实现中使用其值。</p>
<p>示例 13-20 有一个 <code>Counter</code> 结构体定义和一个创建 <code>Counter</code> 实例的关联函数 <code>new</code>：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-20：定义 <code>Counter</code> 结构体和一个创建 <code>count</code> 初值为 0 的 <code>Counter</code> 实例的 <code>new</code> 函数</span></p>
<p><code>Counter</code> 结构体有一个字段 <code>count</code>。这个字段存放一个 <code>u32</code> 值，它会记录处理 1 到 5 的迭代过程中的位置。<code>count</code> 是私有的因为我们希望 <code>Counter</code> 的实现来管理这个值。<code>new</code> 函数通过总是从为 0 的 <code>count</code> 字段开始新实例来确保我们需要的行为。</p>
<p>接下来将为 <code>Counter</code> 类型实现 <code>Iterator</code> trait，通过定义 <code>next</code> 方法来指定使用迭代器时的行为，如示例 13-21 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-21：在 <code>Counter</code> 结构体上实现 <code>Iterator</code> trait</span></p>
<p>这里将迭代器的关联类型 <code>Item</code> 设置为 <code>u32</code>，意味着迭代器会返回 <code>u32</code> 值集合。再一次，这里仍无需担心关联类型，第十九章会讲到。</p>
<p>我们希望迭代器对其内部状态加一，这也就是为何将 <code>count</code> 初始化为 0：我们希望迭代器首先返回 1。如果 <code>count</code> 值小于 6，<code>next</code> 会返回封装在 <code>Some</code> 中的当前值，不过如果 <code>count</code> 大于或等于 6，迭代器会返回 <code>None</code>。</p>
<a class="header" href="print.html#a使用-counter-迭代器的-next-方法" id="a使用-counter-迭代器的-next-方法"><h4>使用 <code>Counter</code> 迭代器的 <code>next</code> 方法</h4></a>
<p>一旦实现了 <code>Iterator</code> trait，我们就有了一个迭代器！示例 13-22 展示了一个测试用来演示使用 <code>Counter</code> 结构体的迭代器功能，通过直接调用 <code>next</code> 方法，正如示例 13-15 中从 vector 创建的迭代器那样：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">示例 13-22：测试 <code>next</code> 方法实现的功能</span></p>
<p>这个测试在 <code>counter</code> 变量中新建了一个 <code>Counter</code> 实例并接着反复调用 <code>next</code> 方法，来验证我们实现的行为符合这个迭代器返回从 1 到 5 的值的预期。</p>
<a class="header" href="print.html#a使用自定义迭代器中其他-iterator-trait-方法" id="a使用自定义迭代器中其他-iterator-trait-方法"><h4>使用自定义迭代器中其他 <code>Iterator</code> trait 方法</h4></a>
<p>通过定义 <code>next</code> 方法实现 <code>Iterator</code> trait，我们现在就可以使用任何标准库定义的拥有默认实现的 <code>Iterator</code> trait 方法了，因为他们都使用了 <code>next</code> 方法的功能。</p>
<p>例如，出于某种原因我们希望获取 <code>Counter</code> 实例产生的值，将这些值与另一个 <code>Counter</code> 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加，这可以如示例 13-23 中的测试这样做：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<p><span class="caption">示例 13-23：使用自定义的 <code>Counter</code> 迭代器的多种方法</span></p>
<p>注意 <code>zip</code> 只产生四对值；理论上第五对值 <code>(5, None)</code> 从未被产生，因为 <code>zip</code> 在任一输入迭代器返回 <code>None</code> 时也返回 <code>None</code>。</p>
<p>所有这些方法调用都是可能的，因为我们通过指定 <code>next</code> 如何工作来实现 <code>Iterator</code> trait 而标准库则提供其他调用 <code>next</code> 的默认方法实现。</p>
<a class="header" href="print.html#a改进-io-项目" id="a改进-io-项目"><h2>改进 I/O 项目</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch13-03-improving-our-io-project.md">ch13-03-improving-our-io-project.md</a>
<br>
commit 2bcb126815a381acc3d46b0d6fc382cb4c98fbc5</p>
</blockquote>
<p>有了这些关于迭代器的新知识，我们可以使用迭代器来改进第十二章中 I/O 项目的实现来使得代码更简洁明了。让我们看看迭代器如何能够改进 <code>Config::new</code> 函数和 <code>search</code> 函数的实现。</p>
<a class="header" href="print.html#a使用迭代器并去掉-clone" id="a使用迭代器并去掉-clone"><h3>使用迭代器并去掉 <code>clone</code></h3></a>
<p>在示例 12-6 中，我们增加了一些代码获取一个 <code>String</code> slice 并创建一个 <code>Config</code> 结构体的实例，他们索引 slice 中的值并克隆这些值以便 <code>Config</code> 结构体可以拥有这些值。在示例 13-24 中原原本本的重现了第十二章结尾示例 12-23 中 <code>Config::new</code> 函数的实现：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<p><span class="caption">示例 13-24：重现第十二章结尾的 <code>Config::new</code> 函数</span></p>
<p>这时可以不必担心低效的 <code>clone</code> 调用了，因为将来可以去掉他们。好吧，就是现在！</p>
<p>起初这里需要 <code>clone</code> 的原因是参数 <code>args</code> 中有一个 <code>String</code> 元素的 slice，而 <code>new</code> 函数并不拥有 <code>args</code>。为了能够返回 <code>Config</code> 实例的所有权，我们需要克隆 <code>Config</code> 中字段 <code>query</code> 和 <code>filename</code> 的值，这样 <code>Config</code> 实例就能拥有这些值。</p>
<p>通过迭代器的新知识，我们可以将 <code>new</code> 函数改为获取一个有所有权的迭代器作为参数而不是借用 slice。我们将使用迭代器功能之前检查 slice 长度和索引特定位置的代码。这会明确 <code>Config::new</code> 的工作因为迭代器会负责访问这些值。</p>
<p>一旦 <code>Config::new</code> 获取了迭代器的所有权并不再使用借用的索引操作，就可以将迭代器中的 <code>String</code> 值移动到 <code>Config</code> 中，而不是调用 <code>clone</code> 分配新的空间。</p>
<a class="header" href="print.html#a直接使用-envargs-返回的迭代器" id="a直接使用-envargs-返回的迭代器"><h4>直接使用 <code>env::args</code> 返回的迭代器</h4></a>
<p>打开 I/O 项目的 <em>src/main.rs</em> 文件，它看起来应该像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p>我们会修改第十二章结尾示例 12-24 中的 <code>main</code> 函数的开头为示例 13-25 中的代码。直到同时更新 <code>Config::new</code> 这些代码还不能编译：</p>
<p>将他们改为如示例 13-25 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p><span class="caption">示例 13-25：将 <code>env::args</code> 的返回值传递给 <code>Config::new</code></span></p>
<p><code>env::args</code> 函数返回一个迭代器！不同于将迭代器的值收集到一个 vector 中接着传递一个 slice 给 <code>Config::new</code>，现在我们直接将 <code>env::args</code> 返回的迭代器的所有权传递给 <code>Config::new</code>。</p>
<p>接下来需要更新 <code>Config::new</code> 的定义。在 I/O 项目的 <em>src/lib.rs</em> 中，将 <code>Config::new</code> 的签名改为如示例 13-26 所示。这仍然不能编译因为我们还需更新函数体：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<p><span class="caption">示例 13-26：更新 <code>Config::new</code> 的签名来接受一个迭代器</span></p>
<p><code>env::args</code> 函数的标准库文档展示了其返回的迭代器类型是 <code>std::env::Args</code>。需要更新 <code>Config::new</code> 函数的签名中 <code>args</code> 参数的类型为 <code>std::env::Args</code> 而不是 <code>&amp;[String]</code>。因为这里需要获取 <code>args</code> 的所有权且通过迭代改变 <code>args</code>，我们可以在 <code>args</code> 参数前指定 <code>mut</code> 关键字使其可变。</p>
<a class="header" href="print.html#a使用-iterator-trait-方法代替索引" id="a使用-iterator-trait-方法代替索引"><h4>使用 <code>Iterator</code> trait 方法代替索引</h4></a>
<p>接下来修复 <code>Config::new</code> 的函数体。标准库文档也提到了 <code>std::env::Args</code> 实现了 <code>Iterator</code> trait，所以可以在其上调用 <code>next</code> 方法！示例 13-27 更新了示例 12-23 中的代码为使用 <code>next</code> 方法：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::env;
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 13-27：修改 <code>Config::new</code> 的函数体为使用迭代器方法</span></p>
<p>请记住 <code>env::args</code> 返回值的第一个值是程序的名称。我们希望忽略它并获取下一个值，所以首先调用 <code>next</code> 并不对返回值做任何操作。之后对希望放入 <code>Config</code> 中字段 <code>query</code> 调用 <code>next</code>。如果 <code>next</code> 返回 <code>Some</code>，使用 <code>match</code> 来提取其值。如果它返回 <code>None</code>，则意味着没有提供足够的参数并通过 <code>Err</code> 值提早返回。对 <code>filename</code> 值进行同样的操作。</p>
<a class="header" href="print.html#a使用迭代器适配器来使代码更简明" id="a使用迭代器适配器来使代码更简明"><h3>使用迭代器适配器来使代码更简明</h3></a>
<p>I/O 项目中其他可以利用迭代器优势的地方位于 <code>search</code> 函数，在示例 13-28 中重现了第十二章结尾示例 12-19 中此函数的定义：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">示例 13-28：第十二章结尾 <code>search</code> 函数的定义</span></p>
<p>可以通过使用迭代器适配器方法来编写更短的代码。这也避免了一个可变的中间 <code>results</code> vector 的使用。函数式编程风格倾向于最小化可变状态的数量来使代码更简洁。去掉可变状态可能会使得将来进行并行搜索的增强变得更容易，因为我们不必管理 <code>results</code> vector 的并发访问。示例 13-29 展示了该变化：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">示例 13-29：在 <code>search</code> 函数实现中使用迭代器适配器</span></p>
<p>回忆 <code>search</code> 函数的目的是返回所有 <code>contents</code> 中包含 <code>query</code> 的行。类似于示例 13-19 中的 <code>filter</code> 例子，可以使用 <code>filter</code> 适配器只保留 <code>line.contains(query)</code> 为真的那些行。接着使用 <code>collect</code> 将匹配行收集到另一个 vector 中。这样就容易多了！请随意对 <code>search_case_insensitive</code> 函数做出同样的使用迭代器方法的修改。</p>
<p>接下来的逻辑问题就是在代码中应该选择哪种风格：示例 13-28 中的原始实现，或者是示例 13-29 中使用迭代器的版本。大部分 Rust 程序员倾向于使用迭代器风格。开始这有点难以理解，不过一旦你对不同迭代器的工作方式有了感觉之后，迭代器可能会更容易理解。相比摆弄不同的循环并创建新 vector，（迭代器）代码则更关注循环的目的。这抽象出了那些老生常谈的代码，这样就更容易看清代码所特有的概念，比如迭代器中每个元素必须面对的过滤条件。</p>
<p>不过这两种实现真的完全等同吗？直觉上的假设是更底层的循环会更快一些。让我们聊聊性能吧。</p>
<a class="header" href="print.html#a性能对比循环-vs-迭代器" id="a性能对比循环-vs-迭代器"><h2>性能对比：循环 VS 迭代器</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch13-04-performance.md">ch13-04-performance.md</a>
<br>
commit 2bcb126815a381acc3d46b0d6fc382cb4c98fbc5</p>
</blockquote>
<p>为了决定使用哪个实现，我们需要知道哪个版本的 <code>search</code> 函数更快：直接使用 <code>for</code> 循环的版本还是使用迭代器的版本。</p>
<p>我们运行了一个性能测试，通过将阿瑟·柯南·道尔的“福尔摩斯探案集”的全部内容加载进 <code>String</code> 并寻找其中的单词 “the”。如下是 <code>for</code> 循环版本和迭代器版本的 <code>search</code> 函数的性能测试结果：</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>结果迭代器版本还要稍微快一点！这里我们将不会查看性能测试的代码，我们的目的并不是为了证明他们是完全等同的，而是得出一个怎样比较这两种实现方式性能的基本思路。</p>
<p>对于一个更全面的性能测试，将会检查不同长度的文本、不同的搜索单词、不同长度的单词和所有其他的可变情况。这里所要表达的是：迭代器，作为一个高级的抽象，被编译成了与手写的底层代码大体一致性能代码。迭代器是 Rust 的 <strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会强加运行时开销，它与本贾尼·斯特劳斯特卢普，C++ 的设计和实现者所定义的 <strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p>
<ul>
<li>Bjarne Stroustrup &quot;Foundations of C++&quot;</li>
</ul>
<p>从整体来说，C++ 的实现遵循了零开销原则：你不需要的，无需为他们买单。更有甚者的是：你需要的时候，也不可能找到其他更好的代码了。</p>
<ul>
<li>本贾尼·斯特劳斯特卢普 &quot;Foundations of C++&quot;</li>
</ul>
</blockquote>
<p>作为另一个例子，这里有一些取自于音频解码器的代码。解码算法使用线性预测数学运算（linear prediction mathematical operation）来根据之前样本的线性函数预测将来的值。这些代码使用迭代器链来对作用域中的三个变量进行了某种数学计算：一个叫 <code>buffer</code> 的数据 slice、一个有 12 个元素的数组 <code>coefficients</code>、和一个代表位移位数的 <code>qlp_shift</code>。例子中声明了这些变量但并没有提供任何值；虽然这些代码在其上下文之外没有什么意义，不过仍是一个简明的现实中的例子，来展示 Rust 如何将高级概念转换为底层代码：</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>为了计算 <code>prediction</code> 的值，这些代码遍历了 <code>coefficients</code> 中的 12 个值，使用 <code>zip</code> 方法将系数与 <code>buffer</code> 的前 12 个值组合在一起。接着将每一对值相乘，再将所有结果相加，然后将总和右移 <code>qlp_shift</code> 位。</p>
<p>像音频解码器这样的程序通常最看重计算的性能。这里，我们创建了一个迭代器，使用了两个适配器，接着消费了其值。Rust 代码将会被编译为什么样的汇编代码呢？好吧，在编写本书的这个时候，它被编译成与手写的相同的汇编代码。遍历 <code>coefficients</code> 的值完全用不到循环：Rust 知道这里会迭代 12 次，所以它“展开”（unroll）了循环。展开是一种移除循环控制代码的开销并替换为每个迭代中的重复代码的优化。</p>
<p>所有的系数都被储存在了寄存器中，这意味着访问他们非常快。这里也没有运行时数组访问边界检查。所有这些 Rust 能够提供的优化使得结果代码极为高效。现在知道这些了，请放心大胆的使用迭代器和闭包吧！他们使得代码看起来更高级，但并不为此引入运行时性能损失。</p>
<a class="header" href="print.html#a总结-12" id="a总结-12"><h2>总结</h2></a>
<p>闭包和迭代器是 Rust 受函数式编程语言观念所启发的功能。他们对 Rust 以底层的性能来明确的表达高级概念的能力有很大贡献。闭包和迭代器的实现达到了不影响运行时性能的程度。这正是 Rust 竭力提供零成本抽象的目标的一部分。</p>
<p>现在我们改进了我们 I/O 项目的（代码）表现力，让我们看一看更多 <code>cargo</code> 的功能，他们将帮助我们准备好将项目分享给世界。</p>
<a class="header" href="print.html#a进一步认识-cargo-和-cratesio" id="a进一步认识-cargo-和-cratesio"><h1>进一步认识 Cargo 和 Crates.io</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch14-00-more-about-cargo.md">ch14-00-more-about-cargo.md</a>
<br>
commit ff93f82ff63ade5a352d9ccc430945d4ec804cdf</p>
</blockquote>
<p>目前为止我们只使用过 Cargo 构建、运行和测试代码的最基本功能，不过它还可以做到更多。这里我们将了解一些 Cargo 其他更为高级的功能，他们将展示如何：</p>
<ul>
<li>使用发布配置来自定义构建</li>
<li>将库发布到 <a href="https://crates.io">crates.io</a><!-- ignore --></li>
<li>使用工作空间来组织更大的项目</li>
<li>从 <a href="https://crates.io">crates.io</a><!-- ignore --> 安装二进制文件</li>
<li>使用自定义的命令来扩展 Cargo</li>
</ul>
<p>相比本章能够涉及的工作 Cargo 甚至还可以做到更多，关于其功能的全部解释，请查看 <a href="http://doc.rust-lang.org/cargo/">其文档</a></p>
<a class="header" href="print.html#a采用发布配置自定义构建" id="a采用发布配置自定义构建"><h2>采用发布配置自定义构建</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch14-01-release-profiles.md">ch14-01-release-profiles.md</a>
<br>
commit ff93f82ff63ade5a352d9ccc430945d4ec804cdf</p>
</blockquote>
<p>在 Rust 中 <strong>发布配置</strong>（<em>release profiles</em>）是预定义的、可定制的带有不同选项的配置，他们允许程序员更多的控制代码编译的多种选项。每一个配置都彼此相互独立。</p>
<p>Cargo 有两个主要的配置：运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置和运行 <code>cargo build --release</code> 的 <code>release</code> 配置。<code>dev</code> 配置被定义为开发时的好的默认配置，<code>release</code> 配置则有着良好的发布构建的默认配置。</p>
<p>我们应该很熟悉这些配置名称因为他们出现在构建的输出中，这会展示构建所使用的配置：</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>构建输出中的 <code>dev</code> 和 <code>release</code> 表明编译器在使用不同的配置。</p>
<p>Cargo 对每一个配置都有默认设置，当项目的 <em>Cargo.toml</em> 文件中没有任何 <code>[profile.*]</code> 部分的时候。通过增加任何希望定制的配置对应的 <code>[profile.*]</code> 部分，我们可以选择覆盖任意默认设置的子集。例如，如下是 <code>dev</code> 和 <code>release</code> 配置的 <code>opt-level</code> 设置的默认值：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p><code>opt-level</code> 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。这就是为什么 <code>dev</code> 的 <code>opt-level</code> 默认为 <code>0</code>。当你准备发布时，花费更多时间在编译上则更好。只需要在发布模式编译一次，而编译出来的程序则会运行很多次，所以发布模式用更长的编译时间换取运行更快的代码。这正是为什么 <code>release</code> 配置的 <code>opt-level</code> 默认为 <code>3</code>。</p>
<p>我们可以选择通过在 <em>Cargo.toml</em> 增加不同的值来覆盖任何默认设置。比如，如果我们想要在开发配置中使用级别 1 的优化，则可以在 <em>Cargo.toml</em> 中增加这两行：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>这会覆盖默认的设置 <code>0</code>。现在运行 <code>cargo build</code> 时，Cargo 将会使用 <code>dev</code> 的默认配置加上定制的 <code>opt-level</code>。因为 <code>opt-level</code> 设置为 <code>1</code>，Cargo 会比默认进行更多的优化，但是没有发布构建那么多。</p>
<p>对于每个配置的设置和其默认值的完整列表，请查看 <a href="https://doc.rust-lang.org/cargo/">Cargo 的文档</a>。</p>
<a class="header" href="print.html#a将-crate-发布到-cratesio" id="a将-crate-发布到-cratesio"><h2>将 crate 发布到 Crates.io</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch14-02-publishing-to-crates-io.md">ch14-02-publishing-to-crates-io.md</a>
<br>
commit ff93f82ff63ade5a352d9ccc430945d4ec804cdf</p>
</blockquote>
<p>我们曾经在项目中使用 <a href="https://crates.io">crates.io</a><!-- ignore --> 上的包作为依赖，不过你也可以通过发布自己的包来向它人分享代码。<a href="https://crates.io">crates.io</a><!-- ignore --> 用来分发包的源代码，所以它主要托管开源代码。</p>
<p>Rust 和 Cargo 有一些帮助它人更方便找到和使用你发布的包的功能。我们将介绍一些这样的功能，接着讲到如何发布一个包。</p>
<a class="header" href="print.html#a编写有用的文档注释" id="a编写有用的文档注释"><h3>编写有用的文档注释</h3></a>
<p>准确的包文档有助于其他用户理解如何以及何时使用他们，所以花一些时间编写文档是值得的。第三章中我们讨论了如何使用 <code>//</code> 注释 Rust 代码。Rust 也有特定的用于文档的注释类型，通常被称为 <strong>文档注释</strong>（<em>documentation comments</em>），他们会生成 HTML 文档。这些 HTML 展示公有 API 文档注释的内容，他们意在让对库感兴趣的程序员理解如何 <strong>使用</strong> 这个 crate，而不是它是如何被 <strong>实现</strong> 的。</p>
<p>文档注释使用 <code>///</code> 而不是 <code>//</code> 并支持 Markdown 注解来格式化文本。文档注释就位于需要文档的项的之前。示例 14-1 展示了一个 <code>my_crate</code> crate 中 <code>add_one</code> 函数的文档注释：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">示例 14-1：一个函数的文档注释</span></p>
<p>这里，我们提供了一个 <code>add_one</code> 函数工作的描述，接着开始了一个标题为 “Examples” 的部分，和展示如何使用 <code>add_one</code> 函数的代码。可以运行 <code>cargo doc</code> 来生成这个文档注释的 HTML 文档。这个命令运行由 Rust 分发的工具 <code>rustdoc</code> 并将生成的 HTML 文档放入 <em>target/doc</em> 目录。</p>
<p>为了方便起见，运行 <code>cargo doc --open</code> 会构建当前 crate 文档（同时还有所有 crate 依赖的文档）的 HTML 并在浏览器中打开。导航到 <code>add_one</code> 函数将会发现文档注释的文本是如何渲染的，如图 14-1 所示：</p>
<p><img alt="`my_crate` 的 `add_one` 函数所渲染的文档注释 HTML" src="img/trpl14-01.png" class="center" /></p>
<p><span class="caption">图 14-1：<code>add_one</code> 函数的文档注释 HTML</span></p>
<a class="header" href="print.html#a常用文档注释部分" id="a常用文档注释部分"><h4>常用（文档注释）部分</h4></a>
<p>示例 14-1 中使用了 <code># Examples</code> Markdown 标题在 HTML 中创建了一个以 “Examples” 为标题的部分。其他一些 crate 作者经常在文档注释中使用的部分有：</p>
<ul>
<li><strong>Panics</strong>：这个函数可能会 <code>panic!</code> 的场景。并不希望程序崩溃的函数调用者应该确保他们不会在这些情况下调用此函数。</li>
<li><strong>Errors</strong>：如果这个函数返回 <code>Result</code>，此部分描述可能会出现何种错误以及什么情况会造成这些错误，这有助于调用者编写代码来采用不同的方式处理不同的错误。</li>
<li><strong>Safety</strong>：如果这个函数使用 <code>unsafe</code> 代码（这会在第十九章讨论），这一部分应该会涉及到期望函数调用者支持的确保 <code>unsafe</code> 块中代码正常工作的不变条件（invariants）。</li>
</ul>
<p>大部分文档注释不需要所有这些部分，不过这是一个提醒你检查调用你代码的人有兴趣了解的内容的列表。</p>
<a class="header" href="print.html#a文档注释作为测试" id="a文档注释作为测试"><h4>文档注释作为测试</h4></a>
<p>在文档注释中增加示例代码块是一个清楚的表明如何使用库的方法，这么做还有一个额外的好处：<code>cargo test</code> 也会像测试那样运行文档中的示例代码！没有什么比有例子的文档更好的了！也没有什么比不能正常工作的例子更糟的了，因为代码在编写文档时已经改变。尝试 <code>cargo test</code> 运行像示例 14-1 中 <code>add_one</code> 函数的文档；应该在测试结果中看到像这样的部分：</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>现在尝试改变函数或例子来使例子中的 <code>assert_eq!</code> 产生 panic。再次运行 <code>cargo test</code>，你将会看到文档测试捕获到了例子与代码不再同步！</p>
<a class="header" href="print.html#a注释包含项的结构" id="a注释包含项的结构"><h4>注释包含项的结构</h4></a>
<p>还有另一种风格的文档注释，<code>//!</code>，这为包含注释的项，而不是注释之后的项增加文档。这通常用于 crate 根文件（通常是 <em>src/lib.rs</em>）或模块的根文件为 crate 或模块整体提供文档。</p>
<p>作为一个例子，如果我们希望增加描述包含 <code>add_one</code> 函数的 <code>my_crate</code> crate 目的的文档，可以在 <em>src/lib.rs</em> 开头增加以 <code>//!</code> 开头的注释，如示例 14-2 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
</code></pre>
<p><span class="caption">示例 14-2：<code>my_crate</code> crate 整体的文档</span></p>
<p>注意 <code>//!</code> 的最后一行之后没有任何代码。因为他们以 <code>//!</code> 开头而不是 <code>///</code>，这是属于包含此注释的项而不是注释之后项的文档。在这个情况中，包含这个注释的项是 <em>src/lib.rs</em> 文件，也就是 crate 根文件。这些注释描述了整个 crate。</p>
<p>如果运行 <code>cargo doc --open</code>，将会发现这些注释显示在 <code>my_crate</code> 文档的首页，位于 crate 中公有项列表之上，如图 14-2 所示：</p>
<p><img alt="crate 整体注释所渲染的 HTML 文档" src="img/trpl14-02.png" class="center" /></p>
<p><span class="caption">图 14-2：包含 <code>my_crate</code> 整体描述的注释所渲染的文档</span></p>
<p>位于项之中的文档注释对于描述 crate 和模块特别有用。使用他们描述其容器整体的目的来帮助 crate 用户理解你的代码组织。</p>
<a class="header" href="print.html#a使用-pub-use-导出合适的公有-api" id="a使用-pub-use-导出合适的公有-api"><h3>使用 <code>pub use</code> 导出合适的公有 API</h3></a>
<p>第七章介绍了如何使用 <code>mod</code> 关键字来将代码组织进模块中，如何使用 <code>pub</code> 关键字将项变为公有，和如何使用 <code>use</code> 关键字将项引入作用域。然而对你开发来说很有道理的结果可能对用户来说就不太方便了。你可能希望将结构组织进有多个层次的层级中，不过想要使用被定义在很深层级中的类型的人可能很难发现这些类型是否存在。他们也可能会厌烦 <code>use my_crate::some_module::another_module::UsefulType;</code> 而不是 <code>use my_crate::UsefulType;</code> 来使用类型。</p>
<p>公有 API 的结构是你发布 crate 时主要需要考虑的。crate 用户没有你那么熟悉其结构，并且如果模块层级过大他们可能会难以找到所需的部分。</p>
<p>好消息是，如果结果对于用户来说 <strong>不是</strong> 很方便，你也无需重新安排内部组织：你可以选择使用 <code>pub use</code> 重导出（re-export）项来使公有结构不同于私有结构。重导出获取位于一个位置的公有项并将其公开到另一个位置，好像它就定义在这个新位置一样。</p>
<p>例如，假设我们创建了一个模块化了充满艺术化气息的库 <code>art</code>。在这个库中是一个包含两个枚举 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 的模块 <code>kinds</code>，以及一个包含函数 <code>mix</code> 的模块 <code>utils</code>，如示例 14-3 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">示例 14-3：一个库 <code>art</code> 其组织包含 <code>kinds</code> 和 <code>utils</code> 模块</span></p>
<p><code>cargo doc</code> 所生成的 crate 文档首页如图 14-3 所示：</p>
<p><img alt="包含 `kinds` 和 `utils` 模块的 `art`" src="img/trpl14-03.png" class="center" /></p>
<p><span class="caption">图 14-3：包含 <code>kinds</code> 和 <code>utils</code> 模块的库 <code>art</code> 的文档首页</span></p>
<p>注意 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型没有在首页中列出，<code>mix</code> 函数也是。必须点击 <code>kinds</code> 或 <code>utils</code> 才能看到他们。</p>
<p>另一个依赖这个库的 crate 需要 <code>use</code> 语句来导入 <code>art</code> 中的项，这包含指定其当前定义的模块结构。示例 14-4 展示了一个使用 <code>art</code> crate 中 <code>PrimaryColor</code> 和 <code>mix</code> 项的 crate 的例子：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">示例 14-4：一个通过导出内部结构使用 <code>art</code> crate 中项的 crate</span></p>
<p>示例 14-4 中使用 <code>art</code> crate 代码的作者不得不搞清楚 <code>PrimaryColor</code> 位于 <code>kinds</code> 模块而 <code>mix</code> 位于 <code>utils</code> 模块。<code>art</code> crate 的模块结构相比使用它的开发者来说对编写它的开发者更有意义。其内部的 <code>kinds</code> 模块和 <code>utils</code> 模块的组织结构并没有对尝试理解如何使用它的人提供任何有价值的信息。<code>art</code> crate 的模块结构因不得不搞清楚所需的内容在何处和必须在 <code>use</code> 语句中指定模块名称而显得混乱和不便。</p>
<p>为了从公有 API 中去掉 crate 的内部组织，我们可以采用示例 14-3 中的 <code>art</code> crate 并增加 <code>pub use</code> 语句来重导出项到顶层结构，如示例 14-5 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<p><span class="caption">示例 14-5：增加 <code>pub use</code> 语句重导出项</span></p>
<p>现在此 crate 由 <code>cargo doc</code> 生成的 API 文档会在首页列出重导出的项以及其链接，如图 14-4 所示，这就使得这些类型易于查找。</p>
<p><img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" /></p>
<p><span class="caption">图 14-10：<code>art</code> 文档的首页，这里列出了重导出的项</span></p>
<p><code>art</code> crate 的用户仍然可以看见和选择使用示例 14-3 中的内部结构，或者可以使用示例 14-4 中更为方便的结构，如示例 14-6 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<p><span class="caption">示例 14-6：一个使用 <code>art</code> crate 中重导出项的程序</span></p>
<p>对于有很多嵌套模块的情况，使用 <code>pub use</code> 将类型重导出到顶级结构对于使用 crate 的人来说将会是大为不同的体验。</p>
<p>创建一个有用的公有 API 结构更像是一门艺术而非科学，你可以反复检视他们来找出最适合用户的 API。选择 <code>pub use</code> 提供了解耦组织 crate 内部结构和与终端用户体现的灵活性。观察一些你所安装的 crate 的代码来看看其内部结构是否不同于公有 API。</p>
<a class="header" href="print.html#a创建-cratesio-账号" id="a创建-cratesio-账号"><h3>创建 Crates.io 账号</h3></a>
<p>在你可以发布任何 crate 之前，需要在 <a href="https://crates.io">crates.io</a><!-- ignore --> 上注册账号并获取一个 API token。为此，访问位于 <a href="https://crates.io">crates.io</a><!-- ignore --> 的首页并使用 GitHub 账号登陆————目前 GitHub 账号是必须的，不过将来该网站可能会支持其他创建账号的方法。一旦登陆之后，查看位于 <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> 的账户设置页面并获取 API token。接着使用该 API token 运行 <code>cargo login</code> 命令，像这样：</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>这个命令会通知 Cargo 你的 API token 并将其储存在本地的 <em>~/.cargo/credentials</em> 文件中。注意这个 token 是一个 <strong>秘密</strong>（<strong>secret</strong>）且不应该与其他人共享。如果因为任何原因与他人共享了这个信息，应该立即到 <a href="https://crates.io">crates.io</a><!-- ignore --> 重新生成这个 token。</p>
<a class="header" href="print.html#a发布新-crate-之前" id="a发布新-crate-之前"><h3>发布新 crate 之前</h3></a>
<p>有了账号之后，比如说你已经有一个希望发布的 crate。在发布之前，你需要在 crate 的 <em>Cargo.toml</em> 文件的 <code>[package]</code> 部分增加一些本 crate 的元信息（metadata）。</p>
<p>首先 crate 需要一个唯一的名称。虽然在本地开发 crate 时，可以使用任何你喜欢的名称。不过 <a href="https://crates.io">crates.io</a><!-- ignore --> 上的 crate 名称遵守先到先得的分配原则。一旦某个 crate 名称被使用，其他人就不能再发布这个名称的 crate 了。请在网站上搜索你希望使用的名称来找出它是否已被使用。如果没有，修改 <em>Cargo.toml</em> 中 <code>[package]</code> 里的名称为你希望用于发布的名称，像这样：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>即使你选择了一个唯一的名称，如果此时尝试运行 <code>cargo publish</code> 发布该 crate 的话，会得到一个一个警告接着是一个错误：</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
--snip--
error: api errors: missing or empty metadata fields: description, license.
</code></pre>
<p>这是因为我们缺少一些关键信息：关于该 crate 用途的描述和用户可能在何种条款下使用该 crate 的 license。为了修正这个错误，需要在 <em>Cargo.toml</em> 中引入这些信息。</p>
<p>描述通常是一两句话，因为它会出现在 crate 的搜索结果中和 crate 页面里。对于 <code>license</code> 字段，你需要一个 <strong>license 标识符值</strong>（<em>license identifier value</em>）。Linux 基金会位于 <em>http://spdx.org/licenses/</em> 的 Software Package Data Exchange (SPDX) 列出了可以使用的标识符。例如，为了指定 crate 使用 MIT License，增加 <code>MIT</code> 标识符：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>如果你希望使用不存在于 SPDX 的 license，则需要将 license 文本放入一个文件，将该文件包含进项目中，接着使用 <code>license-file</code> 来指定文件名而不是使用 <code>license</code> 字段。</p>
<p>关于项目所适用的 license 指导超出了本书的范畴。很多 Rust 社区成员选择与 Rust 自身相同的 license，这是一个双许可的 <code>MIT OR Apache-2.0</code> ———— 这展示了也可以通过 <code>OR</code> 来分隔来为项目指定多个 license 标识符。</p>
<p>那么，有了唯一的名称、版本号、由 <code>cargo new</code> 新建项目时增加的作者信息、描述和所选择的 license，已经准备好发布的项目的 <em>Cargo.toml</em> 文件可能看起来像这样：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="http://doc.rust-lang.org/cargo/">Cargo 的文档</a> 描述了其他可以指定的元信息，他们可以帮助你的 crate 更容易被发现和使用！</p>
<a class="header" href="print.html#a发布到-cratesio" id="a发布到-cratesio"><h3>发布到 Crates.io</h3></a>
<p>现在我们创建了一个账号，保存了 API token，为 crate 选择了一个名字，并指定了所需的元数据，你已经准备好发布了！发布 crate 会上传特定版本的 crate 到 <a href="https://crates.io">crates.io</a><!-- ignore --> 以供他人使用。</p>
<p>发布 crate 时请多加小心，因为发布是 <strong>永久性的</strong>（<em>permanent</em>）。对应版本不可能被覆盖，其代码也不可能被删除。<a href="https://crates.io">crates.io</a><!-- ignore --> 的一个主要目标是作为一个代码的永久文档服务器，这样所有依赖 <a href="https://crates.io">crates.io</a><!-- ignore --> 中 crate 的项目都能一直正常工作。允许删除版本将不可能满足这个目标。然而，可以被发布的版本号却没有限制。</p>
<p>再次运行 <code>cargo publish</code> 命令。这次它应该会成功：</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>恭喜！你现在向 Rust 社区分享了代码，而且任何人都可以轻松的将你的 crate 加入他们项目的依赖。</p>
<a class="header" href="print.html#a发布现存-crate-的新版本" id="a发布现存-crate-的新版本"><h3>发布现存 crate 的新版本</h3></a>
<p>当你修改了 crate 并准备好发布新版本时，改变 <em>Cargo.toml</em> 中 <code>version</code> 所指定的值。请使用 <a href="http://semver.org/">语义化版本规则</a> 来根据修改的类型决定下一个版本号。接着运行 <code>cargo publish</code> 来上传新版本。</p>
<a class="header" href="print.html#a使用-cargo-yank-从-cratesio-撤回版本" id="a使用-cargo-yank-从-cratesio-撤回版本"><h3>使用 <code>cargo yank</code> 从 Crates.io 撤回版本</h3></a>
<p>虽然你不能删除之前版本的 crate，但是可以阻止任何将来的项目将他们加入到依赖中。这在某个版本因为这样或那样的原因被破坏的情况很有用。对于这种情况，Cargo 支持 <strong>撤回</strong>（<em>yanking</em>）某个版本。</p>
<p>撤回某个版本会阻止新项目开始依赖此版本，不过所有现存此依赖的项目仍然能够下载和依赖这个版本。从本质上说，撤回意味着所有带有 <em>Cargo.lock</em> 的项目的依赖不会被破坏，同时任何新生成的 <em>Cargo.lock</em> 将不能使用被撤回的版本。</p>
<p>为了撤回一个 crate，运行 <code>cargo yank</code> 并指定希望撤回的版本：</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>也可以撤销撤回操作，并允许项目可以再次开始依赖某个版本，通过在命令上增加 <code>--undo</code>：</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>撤回 <strong>并没有</strong> 删除任何代码。举例来说，撤回功能并不意在删除不小心上传的秘密信息。如果出现了这种情况，请立即重新设置这些秘密信息。</p>
<a class="header" href="print.html#cargo-工作空间" id="cargo-工作空间"><h2>Cargo 工作空间</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch14-03-cargo-workspaces.md">ch14-03-cargo-workspaces.md</a>
<br>
commit a59537604248f2970e0831d5ead9f6fac2cdef84</p>
</blockquote>
<p>第十二章中，我们构建一个包含二进制 crate 和库 crate 的包。你可能会发现，随着项目开发的深入，库 crate 持续增大，而你希望将其进一步拆分成多个库 crate。对于这种情况，Cargo 提供了一个叫 <strong>工作空间</strong>（<em>workspaces</em>）的功能，它可以帮助我们管理多个相关的协同开发的包。</p>
<p><strong>工作空间</strong> 是一系列共享同样的 <em>Cargo.lock</em> 和输出目录的包。让我们使用工作空间创建一个项目，这里采用常见的代码这样就可以关注工作空间的结构了。有多种组织工作空间的方式；我们将展示一个常用方法。我们的工作空间有一个二进制项目和两个库。二进制项目会提供作为命令行工具的主要功能，它会依赖另两个库。一个库会提供 <code>add_one</code> 方法而第二个会提供 <code>add_two</code> 方法。这三个 crate 将会是相同工作空间的一部分。让我们以新建工作空间目录开始：</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<p>在 add* 目录中，创建 <em>Cargo.toml</em> 文件。这个 <em>Cargo.toml</em> 文件配置了整个工作空间。它不会包含 <code>[package]</code> 或其他我们在 <em>Cargo.toml</em> 中见过的元信息。相反，它以 <code>[workspace]</code> 部分作为开始，并通过指定 <em>adder</em> 的路径来为工作空间增加成员，如下会加入二进制 crate：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>接下来，在 <em>add</em> 目录运行 <code>cargo new</code> 新建 <code>adder</code> 二进制 crate：</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
</code></pre>
<p>到此为止，可以运行 <code>cargo build</code> 来构建工作空间。<em>add</em> 目录中的文件应该看起来像这样：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>工作空间在顶级目录有一个 <em>target</em> 目录；<code>adder</code> 并没有自己的 <em>target</em> 目录。即使进入 <em>adder</em> 目录运行 <code>cargo build</code>，构建结果也位于 <em>add/target</em> 而不是 <em>add/adder/target</em>。工作空间中的 crate 之间相互依赖。如果每个 crate 有其自己的 <em>target</em> 目录，为了在自己的 <em>target</em> 目录中生成构建结果，工作空间中的每一个 crate 都不得不相互重新编译其他 crate。通过共享一个 <em>target</em> 目录，工作空间可以避免其他 crate 多余的重复构建。</p>
<a class="header" href="print.html#a在工作空间中创建第二个-crate" id="a在工作空间中创建第二个-crate"><h3>在工作空间中创建第二个 crate</h3></a>
<p>接下来，让我们在工作空间中指定另一个成员 crate。这个 crate 位于 <em>add-one</em> 目录中，所以修改顶级 <em>Cargo.toml</em> 为也包含 <em>add-one</em> 路径：</p>
<p><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>接着新生成一个叫做 <code>add-one</code> 的库：</p>
<pre><code class="language-text">$ cargo new add-one
     Created library `add-one` project
</code></pre>
<p>现在 <em>add</em> 目录应该有如下目录和文件：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>在 <em>add-one/src/lib.rs</em> 文件中，增加一个 <code>add_one</code> 函数：</p>
<p><span class="filename">文件名: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>现在工作空间中有了一个库 crate，让 <code>adder</code> 依赖库 crate <code>add-one</code>。首先需要在 <em>adder/Cargo.toml</em> 文件中增加 <code>add-one</code> 作为路径依赖：</p>
<p><span class="filename">文件名: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>工作空间中的 crate 不必相互依赖，所以仍需显式地表明工作空间中 crate 的依赖关系。</p>
<p>接下来，在 <code>adder</code> crate 中使用 <code>add-one</code> crate 的函数 <code>add_one</code>。打开 <em>adder/src/main.rs</em> 在顶部增加一行 <code>extern crate</code> 将新 <code>add-one</code> 库 crate 引入作用域。接着修改 <code>main</code> 函数来调用 <code>add_one</code> 函数，如示例 14-7 所示：</p>
<p><span class="filename">文件名: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p><span class="caption">示例 14-7：在 <code>adder</code> crate 中使用 <code>add-one</code> 库 crate</span></p>
<p>在 <em>add</em> 目录中运行 <code>cargo build</code> 来构建工作空间！</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p>为了在顶层 <em>add</em> 目录运行二进制 crate，需要通过 <code>-p</code> 参数和包名称来运行 <code>cargo run</code> 指定工作空间中我们希望使用的包：</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>这会运行 <em>adder/src/main.rs</em> 中的代码，其依赖 <code>add-one</code> crate</p>
<a class="header" href="print.html#a在工作空间中依赖外部-crate" id="a在工作空间中依赖外部-crate"><h4>在工作空间中依赖外部 crate</h4></a>
<p>还需注意的是工作空间只在根目录有一个 <em>Cargo.lock</em>，而不是在每一个 crate 目录都有 <em>Cargo.lock</em>。这确保了所有的 crate 都使用完全相同版本的依赖。如果在 <em>Cargo.toml</em> 和 <em>add-one/Cargo.toml</em> 中都增加 <code>rand</code> crate，则 Cargo 会将其都解析为同一版本并记录到唯一的 <em>Cargo.lock</em> 中。使得工作空间中的所有 crate 都使用相同的依赖意味着其中的 crate 都是相互兼容的。让我们在 <em>add-one/Cargo.toml</em> 中的 <code>[dependencies]</code> 部分增加 <code>rand</code> crate 以便能够在 <code>add-one</code> crate 中使用 <code>rand</code> crate：</p>
<p><span class="filename">文件名: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>现在就可以在 <em>add-one/src/lib.rs</em> 中增加 <code>extern crate rand;</code> 了，接着在 <em>add</em> 目录运行 <code>cargo build</code> 构建整个工作空间就会引入并编译 <code>rand</code> crate：</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p>现在顶级的 <em>Cargo.lock</em> 包含了 <code>add-one</code> 的 <code>rand</code> 依赖的信息。然而，即使 <code>rand</code> 被用于工作空间的某处，也不能在其他 crate 中使用它，除非也在他们的 <em>Cargo.toml</em> 中加入 <code>rand</code>。例如，如果在顶级的 <code>adder</code> crate 的 <em>adder/src/main.rs</em> 中增加 <code>extern crate rand;</code>，会得到一个错误：</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --&gt; adder/src/main.rs:1:1
  |
1 | extern crate rand;
</code></pre>
<p>为了修复这个错误，修改顶级 <code>adder</code> crate 的 <em>Cargo.toml</em> 来表明 <code>rand</code> 也是这个 crate 的依赖。构建 <code>adder</code> crate 会将 <code>rand</code> 加入到 <em>Cargo.lock</em> 中 <code>adder</code> 的依赖列表中，但是这并不会下载 <code>rand</code> 的额外拷贝。Cargo 确保了工作空间中任何使用 <code>rand</code> 的 crate 都采用相同的版本。在整个工作空间中使用相同版本的 <code>rand</code> 节省了空间，因为这样就无需多个拷贝并确保了工作空间中的 crate 将是相互兼容的。</p>
<a class="header" href="print.html#a为工作空间增加测试" id="a为工作空间增加测试"><h4>为工作空间增加测试</h4></a>
<p>作为另一个提升，让我们为 <code>add_one</code> crate 中的 <code>add_one::add_one</code> 函数增加一个测试：</p>
<p><span class="filename">文件名: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<p>在顶级 <em>add</em> 目录运行 <code>cargo test</code>：</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>输出的第一部分显示 <code>add-one</code> crate 的 <code>it_works</code> 测试通过了。下一个部分显示 <code>adder</code> crate 中找到了 0 个测试，最后一部分显示 <code>add-one</code> crate 中有 0 个文档测试。在像这样的工作空间结构中运行 <code>cargo test</code> 会运行工作空间中所有 crate 的测试。</p>
<p>也可以选择运行工作空间中特定 crate 的测试，通过在根目录使用 <code>-p</code> 参数并指定希望测试的 crate 名称：</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>输出显示了 <code>cargo test</code> 只运行了 <code>add-one</code> crate 的测试而没有运行 <code>adder</code> crate 的测试。</p>
<p>如果你选择向 <em>https://crates.io/</em> 发布工作空间中的 crate，每一个工作空间中的 crate 将会单独发布。<code>cargo publish</code> 命令并没有 <code>--all</code> 或者 <code>-p</code> 参数，所以必须进入每一个 crate 的目录并运行 <code>cargo publish</code> 来发布工作空间中的每一个 crate。</p>
<p>现在尝试以类似 <code>add-one</code> crate 的方式向工作空间增加 <code>add-two</code> crate 来作为更多的练习！</p>
<p>随着项目增长，考虑使用工作空间：每一个更小的组件比一大块代码要容易理解。将 crate 保持在工作空间中更易于协调他们的改变，如果他们一起运行并经常需要同时被修改的话。</p>
<a class="header" href="print.html#a使用-cargo-install-从-cratesio-安装二进制文件" id="a使用-cargo-install-从-cratesio-安装二进制文件"><h2>使用 <code>cargo install</code> 从 Crates.io 安装二进制文件</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch14-04-installing-binaries.md">ch14-04-installing-binaries.md</a>
<br>
commit ff93f82ff63ade5a352d9ccc430945d4ec804cdf</p>
</blockquote>
<p><code>cargo install</code> 命令用于在本地安装和使用二进制 crate。它并不打算替换系统中的包；它意在作为一个方便 Rust 开发者们安装其他人已经在 <a href="https://crates.io">crates.io</a><!-- ignore --> 上共享的工具的手段。只有拥有二进制目标文件的包能够被安装。二进制目标文件是在 crate 有 <em>src/main.rs</em> 或者其他指定为二进制文件时所创建的可执行程序，这不同于自身不能执行但适合包含在其他程序中的库目标文件。通常 crate 的 <em>README</em> 文件中有该 crate 是库、二进制目标还是两者都是的信息。</p>
<p>所有来自 <code>cargo install</code> 的二进制文件都安装到 Rust 安装根目录的 <em>bin</em> 文件夹中。如果你使用 <em>rustup.rs</em> 安装的 Rust 且没有自定义任何配置，这将是 <code>$HOME/.cargo/bin</code>。确保将这个目录添加到 <code>$PATH</code> 环境变量中就能够运行通过 <code>cargo install</code> 安装的程序了。</p>
<p>例如，第十二章提到的叫做 <code>ripgrep</code> 的用于搜索文件的 <code>grep</code> 的 Rust 实现。如果想要安装 <code>ripgrep</code>，可以运行如下：</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>最后一行输出展示了安装的二进制文件的位置和名称，在这里 <code>ripgrep</code> 被命名为 <code>rg</code>。只要你像上面提到的那样将安装目录加入 <code>$PATH</code>，就可以运行 <code>rg --help</code> 并开始使用一个更快更 Rust 的工具来搜索文件了！</p>
<a class="header" href="print.html#cargo-自定义扩展命令" id="cargo-自定义扩展命令"><h2>Cargo 自定义扩展命令</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch14-05-extending-cargo.md">ch14-05-extending-cargo.md</a>
<br>
commit ff93f82ff63ade5a352d9ccc430945d4ec804cdf</p>
</blockquote>
<p>Cargo 被设计为可以通过新的子命令而无须修改 Cargo 自身来进行扩展。如果 <code>$PATH</code> 中有类似 <code>cargo-something</code> 的二进制文件，就可以通过 <code>cargo something</code> 来像 Cargo 子命令一样运行它。像这样的自定义命令也可以运行 <code>cargo --list</code> 来展示出来。能够通过 <code>cargo install</code> 向 Cargo 安装扩展并可以如内建 Cargo 工具那样运行他们是 Cargo 设计上的一个非常方便的优点！</p>
<a class="header" href="print.html#a总结-13" id="a总结-13"><h2>总结</h2></a>
<p>通过 Cargo 和 <a href="https://crates.io">crates.io</a><!-- ignore --> 来分享代码是使得 Rust 生态环境可以用于许多不同的任务的重要组成部分。Rust 的标准库是小而稳定的，不过 crate 易于分享和使用，并采用一个不同语言自身的时间线来提供改进。不要羞于在 <a href="https://crates.io">crates.io</a><!-- ignore --> 上共享对你有用的代码；因为它很有可能对别人也很有用！</p>
<a class="header" href="print.html#a智能指针" id="a智能指针"><h1>智能指针</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-00-smart-pointers.md">ch15-00-smart-pointers.md</a>
<br>
commit 68267b982a226fa252e9afa1a5029396ccf5fa03</p>
</blockquote>
<p><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其他数据。Rust 中最常见的指针是第四章介绍的 <strong>引用</strong>（<em>reference</em>）。引用以 <code>&amp;</code> 符号为标志并借用了他们所指向的值。除了引用数据它们没有任何其他特殊功能。它们也没有任何额外开销，所以应用的最多。</p>
<p>另一方面，<strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中。Rust 标准库中不同的智能指针提供了多于引用的额外功能。本章将会探索的一个例子便是 <strong>引用计数</strong> （<em>reference counting</em>）智能指针类型，其允许数据有多个所有者。引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。</p>
<!-- maybe a brief explanation what deref and drop? I'm not really sure what
reference counting is here too, can you outline that in brief?-->
<!-- We've added a quick explanation of reference counting here and a brief
explanation of deref and drop below. /Carol -->
<!--(regarding C++) if this is relevant here, can you expand? Are we saying
they will be familiar to C++ people? -->
<!-- We were trying to say that "smart pointer" isn't something particular to
Rust; we've tried to clarify. /Carol -->
<p>在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反大部分情况，智能指针 <strong>拥有</strong> 他们指向的数据。</p>
<p>实际上本书中已经出现过一些智能指针，比如第八章的 <code>String</code> 和 <code>Vec&lt;T&gt;</code>，虽然当时我们并不这么称呼它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们。它们也带有元数据（比如他们的容量）和额外的功能或保证（<code>String</code> 的数据总是有效的 UTF-8 编码）。</p>
<!-- Above: we said smart pointers don't own values earlier but in the
paragraph above we're saying String and Vec own memory, is that a
contradiction? -->
<!-- Our original text read: "In Rust, an additional difference between plain
references and smart pointers is that references are a kind of pointer that
only borrow data; by contrast, in many cases, smart pointers *own* the data
that they point to." You had edited this to say the opposite: "In Rust, smart
pointers can only borrow data, whereas in many other languages, smart pointers
*own* the data they point to." We had the "in rust" phrase not to distinguish
Rust's smart pointer implementation from other languages' smart pointer
implementations, but to acknowledge that the concept of borrowing and ownership
doesn't apply in many languages. The distinction between references borrowing
and smart pointers owning is important in the context of Rust. We've tried to
clarify the sentence talking about C++ and separate it from the discussion of
borrowing vs owning. So there shouldn't be a contradiction, and it should be
clearer that smart pointers usually own the data they point to. /Carol -->
<p>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 <code>Deref</code> 和 <code>Drop</code> trait。<code>Deref</code> trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用又用于智能指针的代码。<code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码。本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。</p>
<p>考虑到智能指针是一个在 Rust 经常被使用的通用设计模式，本章并不会覆盖所有现存的智能指针。很多库都有自己的智能指针而你也可以编写属于你自己的智能指针。这里将会讲到的是来自标准库中最常用的一些：</p>
<!-- Would it make sense to hyphenate reference-counted (and its derivations)
here? I think that would be more clear, but I don't want to do that if that's
not the Rust convention -->
<!-- The hyphenated version doesn't appear to be a general convention to me, it
looks like "reference counted" is most often not hyphenated. For example:
http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf
 We'd be interested to know if there's a standard that we don't know about
/Carol -->
<ul>
<li><code>Box&lt;T&gt;</code>，用于在堆上分配值</li>
<li><code>Rc&lt;T&gt;</code>，一个引用计数类型，其数据可以有多个所有者</li>
<li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问，一个在运行时而不是在编译时执行借用规则的类型。</li>
</ul>
<!-- Should we add Ref and RefMut to this list, too? -->
<!-- They were already sort of in the list; we've flipped the order to make it
clearer /Carol-->
<p>同时我们会涉及 <strong>内部可变性</strong>（<em>interior mutability</em>）模式，这时不可变类型暴露出改变其内部值的 API。我们也会讨论 <strong>引用循环</strong>（<em>reference cycles</em>）会如何泄露内存，以及如何避免。</p>
<p>让我们开始吧！</p>
<a class="header" href="print.html#boxt-在堆上存储数据并且可确定大小" id="boxt-在堆上存储数据并且可确定大小"><h2><code>Box&lt;T&gt;</code> 在堆上存储数据，并且可确定大小</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-01-box.md">ch15-01-box.md</a>
<br>
commit 0905e41f7387b60865e6eac744e31a7f7b46edf5</p>
</blockquote>
<p>最简单直接的智能指针是 <em>box</em>，其类型是 <code>Box&lt;T&gt;</code>。 box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。如果你想回顾一下栈与堆的区别请参考第四章。</p>
<!-- do we mean, allows you to place a value on the heap rather than the
default behavior of placing it on the stack? Can you quickly recap on what the
advantage to this can be, help them know when they'd use this? -->
<!-- Correct! Recap below: /Carol -->
<p>除了数据被储存在堆上而不是栈上之外，box 没有性能损失，不过也没有很多额外的功能。他们多用于如下场景：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li>
</ul>
<p>我们将在本部分的余下内容中展示第一种应用场景。作为对另外两个情况更详细的说明：在第二种情况中，转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝。第三种情况被称为 <strong>trait 对象</strong>（<em>trait object</em>），第十七章刚好有一整个部分专门讲解这个主题。所以这里所学的内容会在第十七章再次用上！</p>
<a class="header" href="print.html#a使用-boxt-在堆上储存数据" id="a使用-boxt-在堆上储存数据"><h3>使用 <code>Box&lt;T&gt;</code> 在堆上储存数据</h3></a>
<p>在开始 <code>Box&lt;T&gt;</code> 的用例之前，让我们熟悉一下语法和如何与储存在 <code>Box&lt;T&gt;</code> 中的值交互。</p>
<p>示例 15-1 展示了如何使用 box 在堆上储存一个 <code>i32</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">示例 15-1：使用 box 在堆上储存一个 <code>i32</code> 值</span></p>
<p>这里定义了变量 <code>b</code>，其值是一个指向被分配在堆上的值 <code>5</code> 的 <code>Box</code>。这个程序会打印出 <code>b = 5</code>；在这个例子中，我们可以像数据是储存在栈上的那样访问 box 中的数据。正如任何拥有数据所有权的值那样，当像 <code>b</code> 这样的 box 在 <code>main</code> 的末尾离开作用域时，它将被释放。这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）。</p>
<p>将一个单独的值存放在堆上并不是很有意义，所以像示例 15-1 这样单独使用 box 并不常见。将像单个 <code>i32</code> 这样的值储存在栈上，也就是其默认存放的地方在大部分使用场景中更为合适。让我们看看一个不使用 box 时无法定义的类型的例子。</p>
<!-- is this what we mean, we wouldn't bother with a box for something that can
be done more simply with a variable? -->
<!-- No, this doesn't really have anything to do with variables; this example
is using both a variable and a box. I've tried to clarify. /Carol -->
<a class="header" href="print.html#box-允许创建递归类型" id="box-允许创建递归类型"><h3>box 允许创建递归类型</h3></a>
<!-- (or something that encompasses everything we do with this example) -->
<!-- below: I'm unfamiliar with the cons concept, are we saying each value
except the first is repeated? does an item contain both its own value and the
next **item**, or the next **value**? Is it a continually nesting list? I'm
finding it hard to visualize -->
<!-- Did Figure 15-4 (trpl15-01.svg that I sent) help at all? /Carol-->
<p>Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 <strong>递归类型</strong>（<em>recursive type</em>），其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。</p>
<p>让我们探索一下 <em>cons list</em>，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念。除了递归之外，我们将要定义的 cons list 类型是很直白的，所以这个例子中的概念在任何遇到更为复杂的涉及到递归类型的场景时都很实用。</p>
<!-- can you also say why we're discussing cons lists in such depth? It seems
like a detour from the smart pointers conversation, is it just another concept
we're covering or is it imperative for learning about smart pointers? Either
way, can you lay that out up front, I think this could throw readers -->
<!-- A cons list is an example that's fairly simple but illustrates the use
case for Box. Readers may find themselves wanting to define a variety of
recursive types more complicated than cons lists in the future, and this
chapter demonstrates why box is the solution they should reach for in those
situations. We've tried to make that clearer in the above two paragraphs.
/Carol -->
<p>cons list 是一个每一项都包含两个部分的列表：当前项的值和下一项。其最后一项值包含一个叫做 <code>Nil</code> 的值并没有下一项。</p>
<blockquote>
<a class="header" href="print.html#cons-list-的更多内容" id="cons-list-的更多内容"><h4>cons list 的更多内容</h4></a>
<p><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，<code>cons</code> 函数（“construct function&quot; 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。</p>
<p>cons 函数的概念涉及到更通用的函数式编程术语；“将 x 与 y 连接” 通常意味着构建一个新的容器而将 x 的元素放在新容器的开头，其后则是容器 y 的元素。</p>
<p>cons list 通过递归调用 <code>cons</code> 函数产生。代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。注意这不同于第六章中的 “null” 或 “nil” 的概念，他们代表无效或缺失的值。</p>
</blockquote>
<p>注意虽然函数式编程语言经常使用 cons list，但是它并不是一个 Rust 中常见的类型。大部分在 Rust 中需要列表的时候，<code>Vec&lt;T&gt;</code> 是一个更好的选择。其他更为复杂的递归数据类型 <strong>确实</strong> 在 Rust 的很多场景中很有用，不过通过以 cons list 作为开始，我们可以探索如何使用 box 毫不费力的定义一个递归数据类型。</p>
<!-- If there isn't a better example for introducing box, I think we need more
justification for using cons lists here. This is supposed to be showing why box
is useful, but we're saying the thing we use box for isn't useful either. What
is it useful for, then? -->
<!-- We've tried to clarify. This is just a simple example to introduce box so
that the reader can use these concepts in more complicated situations. A more
realistic example would be quite a bit more complicated and obscure why a box
is useful even more. /Carol -->
<p>示例 15-2 包含一个 cons list 的枚举定义。注意这还不能编译因为这个类型没有已知的大小，之后我们会展示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">示例 15-2：第一次尝试定义一个代表 <code>i32</code> 值的 cons list 数据结构的枚举</span></p>
<blockquote>
<p>注意：出于示例的需要我们选择实现一个只存放 <code>i32</code> 值的 cons list。也可以用泛型实现它，正如第十章讲到的，来定义一个可以存放任何类型值的 cons list 类型。</p>
</blockquote>
<!-- any reason, in that case, that we use i32s here? Does it just provide a
more stable example? -->
<!-- It's a simpler example; the value within each item doesn't matter much for
the example; i32 is the default integer type so we chose that. I'm not sure
what you mean by stable? /Carol-->
<p>使用这个 cons list 来储存列表 <code>1, 2, 3</code> 将看起来如示例 15-3 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">示例 15-3：使用 <code>List</code> 枚举储存列表 <code>1, 2, 3</code></span></p>
<p>第一个 <code>Cons</code> 储存了 <code>1</code> 和另一个 <code>List</code> 值。这个 <code>List</code> 是另一个包含 <code>2</code> 的 <code>Cons</code> 值和下一个 <code>List</code> 值。接着又有另一个存放了 <code>3</code> 的 <code>Cons</code> 值和最后一个值为 <code>Nil</code> 的 <code>List</code>，非递归成员代表了列表的结尾。</p>
<p>如果尝试编译上面的代码，会得到如示例 15-4 所示的错误：</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt;
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">示例 15-4：尝试定义一个递归枚举时得到的错误</span></p>
<!-- above-- but isn't that the definition of a cons list that we gave earlier,
that is must hold a value of itself? As you can see, I'm struggling with the
cons definition at the moment! -->
<!-- Yes, this type is the most literal translation of the concept of a concept
to a Rust type, but it's not allowed in Rust. We have to use box to make the
variant hold a pointer to the next value, not the actual value itself. We've
tried to clarify throughout this section. /Carol -->
<p>这个错误表明这个类型 “有无限的大小”。其原因是 <code>List</code> 的一个成员被定义为是递归的：它直接存放了另一个相同类型的值。这意味着 Rust 无法计算为了存放 <code>List</code> 值到底需要多少空间。让我们一点一点来看：首先了解一下 Rust 如何决定需要多少空间来存放一个非递归类型。</p>
<a class="header" href="print.html#a计算非递归类型的大小" id="a计算非递归类型的大小"><h3>计算非递归类型的大小</h3></a>
<p>回忆一下第六章讨论枚举定义时示例 6-2 中定义的 <code>Message</code> 枚举：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p>当 Rust 需要知道要为 <code>Message</code> 值分配多少空间时，它可以检查每一个成员并发现 <code>Message::Quit</code> 并不需要任何空间，<code>Message::Move</code> 需要足够储存两个 <code>i32</code> 值的空间，依此类推。因此，<code>Message</code> 值所需的空间等于储存其最大成员的空间大小。</p>
<p>与此相对当 Rust 编译器检查像示例 15-2 中的 <code>List</code> 这样的递归类型时会发生什么呢。编译器尝试计算出储存一个 <code>List</code> 枚举需要多少内存，并开始检查 <code>Cons</code> 成员，那么 <code>Cons</code> 需要的空间等于 <code>i32</code> 的大小加上 <code>List</code> 的大小。为了计算 <code>List</code> 需要多少内存，它检查其成员，从 <code>Cons</code> 成员开始。<code>Cons</code>成员储存了一个 <code>i32</code> 值和一个<code>List</code>值，这样的计算将无限进行下去，如图 15-5 所示：</p>
<p><img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 15-5：一个包含无限个 <code>Cons</code> 成员的无限 <code>List</code></span></p>
<a class="header" href="print.html#a使用-boxt-给递归类型一个已知的大小" id="a使用-boxt-给递归类型一个已知的大小"><h3>使用 <code>Box&lt;T&gt;</code> 给递归类型一个已知的大小</h3></a>
<p>Rust 无法计算出要为定义为递归的类型分配多少空间，所以编译器给出了示例 15-4 中的错误。这个错误也包括了有用的建议：</p>
<pre><code class="language-text">= help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
        make `List` representable
</code></pre>
<p>在建议中，“indirection” 意味着不同于直接储存一个值，我们将间接的储存一个指向值的指针。</p>
<p>因为 <code>Box&lt;T&gt;</code> 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。</p>
<p>所以可以将 <code>Box</code> 放入 <code>Cons</code> 成员中而不是直接存放另一个 <code>List</code> 值。<code>Box</code> 会指向另一个位于堆上的 <code>List</code> 值，而不是存放在 <code>Cons</code> 成员中。从概念上讲，我们仍然有一个通过在其中 “存放” 其他列表创建的列表，不过现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。</p>
<p>我们可以修改示例 15-2 中 <code>List</code> 枚举的定义和示例 15-3 中对 <code>List</code> 的应用，如示例 15-6 所示，这是可以编译的：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">示例 15-6：为了拥有已知大小而使用 <code>Box&lt;T&gt;</code> 的 <code>List</code> 定义</span></p>
<p><code>Cons</code> 成员将会需要一个 <code>i32</code> 的大小加上储存 box 指针数据的空间。<code>Nil</code> 成员不储存值，所以它比 <code>Cons</code> 成员需要更少的空间。现在我们知道了任何 <code>List</code> 值最多需要一个 <code>i32</code> 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 <code>List</code> 值需要的大小了。图 15-7 展示了现在 <code>Cons</code> 成员看起来像什么：</p>
<p><img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">图 15-7：因为 <code>Cons</code> 存放一个 <code>Box</code> 所以 <code>List</code> 不是无限大小的了</span></p>
<p>box 只提供了间接存储和堆分配；他们并没有任何其他特殊的功能，比如我们将会见到的其他智能指针。他们也没有这些特殊功能带来的性能损失，所以他们可以用于像 cons list 这样间接存储是唯一所需功能的场景。我们还将在第十七章看到 box 的更多应用场景。</p>
<p><code>Box&lt;T&gt;</code> 类型是一个智能指针，因为它实现了 <code>Deref</code> trait，它允许 <code>Box&lt;T&gt;</code> 值被当作引用对待。当 <code>Box&lt;T&gt;</code> 值离开作用域时，由于 <code>Box&lt;T&gt;</code> 类型 <code>Drop</code> trait 的实现，box 所指向的堆数据也会被清除。让我们更详细的探索一下这两个 trait；这些 trait 在本章余下讨论的其他智能指针所提供的功能中将会更为重要。</p>
<!-- so deref and drop are features of Box and not of smart pointers? Or of
both? I'm not sure it's clear -->
<!-- We've tried to clarify. We wanted to demonstrate one smart pointer before
getting into these traits since they don't make much sense out of context, but
they're more important to understand before explaining the more complicated
smart pointers /Carol -->
<a class="header" href="print.html#a通过-deref-trait-将智能指针当作常规引用处理" id="a通过-deref-trait-将智能指针当作常规引用处理"><h2>通过 <code>Deref</code> trait 将智能指针当作常规引用处理</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-02-deref.md">ch15-02-deref.md</a>
<br>
commit d06a6a181fd61704cbf7feb55bc61d518c6469f9</p>
</blockquote>
<p>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong>（<em>dereference operator</em>）<code>*</code>（与乘法运算符或 glob 运算符相区别）。通过这种方式实现 <code>Deref</code> trait 可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。</p>
<!-- Why would we want to override the dereference operator? Can you lay that
out? -->
<!-- Attempted above. /Carol -->
<!-- I'd suggest introducing what you mean by "convenient" here, if we are
using it as the reason we want to use Deref -->
<!-- I've removed convenient from the first paragraph and foreshadowed in a
different way in the below paragraph /Carol -->
<p>让我们首先看看 <code>*</code> 如何处理引用，接着尝试定义我们自己的类 <code>Box&lt;T&gt;</code> 类型并看看为何 <code>*</code> 不能像引用一样工作。我们会探索如何实现 <code>Deref</code> trait 使得智能指针以类似引用的方式工作变为可能。最后，我们会讨论 Rust 的 <strong>解引用强制多态</strong>（<em>deref coercions</em>）功能和它是如何一同处理引用或智能指针的。</p>
<a class="header" href="print.html#a通过--追踪指针的值" id="a通过--追踪指针的值"><h3>通过 <code>*</code> 追踪指针的值</h3></a>
<!-- I want to avoid too much cross referencing, I think it can be distracting,
make the reader feel they need to flip back but they don't really, here -->
<!-- Ok, guess we went too far then! I've been adding *more* cross referencing
so that the reader can go back if they've forgotten something we've already
covered. /Carol -->
<!--Oh! I see, de-reference, meaning we cut the tie between the data and the
reference? I've assumed so above, please correct if not! -->
<!-- I wouldn't describe it as "cutting the tie"; the tie is still there. It's
more like we're following an arrow (the pointer) to find the value. Let us know
if this explanation is still unclear. /Carol -->
<p>常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。在示例 15-8 中，创建了一个 <code>i32</code> 值的引用接着使用解引用运算符来跟踪所引用的数据：</p>
<!-- We'll start with an example of dereferencing and re-allocating references
to `i32` values: -->
<!-- Is this what this is an example of? -->
<!-- No, there isn't any re-allocation happening here; allocation is a term
that means asking for more space in order to hold data (as we covered in
chapter 4). What were you trying to convey with "re-allocating", exactly? Have
we addressed whatever was confusing here before? /Carol -->
<!-- We've reworked the following sections in this chapter heavily because the
`Mp3` example seemed to be confusing with the metadata that was involved.
Interested to see if this breakdown works better or not. /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">示例 15-8：使用解引用运算符来跟踪 <code>i32</code> 值的引用</span></p>
<p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code> 等于 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来追踪引用所指向的值（也就是 <strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p>
<p>相反如果尝试编写 <code>assert_eq!(5, y);</code>，则会得到如下编译错误：</p>
<pre><code class="language-text">error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>不允许比较数字的引用与数字，因为它们是不同的类型。必须使用 <code>*</code> 追踪引用所指向的值。</p>
<a class="header" href="print.html#a像引用一样使用-boxt" id="a像引用一样使用-boxt"><h3>像引用一样使用 <code>Box&lt;T&gt;</code></h3></a>
<p>可以重写示例 15-8 中的代码来使用 <code>Box&lt;T&gt;</code> 而不是引用，同时借引用运算符也一样能工作，如示例 15-9 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">示例 15-9：在 <code>Box&lt;i32&gt;</code> 上使用解引用运算符</span></p>
<p>相比示例 15-8 唯一修改的地方就是将 <code>y</code> 设置为一个指向 <code>x</code> 值的 box 实例，而不是指向 <code>x</code> 值的引用。在最后的断言中，可以使用解引用运算符以 <code>y</code> 为引用时相同的方式追踪 box 的指针。让我们通过实现自己的 box 类型来探索 <code>Box&lt;T&gt;</code> 能这么做有何特殊之处。</p>
<a class="header" href="print.html#a自定义智能指针" id="a自定义智能指针"><h3>自定义智能指针</h3></a>
<p>为了体会默认智能指针的行为不同于引用，让我们创建一个类似于标准库提供的 <code>Box&lt;T&gt;</code> 类型的智能指针。接着会学习如何增加使用解引用运算符的功能。</p>
<p>从根本上说，<code>Box&lt;T&gt;</code> 被定义为包含一个元素的元组结构体，所以示例 15-10 以相同的方式定义了 <code>MyBox&lt;T&gt;</code> 类型。我们还定义了 <code>new</code> 函数来对应定义于 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函数：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 15-10：定义 <code>MyBox&lt;T&gt;</code> 类型</span></p>
<p>这里定义了一个结构体 <code>MyBox</code> 并声明了一个泛型 <code>T</code>，因为我们希望其可以存放任何类型的值。<code>MyBox</code> 是一个包含 <code>T</code> 类型元素的元组结构体。<code>MyBox::new</code> 函数获取一个 <code>T</code> 类型的参数并返回一个存放传入值的 <code>MyBox</code> 实例。</p>
<p>尝试将示例 15-9 中的代码加入示例 15-10 中并修改 <code>main</code> 使用我们定义的 <code>MyBox&lt;T&gt;</code> 类型代替 <code>Box&lt;T&gt;</code>。示例 15-11 中的代码不能编译，因为 Rust 不知道如何解引用 <code>MyBox</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">示例 15-11：尝试以使用引用和 <code>Box&lt;T&gt;</code> 相同的方式使用 <code>MyBox&lt;T&gt;</code></span></p>
<p>得到的编译错误是：</p>
<pre><code class="language-text">error: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p><code>MyBox&lt;T&gt;</code> 类型不能解引用我们并没有为其实现这个功能。为了启用 <code>*</code> 运算符的解引用功能，可以实现 <code>Deref</code> trait。</p>
<a class="header" href="print.html#a实现-deref-trait-定义如何像引用一样对待某类型" id="a实现-deref-trait-定义如何像引用一样对待某类型"><h3>实现 <code>Deref</code> trait 定义如何像引用一样对待某类型</h3></a>
<p>如第十章所讨论的，为了实现 trait，需要提供 trait 所需的方法实现。<code>Deref</code> trait，由标准库提供，要求实现名为 <code>deref</code> 的方法，其借用 <code>self</code> 并返回一个内部数据的引用。示例 15-12 包含定义于 <code>MyBox</code> 之上的 <code>Deref</code> 实现：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Deref;

# struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 15-12：<code>MyBox&lt;T&gt;</code> 上的 <code>Deref</code> 实现</span></p>
<p><code>type Target = T;</code> 语法定义了用于此 trait 的关联类型。关联类型是一个稍有不同的定义泛型参数的方式，现在还无需过多的担心它；第十九章会详细介绍。</p>
<!-- Is it possible to just use a method for declaring a generic parameter we
have seen before, so we can focus on the deref trait here? -->
<!-- No, this is how the `Deref` trait is defined in the standard library, so
this is what you have to specify in order to implement it. /Carol -->
<p><code>deref</code> 方法体中写入了 <code>&amp;self.0</code>，这样 <code>deref</code> 返回了我希望通过 <code>*</code> 运算符访问的值的引用。示例 15-11 中的 <code>main</code> 函数中对 <code>MyBox&lt;T&gt;</code> 值的 <code>*</code> 调用现在可以编译并能通过断言了！</p>
<p>没有 <code>Deref</code> trait 的话，编译器只能解引用 <code>&amp;</code> 引用。<code>Deref</code> trait 的 <code>deref</code> 方法为编译器提供了获取任何实现了 <code>Deref</code> 的类型值的能力，为了获取其知道如何解引用的 <code>&amp;</code> 引用编译器可以调用 <code>deref</code> 方法。</p>
<p>当我们在示例 15-11 中输入 <code>*y</code> 时，Rust 事实上在底层运行了如下代码：</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!-- why is that happening behind the scenes, rather than us just calling this
up front? -->
<!-- we've tried to clarify below /Carol -->
<p>Rust 将 <code>*</code> 运算符替换为 <code>deref</code> 方法调用和一个普通解引用，如此我们便无需担心是否需要调用 <code>deref</code> 方法。Rust 的这个功能让我们可以编写同时处理常规引用或实现了 <code>Deref</code> 的类型的代码。</p>
<p><code>deref</code> 方法返回值的引用，以及 <code>*(y.deref())</code> 括号外边的普通解引用仍为必须的原因在于所有权。如果 <code>deref</code> 方法直接返回值而不是值的引用，其值（的所有权）将被移出 <code>self</code>。在这里以及大部分使用解引用运算符的情况下我们并不希望获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权。</p>
<p>注意将 <code>*</code> 替换为 <code>deref</code> 调用和 <code>*</code> 调用的过程在每次使用 <code>*</code> 的时候都会发生一次。<code>*</code> 的替换并不会无限递归进行。最终的数据类型是 <code>i32</code>，它与示例 15-11 中 <code>assert_eq!</code> 的 <code>5</code> 相匹配。</p>
<a class="header" href="print.html#a函数和方法的隐式解引用强制多态" id="a函数和方法的隐式解引用强制多态"><h3>函数和方法的隐式解引用强制多态</h3></a>
<!--Below -- "A deref coercion happens when..." So this isn't something the
reader is making happen, but something that just happens behind the scene? If
not, can you change this to an active tone? -->
<!-- Yes, it is something that happens behind the scenes, which is why we
describe it as implicit. /Carol -->
<p><strong>解引用强制多态</strong>（<em>deref coercions</em>）是 Rust 出于方便的考虑作用于函数或方法的参数的。其将实现了 <code>Deref</code> 的类型的引用转换为 <code>Deref</code> 所能够将原始类型转换的类型的引用。解引用强制多态发生于当作为参数传递给函数或方法的特定类型的引用不同于函数或方法签名中定义参数类型的时候，这时会有一系列的 <code>deref</code> 方法调用会将提供的类型转换为参数所需的类型。</p>
<p>解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 <code>&amp;</code> 和 <code>*</code> 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。</p>
<p>作为展示解引用强制多态的实例，让我们使用示例 15-10 中定义的 <code>MyBox&lt;T&gt;</code>，以及示例 15-12 中增加的 <code>Deref</code> 实现。示例 15-13 展示了一个有着字符串 slice 参数的函数定义：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
#}</code></pre></pre>
<p><span class="caption">示例 15-13：<code>hello</code> 函数有着 <code>&amp;str</code> 类型的参数 <code>name</code></span></p>
<p>可以使用字符串 slice 作为参数调用 <code>hello</code> 函数，比如 <code>hello(&quot;Rust&quot;);</code>。解引用强制多态使得用 <code>MyBox&lt;String&gt;</code> 类型值的引用调用 <code>hello</code> 成为可能，如示例 15-14 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">示例 15-14：因为解引用强制多态，使用 <code>MyBox&lt;String&gt;</code> 的引用调用 <code>hello</code> 是可行的</span></p>
<p>这里使用 <code>&amp;m</code> 调用 <code>hello</code> 函数，其为 <code>MyBox&lt;String&gt;</code> 值的引用。因为示例 15-12 中在 <code>MyBox&lt;T&gt;</code> 上实现了 <code>Deref</code> trait，Rust 可以通过 <code>deref</code> 调用将 <code>&amp;MyBox&lt;String&gt;</code> 变为 <code>&amp;String</code>。标准库中提供了 <code>String</code> 上的 <code>Deref</code> 实现，其会返回字符串 slice，这可以在 <code>Deref</code> 的 API 文档中看到。Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 变为 <code>&amp;str</code>，这就符合 <code>hello</code> 函数的定义了。</p>
<p>如果 Rust 没有实现解引用强制多态，为了使用 <code>&amp;MyBox&lt;String&gt;</code> 类型的值调用 <code>hello</code>，则不得不编写示例 15-15 中的代码来代替示例 15-14：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">示例 15-15：如果 Rust 没有解引用强制多态则必须编写的代码</span></p>
<p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 <code>String</code>。接着 <code>&amp;</code> 和 <code>[..]</code> 获取了整个 <code>String</code> 的字符串 slice 来匹配 <code>hello</code> 的签名。没有解引用强制多态所有这些符号混在一起将更难以读写和理解。解引用强制多态使得 Rust 自动的帮我们处理这些转换。</p>
<p>当所涉及到的类型定义了 <code>Deref</code> trait，Rust 会分析这些类型并使用任意多次 <code>Deref::deref</code> 调用以获得匹配参数的类型。这些解析都发生在编译时，所以利用解引用强制多态并没有运行时惩罚！</p>
<a class="header" href="print.html#a解引用强制多态如何与可变性交互" id="a解引用强制多态如何与可变性交互"><h3>解引用强制多态如何与可变性交互</h3></a>
<!-- below: are we talking about any mutable references, or are we talking
about mutable generic types, below? Can you make sure it's clear throughout, I
wasn't 100% -->
<!-- I'm not sure what you're asking, *types* don't have the property of
mutability or immutability, it's the variables or references to *instances* of
those types that are mutable or immutable. Also the way to say "any mutable
reference" is with `&mut` and a generic type parameter. Is that what's
confusing? /Carol -->
<p>类似于如何使用 <code>Deref</code> trait 重载不可变引用的 <code>*</code> 运算符，Rust 提供了 <code>DerefMut</code> trait 用于重载可变引用的 <code>*</code> 运算符。</p>
<p>Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：</p>
<!-- Would it make sense to move this list to the start of the deref section?
-->
<!-- I don't think this list makes very much sense until you understand what
deref coercion *is*. Can you elaborate on why you think it should be moved to
the beginning? /Carol -->
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li>
</ul>
<p>头两个情况除了可变性之外是相同的：第一种情况表明如果有一个 <code>&amp;T</code>，而 <code>T</code> 实现了返回 <code>U</code> 类型的 <code>Deref</code>，则可以直接得到 <code>&amp;U</code>。第二种情况表明对于可变引用也有着相同的行为。</p>
<p>最后一个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 <strong>不可能</strong> 的：不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。因此，Rust 无法假设将不可变引用转换为可变引用是可能的。</p>
<!-- Why does it coerce to an immutable reference, and why cant it go the other
way?-->
<!-- Elaborated above /Carol-->
<a class="header" href="print.html#a使用-drop-trait-运行清理代码" id="a使用-drop-trait-运行清理代码"><h2>使用 <code>Drop</code> Trait 运行清理代码</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-03-drop.md">ch15-03-drop.md</a>
<br>
commit 6060440d67759b7c8627b4d97cb69576057f5fa6</p>
</blockquote>
<p>对于智能指针模式来说另一个重要的 trait 是 <code>Drop</code>。<code>Drop</code> 允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。我们在智能指针上下文中讨论 <code>Drop</code> 是因为其功能几乎总是用于实现智能指针。例如，<code>Box&lt;T&gt;</code> 自定义了 <code>Drop</code> 用来释放 box 所指向的堆空间。</p>
<p>在其他一些语言中，我们不得不记住在每次使用完智能指针实例后调用清理内存或资源的代码。如果忘记的话，运行代码的系统可能会因为负荷过重而崩溃。在 Rust 中，可以指定一些代码应该在值离开作用域时被执行，而编译器会自动插入这些代码。于是我们就不需要在程序中到处编写在实例结束时清理这些变量的代码——而且还不会泄露资源了。</p>
<p>这意味着无需记住在所有处理完这些类型实例后调用清理代码，而仍然不会泄露资源！</p>
<p>指定在值离开作用域时应该执行的代码的方式是实现 <code>Drop</code> trait。<code>Drop</code> trait 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。为了能够看出 Rust 何时调用 <code>drop</code>，让我们暂时使用 <code>println!</code> 语句实现 <code>drop</code>。</p>
<p>示例 15-16 展示了唯一定制功能就是当其实例离开作用域时打印出 <code>Dropping CustomSmartPointer!</code> 的结构体 <code>CustomSmartPointer</code>。这会演示 Rust 何时运行 <code>drop</code> 函数：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">示例 15-14：结构体 <code>CustomSmartPointer</code>，其实现了放置清理代码的 <code>Drop</code> trait</span></p>
<p><code>Drop</code> trait 包含在 prelude 中，所以无需导入它。我们在 <code>CustomSmartPointer</code> 上实现了 <code>Drop</code> trait，并提供了一个调用 <code>println!</code> 的 <code>drop</code> 方法实现。<code>drop</code> 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方。这里选择打印一些文本以展示 Rust 何时调用 <code>drop</code>。</p>
<p>在 <code>main</code> 中，我们新建了两个 <code>CustomSmartPointer</code> 实例并打印出了 <code>CustomSmartPointer created.</code>。在 <code>main</code> 的结尾，<code>CustomSmartPointer</code> 的实例会离开作用域，而 Rust 会调用放置于 <code>drop</code> 方法中的代码，打印出最后的信息。注意无需显示调用 <code>drop</code> 方法：</p>
<p>当运行这个程序，会出现如下输出：</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>当实例离开作用域 Rust 会自动调用 <code>drop</code>，并调用我们指定的代码。变量以被创建时相反的顺序被丢弃，所以 <code>d</code> 在 <code>c</code> 之前被丢弃。这个例子刚好给了我们一个 drop 方法如何工作的可视化指导，不过通常需要指定类型所需执行的清理代码而不是打印信息。</p>
<a class="header" href="print.html#a通过-stdmemdrop-提早丢弃值" id="a通过-stdmemdrop-提早丢弃值"><h4>通过 <code>std::mem::drop</code> 提早丢弃值</h4></a>
<p>不幸的是，我们并不能直截了当的禁用 <code>drop</code> 这个功能。通常也不需要禁用 <code>drop</code> ；整个 <code>Drop</code> trait 存在的意义在于其是自动处理的。然而，有时你可能需要提早清理某个值。一个例子是当使用智能指针管理锁时；你可能希望强制运行 <code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁。Rust 并不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法；当我们希望在作用域结束之前就释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>。</p>
<p>如果我们像是示例 15-14 那样尝试调用 <code>Drop</code> trait 的 <code>drop</code> 方法，就会得到像示例 15-15 那样的编译错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">示例 15-15：尝试手动调用 <code>Drop</code> trait 的 <code>drop</code> 方法提早清理</span></p>
<p>如果尝试编译代码会得到如下错误：</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<p>错误信息表明不允许显式调用 <code>drop</code>。错误信息使用了术语 <strong>析构函数</strong>（<em>destructor</em>），这是一个清理实例的函数的通用编程概念。<strong>析构函数</strong> 对应创建实例的 <strong>构造函数</strong>。Rust 中的 <code>drop</code> 函数就是这么一个析构函数。</p>
<p>Rust 不允许我们显式调用 <code>drop</code> 因为 Rust 仍然会在 <code>main</code> 的结尾对值自动调用 <code>drop</code>，这会导致一个 <strong>double free</strong> 错误，因为 Rust 会尝试清理相同的值两次。</p>
<p>因为不能禁用当值离开作用域时自动插入的 <code>drop</code>，并且不能显示调用 <code>drop</code>，如果我们需要提早清理值，可以使用 <code>std::mem::drop</code> 函数。</p>
<p><code>std::mem::drop</code> 函数不同于 <code>Drop</code> trait 中的 <code>drop</code> 方法。可以通过传递希望提早强制丢弃的值作为参数。<code>std::mem::drop</code> 位于 prelude，所以我们可以修改示例 15-15 中的 <code>main</code> 来调用 <code>drop</code> 函数如示例 15-16 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct CustomSmartPointer {
#     data: String,
# }
#
# impl Drop for CustomSmartPointer {
#     fn drop(&amp;mut self) {
#         println!(&quot;Dropping CustomSmartPointer!&quot;);
#     }
# }
#
fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">示例 15-16: 在值离开作用域之前调用 <code>std::mem::drop</code> 显式清理</span></p>
<p>运行这段代码会打印出如下：</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p><code>Dropping CustomSmartPointer with data `some data`!</code> 出现在 <code>CustomSmartPointer created.</code> 和 <code>CustomSmartPointer dropped before the end of main.</code> 之间，表明了 <code>drop</code> 方法被调用了并在此丢弃了 <code>c</code>。</p>
<p><code>Drop</code> trait 实现中指定的代码可以用于许多方面来使得清理变得方便和安全：比如可以用其创建我们自己的内存分配器！通过 <code>Drop</code> trait 和 Rust 所有权系统，你无需担心之后清理代码，Rust 会自动考虑这些问题。</p>
<p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 <code>drop</code> 只会在值不再被使用时被调用一次。</p>
<p>使用 <code>Drop</code> trait 实现指定的代码在很多方面都使得清理值变得方便和安全：比如可以使用它来创建我们自己的内存分配器！通过<code>Drop</code> trait 和 Rust 所有权系统，就无需担心之后清理代码，因为 Rust 会自动考虑这些问题。如果代码在值仍被使用时就清理它会出现编译错误，因为所有权系统确保了引用总是有效的，这也就保证了<code>drop</code>只会在值不再被使用时被调用一次。</p>
<p>现在我们学习了 <code>Box&lt;T&gt;</code> 和一些智能指针的特性，让我们聊聊一些其他标准库中定义的智能指针。</p>
<a class="header" href="print.html#rct-引用计数智能指针" id="rct-引用计数智能指针"><h2><code>Rc&lt;T&gt;</code> 引用计数智能指针</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-04-rc.md">ch15-04-rc.md</a>
<br>
commit 071b97540bca12fd416d2ea7a2daa5d3e9c74400</p>
</blockquote>
<p>大部分情况下所有权是非常明确的：可以准确的知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。</p>
<!-- Can you give an example or two for when a variable needs multiple owners?
-->
<!-- Done /Carol -->
<p>为了启用多所有权，Rust 有一个叫做 <code>Rc&lt;T&gt;</code> 的类型。其名称为 <strong>引用计数</strong>（<em>reference counting</em>）的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p>
<p>可以将其想象为客厅中的电视。当一个人进来看电视时，他打开电视。其他人也可以进来看电视。当最后一个人离开房间时，他关掉电视因为它不再被使用了。如果某人在其他人还在看的时候就关掉了电视，正在看电视的人肯定会抓狂的！</p>
<p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的那一部分会最后结束使用它的时候。如果确实知道哪部分会结束使用的话，就可以令其成为数据的所有者同时正常的所有权规则就可以在编译时生效。</p>
<p>注意 <code>Rc&lt;T&gt;</code> 只能用于单线程场景；第十六章并发会涉及到如何在多线程程序中进行引用计数。</p>
<a class="header" href="print.html#a使用-rct-共享数据" id="a使用-rct-共享数据"><h3>使用 <code>Rc&lt;T&gt;</code> 共享数据</h3></a>
<p>让我们回到示例 15-6 中使用 <code>Box&lt;T&gt;</code> 定义 cons list 的例子。这一次，我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如图 15-19 所示：</p>
<p><img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">图 15-19: 两个列表, <code>b</code> 和 <code>c</code>, 共享第三个列表 <code>a</code> 的所有权</span></p>
<p>列表 <code>a</code> 包含 5 之后是 10，之后是另两个列表：<code>b</code> 从 3 开始而 <code>c</code> 从 4 开始。<code>b</code> 和 <code>c</code> 会接上包含 5 和 10 的列表 <code>a</code>。换句话说，这两个列表会尝试共享第一个列表所包含的 5 和 10。</p>
<p>尝试使用 <code>Box&lt;T&gt;</code> 定义的 <code>List</code> 并实现不能工作，如示例 15-20 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">示例 15-20: 展示不能用两个 <code>Box&lt;T&gt;</code> 的列表尝试共享第三个列表的所有权</span></p>
<p>编译会得出如下错误：</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not
   implement the `Copy` trait
</code></pre>
<p><code>Cons</code> 成员拥有其储存的数据，所以当创建 <code>b</code> 列表时，<code>a</code> 被移动进了 <code>b</code> 这样 <code>b</code> 就拥有了 <code>a</code>。接着当再次尝使用 <code>a</code> 创建 <code>c</code> 时，这不被允许因为 <code>a</code> 的所有权已经被移动。</p>
<p>可以改变 <code>Cons</code> 的定义来存放一个引用，不过接着必须指定生命周期参数。通过指定生命周期参数，表明列表中的每一个元素都至少与列表本身存在的一样久。例如，借用检查器不会允许 <code>let a = Cons(10, &amp;Nil);</code> 编译，因为临时值 <code>Nil</code> 会在 <code>a</code> 获取其引用之前就被丢弃了。</p>
<p>相反，我们修改 <code>List</code> 的定义为使用 <code>Rc&lt;T&gt;</code> 代替 <code>Box&lt;T&gt;</code>，如列表 15-21 所示。现在每一个 <code>Cons</code> 变量都包含一个值和一个指向 <code>List</code> 的 <code>Rc</code>。当创建 <code>b</code> 时，不同于获取 <code>a</code> 的所有权，这里会克隆 <code>a</code> 所包含的 <code>Rc</code>，这会将引用计数从 1 增加到 2 并允许 <code>a</code> 和 <code>b</code> 共享 <code>Rc</code> 中数据的所有权。创建 <code>c</code> 时也会克隆 <code>a</code>，这会将引用计数从 2 增加为 3。每次调用 <code>Rc::clone</code>，<code>Rc</code> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理：</p>
<!-- And what will Rc do that's different here, how will the ownership of a b
c change? Could you write a paragraph equivalent to the one describing the cons
variants above? That was really useful -->
<!-- I'm not sure which paragraph about cons you're talking about, but I've
tried to guess /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">示例 15-21: 使用 <code>Rc&lt;T&gt;</code> 定义的 <code>List</code></span></p>
<p>需要为 <code>Rc</code> 增加<code>use</code>语句因为它不在 prelude 中。在 <code>main</code> 中创建了存放 5 和 10 的列表并将其存放在 <code>a</code> 的新的 <code>Rc</code> 中。接着当创建 <code>b</code> 和 <code>c</code> 时，调用 <code>Rc::clone</code> 函数并传递 <code>a</code> 中 <code>Rc</code> 的引用作为参数。</p>
<p>也可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，不过在这里 Rust 的习惯是使用 <code>Rc::clone</code>。<code>Rc::clone</code> 的实现并不像大部分类型的 <code>clone</code> 实现那样对所有数据进行深拷贝。<code>Rc::clone</code> 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间，所以通过使用 <code>Rc::clone</code> 进行引用计数，可以明显的区别可能会对运行时性能有巨大影响的深拷贝和不分配内存的对运行时性能影响相对较小的增加引用计数拷贝。</p>
<a class="header" href="print.html#a克隆-rct-会增加引用计数" id="a克隆-rct-会增加引用计数"><h3>克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</h3></a>
<p>让我们修改示例 15-21 的代码以便观察创建和丢弃 <code>a</code> 中 <code>Rc</code> 的引用时引用计数的变化。</p>
<!-- Below -- can you let the reader know why we are doing this? What does it
show us/improve? Is this our working version of the code, or just illustrating
reference count? -->
<!-- This is illustrating reference counting /Carol -->
<p>在示例 15-22 中，修改了 <code>main</code> 以便将列表 <code>c</code> 置于内部作用域中，这样就可以观察当 <code>c</code> 离开作用域时引用计数如何变化。在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 <code>Rc::strong_count</code> 函数获得。在本章稍后的部分讨论避免引用循环时会解释为何这个函数叫做 <code>strong_count</code> 而不是 <code>count</code>。</p>
<!-- If we need to talk about this later, that might indicate that this chapter
is out of order --- should the section on reference cycles come first? -->
<!-- It's not possible to create reference cycles until we've explained both
`Rc` and `RefCell`, so we don't see a way to reorder these sections. The
"strong" is the only detail from that section relevant here; we just want to
have the reader ignore that detail for now but know that we will explain it in
a bit. /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">示例 15-22：打印出引用计数</span></p>
<p>这会打印出：</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<!-- is there a reason we call `a` rc here, and not just `a`? -->
<!-- Yes, because it's not `a`, it's the strong count of the `Rc` in `a`. We've
changed the text to hopefully be clearer. /Carol -->
<p>我们能够看到 <code>a</code> 中 <code>Rc</code> 的初始引用计数为一，接着每次调用 <code>clone</code>，计数会增加一。当 <code>c</code> 离开作用域时，计数减一。不必像调用 <code>Rc::clone</code> 增加引用计数那样调用一个函数来减少计数；<code>Drop</code> trait 的实现当 <code>Rc</code> 值离开作用域时自动减少引用计数。</p>
<p>从这个例子我们所不能看到的是在 <code>main</code> 的结尾当 <code>b</code> 然后是 <code>a</code> 离开作用域时，此处计数会是 0，同时 <code>Rc</code> 被完全清理。使用 <code>Rc</code> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p>
<p><code>Rc&lt;T&gt;</code> 允许通过不可变引用来只读的在程序的多个部分共享数据。如果 <code>Rc&lt;T&gt;</code> 也允许多个可变引用，则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。不过可以修改数据是非常有用的！在下一部分，我们将讨论内部可变性模式和 <code>RefCell&lt;T&gt;</code> 类型，它可以与 <code>Rc&lt;T&gt;</code> 结合使用来处理不可变性的限制。</p>
<a class="header" href="print.html#refcellt-和内部可变性模式" id="refcellt-和内部可变性模式"><h2><code>RefCell&lt;T&gt;</code> 和内部可变性模式</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-05-interior-mutability.md">ch15-05-interior-mutability.md</a>
<br>
commit 54169ef43f57847913ebec7e021c1267663a5d12</p>
</blockquote>
<!-- I'm concerned here about referencing forward too much, do we need that
information from Ch 19 to understand this? Should we look at rearranging a few
things here? -->
<!-- We don't think the reader needs to *understand* `unsafe` at this point,
just that `unsafe` is how this is possible and that we'll learn about `unsafe`
later. After reading this section, did you feel that you needed to know more
about `unsafe` to understand this section? /Carol -->
<!--below: as in, we use the pattern, or it's used automatically? I'm not clear
on what's the user's responsibility with this pattern -->
<!-- When we choose to use types implemented using the interior mutability
pattern, or when we implement our own types using the interior mutability
pattern. /Carol -->
<p><strong>内部可变性</strong>（<em>Interior mutability</em>）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时改变数据，这通常是借用规则所不允许的。为此，该模式在数据结构中使用 <code>unsafe</code> 代码来模糊 Rust 通常的可变性和借用规则。我们还未讲到不安全代码；第十九章会学习它们。当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型。所涉及的 <code>unsafe</code> 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。</p>
<p>让我们通过遵循内部可变性模式的 <code>RefCell&lt;T&gt;</code> 类型来开始探索。</p>
<a class="header" href="print.html#a通过-refcellt-在运行时检查借用规则" id="a通过-refcellt-在运行时检查借用规则"><h3>通过 <code>RefCell&lt;T&gt;</code> 在运行时检查借用规则</h3></a>
<p>不同于 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 代表其数据的唯一的所有权。那么是什么让 <code>RefCell&lt;T&gt;</code> 不同于像 <code>Box&lt;T&gt;</code> 这样的类型呢？回忆一下第四章所学的借用规则：</p>
<ol>
<li>在任意给定时间，<strong>只能</strong> 拥有如下中的一个：</li>
</ol>
<ul>
<li>一个可变引用。</li>
<li>任意数量的不可变引用。</li>
</ul>
<ol start="2">
<li>引用必须总是有效的。</li>
</ol>
<p>对于引用和 <code>Box&lt;T&gt;</code>，借用规则的不可变性作用于编译时。对于 <code>RefCell&lt;T&gt;</code>，这些不可变性作用于 <strong>运行时</strong>。对于引用，如果违反这些规则，会得到一个编译错误。而对于<code>RefCell&lt;T&gt;</code>，违反这些规则会 <code>panic!</code>。</p>
<!-- Is there an advantage to having these rules enforced at different times?
-->
<!-- Yes, that's what we were trying to say below, we've tried to make this more explicit /Carol -->
<p>在编译时检查借用规则的好处是这些错误将在开发过程的早期被捕获同时对没有运行时性能影响，因为所有的分析都提前完成了。为此，在编译时检查借用规则是大部分情况的最佳选择，这也正是其为何是 Rust 的默认行为。</p>
<p>相反在运行时检查借用规则的好处是特定内存安全的场景是允许的，而它们在编译时检查中是不允许的。静态分析，正如 Rust 编译器，是天生保守的。代码的一些属性则不可能通过分析代码发现：其中最著名的就是 <a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">停机问题（Halting Problem）</a>，这超出了本书的范畴，不过如果你感兴趣的话这是一个值得研究的有趣主题。</p>
<!--below: can't be sure of what, exactly? Sure that the code complies with the
ownership rules? -->
<!-- Yes /Carol -->
<p>因为一些分析是不可能的，如果 Rust 编译器不能通过所有权规则编译，它可能会拒绝一个正确的程序；从这种角度考虑它是保守的。如果 Rust 接受不正确的程序，那么人们也就不会相信 Rust 所做的保证了。然而，如果 Rust 拒绝正确的程序，会给程序员带来不便，但不会带来灾难。<code>RefCell&lt;T&gt;</code> 正是用于当你确信代码遵守借用规则，而编译器不能理解和确定的时候。</p>
<p>类似于 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 只能用于单线程场景。如果尝试在多线程上下文中使用<code>RefCell&lt;T&gt;</code>，会得到一个编译错误。第十六章会介绍如何在多线程程序中使用 <code>RefCell&lt;T&gt;</code> 的功能。</p>
<!-- I'm not really clear at this point what the difference between Rc<T> and
RefCell<T> is, perhaps a succinct round up would help? -->
<!-- Done /Carol -->
<p>如下为选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p>
<ul>
<li><code>Rc&lt;T&gt;</code> 允许相同数据有多个所有者；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li>
<li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变（或可变）借用检查；<code>Rc&lt;T&gt;</code>仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变（或可变）借用检查。</li>
<li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下修改其内部的值。</li>
</ul>
<p>最后一个理由便是指 <strong>内部可变性</strong> 模式。让我们看看何时内部可变性是有用的，并讨论这是如何成为可能的。</p>
<a class="header" href="print.html#a内部可变性不可变值的可变借用" id="a内部可变性不可变值的可变借用"><h3>内部可变性：不可变值的可变借用</h3></a>
<p>借用规则的一个推论是当有一个不可变值时，不能可变的借用它。例如，如下代码不能编译：</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>如果尝试编译，会得到如下错误：</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<p>然而，特定情况下在值的方法内部能够修改自身是很有用的；而不是在其他代码中，此时值仍然是不可变。值方法外部的代码不能修改其值。<code>RefCell&lt;T&gt;</code> 是一个获得内部可变性的方法。<code>RefCell&lt;T&gt;</code> 并没有完全绕开借用规则，编译器中的借用检查器允许内部可变性并相应的在运行时检查借用规则。如果违反了这些规则，会得到 <code>panic!</code> 而不是编译错误。</p>
<p>让我们通过一个实际的例子来探索何处可以使用 <code>RefCell&lt;T&gt;</code> 来修改不可变值并看看为何这么做是有意义的。</p>
<a class="header" href="print.html#a内部可变性的用例mock-对象" id="a内部可变性的用例mock-对象"><h4>内部可变性的用例：mock 对象</h4></a>
<p><strong>测试替身</strong>（<em>test double</em>）是一个通用编程概念，它代表一个在测试中替代某个类型的类型。<strong>mock 对象</strong> 是特定类型的测试替身，它们记录测试过程中发生了什么以便可以断言操作是正确的。</p>
<p>虽然 Rust 没有与其他语言中的对象完全相同的对象，Rust 也没有像其他语言那样在标准库中内建 mock 对象功能，不过我们确实可以创建一个与 mock 对象有着相同功能的结构体。</p>
<p>如下是一个我们想要测试的场景：我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。</p>
<p>该库只提供记录与最大值的差距，以及何种情况发送什么消息的功能。使用此库的程序则期望提供实际发送消息的机制：程序可以选择记录一条消息、发送 email、发送短信等等。库本身无需知道这些细节；只需实现其提供的 <code>Messenger</code> trait 即可。示例 15-23 展示了库代码：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 15-23：一个记录某个值与最大值差距的库，并根据此值的特定级别发出警告</span></p>
<p>这些代码中一个重要部分是拥有一个方法 <code>send</code> 的 <code>Messenger</code> trait，其获取一个 <code>self</code> 的不可变引用和文本信息。这是我们的 mock 对象所需要拥有的接口。另一个重要的部分是我们需要测试 <code>LimitTracker</code> 的 <code>set_value</code> 方法的行为。可以改变传递的 <code>value</code> 参数的值，不过 <code>set_value</code> 并没有返回任何可供断言的值。也就是说，如果使用某个实现了 <code>Messenger</code> trait 的值和特定的 <code>max</code> 创建 <code>LimitTracker</code>，当传递不同 <code>value</code> 值时，消息发送者应被告知发送合适的消息。</p>
<p>我们所需的 mock 对象是，调用 <code>send</code> 不同于实际发送 email 或短息，其只记录信息被通知要发送了。可以新建一个 mock 对象示例，用其创建 <code>LimitTracker</code>，调用 <code>LimitTracker</code> 的 <code>set_value</code> 方法，然后检查 mock 对象是否有我们期望的消息。示例 15-24 展示了一个如此尝试的 mock 对象实现，不过借用检查器并不允许：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 15-24：尝试实现 <code>MockMessenger</code>，借用检查器并不允许</span></p>
<p>测试代码定义了一个 <code>MockMessenger</code> 结构体，其 <code>sent_messages</code> 字段为一个 <code>String</code> 值的 <code>Vec</code> 用来记录被告知发送的消息。我们还定义了一个关联函数 <code>new</code> 以便于新建从空消息列表开始的 <code>MockMessenger</code> 值。接着为 <code>MockMessenger</code> 实现 <code>Messenger</code> trait 这样就可以为 <code>LimitTracker</code> 提供一个 <code>MockMessenger</code>。在 <code>send</code> 方法的定义中，获取传入的消息作为参数并储存在 <code>MockMessenger</code> 的 <code>sent_messages</code> 列表中。</p>
<p>在测试中，我们测试了当 <code>LimitTracker</code> 被告知将 <code>value</code> 设置为超过 <code>max</code> 值 75% 的某个值。首先新建一个 <code>MockMessenger</code>，其从空消息列表开始。接着新建一个 <code>LimitTracker</code> 并传递新建 <code>MockMessenger</code> 的引用和 <code>max</code> 值 100。我们使用值 80 调用 <code>LimitTracker</code> 的 <code>set_value</code> 方法，这超过了 100 的 75%。接着断言 <code>MockMessenger</code> 中记录的消息列表应该有一条消息。</p>
<p>然而，这个测试是有问题的：</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --&gt; src/lib.rs:46:13
   |
45 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
46 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<p>不能修改 <code>MockMessenger</code> 来记录消息，因为 <code>send</code> 方法获取 <code>self</code> 的不可变引用。我们也不能参考错误文本的建议使用 <code>&amp;mut self</code> 替代，因为这样 <code>send</code> 的签名就不符合 <code>Messenger</code> trait 定义中的签名了（请随意尝试如此修改并看看会出现什么错误信息）。</p>
<p>这正是内部可变性的用武之地！我们将通过 <code>RefCell</code> 来储存 <code>sent_messages</code>，然而 <code>send</code> 将能够修改 <code>sent_messages</code> 并储存消息。示例 15-25 展示了代码：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
#         limit_tracker.set_value(75);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 15-25：使用 <code>RefCell&lt;T&gt;</code> 能够在外部值被认为是不可变的情况下修改内部值</span></p>
<p>现在 <code>sent_messages</code> 字段的类型是 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 而不是 <code>Vec&lt;String&gt;</code>。在 <code>new</code> 函数中新建了一个 <code>RefCell</code> 示例替代空 vector。</p>
<p>对于 <code>send</code> 方法的实现，第一个参数仍为 <code>self</code> 的不可变借用，这是符合方法定义的。我们调用 <code>self.sent_messages</code> 中 <code>RefCell</code> 的 <code>borrow_mut</code> 方法来获取 <code>RefCell</code> 中值的可变引用，这是一个 vector。接着可以对 vector 的可变引用调用 <code>push</code> 以便记录测试过程中看到的消息。</p>
<p>最后必须做出的修改位于断言中：为了看到其内部 vector 中有多少个项，需要调用 <code>RefCell</code> 的 <code>borrow</code> 以获取 vector 的不可变引用。</p>
<p>现在我们见识了如何使用 <code>RefCell&lt;T&gt;</code>，让我们研究一下它怎样工作的！</p>
<a class="header" href="print.html#refcellt-在运行时检查借用规则" id="refcellt-在运行时检查借用规则"><h3><code>RefCell&lt;T&gt;</code> 在运行时检查借用规则</h3></a>
<p>当创建不可变和可变引用时，我们分别使用 <code>&amp;</code> 和 <code>&amp;mut</code> 语法。对于 <code>RefCell&lt;T&gt;</code> 来说，则是 <code>borrow</code> 和 <code>borrow_mut</code> 方法，这属于 <code>RefCell&lt;T&gt;</code> 安全 API 的一部分。<code>borrow</code> 方法返回 <code>Ref</code> 类型的智能指针，<code>borrow_mut</code> 方法返回 <code>RefMut</code> 类型的智能指针。这两个类型都实现了 <code>Deref</code> 所以可以当作常规引用对待。</p>
<!-- can you clarify what you mean, practically, by "track borrows
dynamically"?-->
<!-- Yep, we've tried to clarify in the next paragraph. /Carol -->
<p><code>RefCell&lt;T&gt;</code> 记录当前有多少个活动的 <code>Ref</code> 和 <code>RefMut</code> 智能指针。每次调用 <code>borrow</code>，<code>RefCell&lt;T&gt;</code> 将活动的不可变借用计数加一。当 <code>Ref</code> 值离开作用域时，不可变借用计数减一。就像编译时借用规则一样，<code>RefCell&lt;T&gt;</code> 在任何时候只允许有多个不可变借用或一个可变借用。</p>
<p>如果我们尝试违反这些规则，相比引用时的编译时错误，<code>RefCell&lt;T&gt;</code> 的实现会在运行时 <code>panic!</code>。示例 15-26 展示了对示例 15-25 中 <code>send</code> 实现的修改，这里我们故意尝试在相同作用域创建两个可变借用以便演示 <code>RefCell&lt;T&gt;</code> 不允许我们在运行时这么做：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<p><span class="caption">示例 15-26：在同一作用域中创建两个可变引用并观察 <code>RefCell&lt;T&gt;</code> panic</span></p>
<p>这里为 <code>borrow_mut</code> 返回的 <code>RefMut</code> 智能指针创建了 <code>one_borrow</code> 变量。接着用相同的方式在变量 <code>two_borrow</code> 创建了另一个可变借用。这会在相同作用域中创建一个可变引用，这是不允许的，如果运行库的测试，编译时不会有任何错误，不过测试会失败：</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
    thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
    'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>可以看到代码 panic 和信息<code>already borrowed: BorrowMutError</code>。这也就是 <code>RefCell&lt;T&gt;</code> 如何在运行时处理违反借用规则的情况。</p>
<p>在运行时捕获借用错误而不是编译时意味着将会在开发过程的后期才会发现错误 ———— 甚至有可能发布到生产环境才发现。还会因为在运行时而不是编译时记录借用而导致少量的运行时性能惩罚。然而，使用 <code>RefCell</code> 使得在只允许不可变值的上下文中编写修改自身以记录消息的 mock 对象成为可能。虽然有取舍，但是我们可以选择使用 <code>RefCell&lt;T&gt;</code> 来获得比常规引用所能提供的更多的功能。</p>
<a class="header" href="print.html#a结合-rct-和-refcellt-来拥有多个可变数据所有者" id="a结合-rct-和-refcellt-来拥有多个可变数据所有者"><h3>结合 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 来拥有多个可变数据所有者</h3></a>
<p><code>RefCell&lt;T&gt;</code> 的一个常见用法是与 <code>Rc&lt;T&gt;</code> 结合。回忆一下 <code>Rc&lt;T&gt;</code> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问。如果有一个储存了 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code> 的话，就可以得到有多个所有者 <strong>并且</strong> 可以修改的值了！</p>
<!-- maybe just recap on why we'd want that? -->
<!-- done, below /Carol -->
<p>例如，回忆示例 15-13 的 cons list 的例子中使用 <code>Rc&lt;T&gt;</code> 使得多个列表共享另一个列表的所有权。因为 <code>Rc&lt;T&gt;</code> 只存放不可变值，所以一旦创建了这些列表值后就不能修改。让我们加入 <code>RefCell&lt;T&gt;</code> 来获得修改列表中值的能力。示例 15-27 展示了通过在 <code>Cons</code> 定义中使用 <code>RefCell&lt;T&gt;</code>，我们就允许修改所有列表中的值了：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">示例 15-27：使用 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 创建可以修改的 <code>List</code></span></p>
<p>这里创建了一个 <code>Rc&lt;RefCell&lt;i32&gt;</code> 实例并储存在变量 <code>value</code> 中以便之后直接访问。接着在 <code>a</code> 中用包含 <code>value</code> 的 <code>Cons</code> 成员创建了一个 <code>List</code>。需要克隆 <code>value</code> 以便 <code>a</code> 和 <code>value</code> 都能拥有其内部值 <code>5</code> 的所有权，而不是将所有权从 <code>value</code> 移动到 <code>a</code> 或者让 <code>a</code> 借用 <code>value</code>。</p>
<!-- above: so that `value` has ownership of what, in addition to a? I didn't
follow the final sentence above -->
<!-- Of the inner value, I've tried to clarify /Carol -->
<p>我们将列表 <code>a</code> 封装进了 <code>Rc&lt;T&gt;</code> 这样当创建列表 <code>b</code> 和 <code>c</code> 时，他们都可以引用 <code>a</code>，正如示例 15-13 一样。</p>
<p>一旦创建了列表 <code>a</code>、<code>b</code> 和 <code>c</code>，我们将 <code>value</code> 的值加 10。为此对 <code>value</code> 调用了 <code>borrow_mut</code>，这里使用了第五章讨论的自定解引用功能（“<code>-&gt;</code>运算符到哪去了？”）来解引用 <code>Rc&lt;T&gt;</code> 以获取其内部的 <code>RefCell&lt;T&gt;</code> 值。<code>borrow_mut</code> 方法返回 <code>RefMut&lt;T&gt;</code> 智能指针，可以对其使用解引用运算符并修改其内部值。</p>
<p>当我们打印出 <code>a</code>、<code>b</code> 和 <code>c</code> 时，可以看到他们都拥有修改后的值 15 而不是 5：</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>这是非常巧妙的！通过使用 <code>RefCell&lt;T&gt;</code>，我们可以拥有一个表面上不可变的 <code>List</code>，不过可以使用 <code>RefCell&lt;T&gt;</code> 中提供内部可变性的方法来在需要时修改数据。<code>RefCell&lt;T&gt;</code> 的运行时借用规则检查也确实保护我们免于出现数据竞争，而且我们也决定牺牲一些速度来换取数据结构的灵活性。</p>
<p>标准库中也有其他提供内部可变性的类型，比如 <code>Cell&lt;T&gt;</code>，它有些类似（<code>RefCell&lt;T&gt;</code>）除了相比提供内部值的引用，其值被拷贝进和拷贝出 <code>Cell&lt;T&gt;</code>。还有 <code>Mutex&lt;T&gt;</code>，其提供线程间安全的内部可变性，下一章并发会讨论它的应用。请查看标准库来获取更多细节和不同类型之间的区别。</p>
<a class="header" href="print.html#a引用循环与内存泄漏" id="a引用循环与内存泄漏"><h2>引用循环与内存泄漏</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-06-reference-cycles.md">ch15-06-reference-cycles.md</a>
<br>
commit cd7d9bcfb099c224439db0ba3b02956d9843864d</p>
</blockquote>
<p>Rust 的内存安全保证使其 <strong>难以</strong> 意外的制造永远也不会被清理的内存（被称为 <strong>内存泄露</strong>（<em>memory leak</em>）），但并不是不可能。完全的避免内存泄露并不是同在编译时拒绝数据竞争一样为 Rust 的保证之一，这意味着内存泄露在 Rust 被认为是内存安全的。这一点可以通过 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 看出：有可能会创建个个项之间相互引用的引用。这会造成内存泄露，因为每一项的引用计数将永远也到不了 0，其值也永远也不会被丢弃。</p>
<a class="header" href="print.html#a制造引用循环" id="a制造引用循环"><h3>制造引用循环</h3></a>
<p>让我们看看引用循环是如何发生的以及如何避免它。以示例 15-28 中的 <code>List</code> 枚举和 <code>tail</code> 方法的定义开始：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre>
<p><span class="caption">示例：一个存放 <code>RefCell</code> 的 cons list 定义，这样可以修改 <code>Cons</code> 成员所引用的数据</span></p>
<p>这里采用了示例 15-6 中 <code>List</code> 定义的另一种变体。现在 <code>Cons</code> 成员的第二个元素是 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>，这意味着不同于像示例 15-19 那样能够修改 <code>i32</code> 的值，我们希望能够修改 <code>Cons</code> 成员所指向的 <code>List</code>。这里还增加了一个 <code>tail</code> 方法来方便我们在有 <code>Cons</code> 成员的时候访问其第二项。</p>
<!-- Can you link this more clearly, what do we have at this point? This change
to a new listing feels unexpected. What are we going to do with this cons list?
Why are we making this next listing, what is it's overall purpose? -->
<!-- I'm not sure if the new listing you're talking about being unexpected is
referring to the listing above or the listing below? The listing above is just
definitions we're going to use, the listing below is the `main` function that
uses the definitions. We just broke these apart to avoid having a lot of code
and then a lot of explanation, I'd be fine having this be one big listing if
you think that would be better /Carol -->
<p>在示例 15-29 中增加了一个 <code>main</code> 函数，其使用了示例 15-28 中的定义。这些代码在 <code>a</code> 中创建了一个列表，一个指向 <code>a</code> 中列表的 <code>b</code> 列表，接着修改 <code>b</code> 中的列表指向 <code>a</code> 中的列表，这会创建一个引用循环。在这个过程的多个位置有 <code>println!</code> 语句展示引用计数。</p>
<!-- so are we adding this to the end of the previous listing? It's in the same
file -->
<!-- yes /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use List::{Cons, Nil};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle; it will
    // overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">示例 15-29：创建一个引用循环：两个<code>List</code> 值互相指向彼此</span></p>
<p>这里在变量 <code>a</code> 中创建了一个 <code>Rc</code> 实例来存放初值为 <code>5, Nil</code> 的 <code>List</code> 值。接着在变量 <code>b</code> 中创建了存放包含值 10 和指向列表 <code>a</code> 的 <code>List</code> 的另一个 <code>Rc</code> 实例。</p>
<p>最后，修改 <code>a</code> 使其指向 <code>b</code> 而不是 <code>Nil</code>，这就创建了一个循环。为此需要使用 <code>tail</code> 方法获取 <code>a</code> 中 <code>RefCell</code> 的引用，并放入变量 <code>link</code> 中。接着使用 <code>RefCell</code> 的 <code>borrow_mut</code> 方法将其值从存放 <code>Nil</code> 的 <code>Rc</code> 修改为 <code>b</code> 中的 <code>Rc</code>。</p>
<p>如果保持最后的 <code>println!</code> 行注释并运行代码，会得到如下输出：</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>可以看到将 <code>a</code> 修改为指向 <code>b</code> 之后，<code>a</code> 和 <code>b</code> 中都有的 <code>Rc</code> 实例的引用计数为 2。在 <code>main</code> 的结尾，Rust 会尝试首先丢弃 <code>b</code>，这会使 <code>a</code> 和 <code>b</code> 中 <code>Rc</code> 实例的引用计数减一。</p>
<!-- Above -- previously `a` and `b` said `Rc`, I wanted to clarify that by Rc
we mean a and b, is that right? -->
<!-- There's lots of stuff in `a` and `b`; we specifically mean the `Rc` values
here which is why we said `Rc`. I've tried to say both `a` & `b` and `Rc` here
instead, to be most precise. What do you think? /Carol -->
<!-- Below--"that Rc" - what are we referring to, a is still referencing b? Can
you clarify that? -->
<!-- Yes, the `Rc` in `b`. /Carol -->
<p>然而，因为 <code>a</code> 仍然引用 <code>b</code> 中的 <code>Rc</code>，<code>Rc</code> 的引用计数是 1 而不是 0，所以 <code>Rc</code> 在堆上的内存不会被丢弃。其内存会因为引用计数为 1 而永远停留。</p>
<p>为了更形象的展示，我们创建了一个如图 15-30 所示的引用循环：</p>
<p><img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" /></p>
<p><span class="caption">图 15-30: 列表 <code>a</code> 和 <code>b</code> 彼此互相指向形成引用循环</span></p>
<p>如果取消最后 <code>println!</code> 的注释并运行程序，Rust 会尝试打印出 <code>a</code> 指向 <code>b</code> 指向 <code>a</code> 这样的循环直到栈溢出。</p>
<!-- Can you show us the output? Also, why are we commenting out the print
statement in the first place?-->
<!-- We have the last println commented out to begin with because otherwise you
get a LOT of output until the stack overflows. We thought that would be
confusing and make it harder to see the reference counts we're printing out
before that point. Did you try the code with and without that line commented
out? Which one would make a better first experience when running this code?
/Carol -->
<p>这个特定的例子中，创建了引用循环之后程序立刻就结束了。这个循环的结果并不可怕。如果在更为复杂的程序中并在循环里分配了很多内存并占有很长时间，这个程序会使用多于它所需要的内存，并有可能压垮系统并造成没有内存可供使用。</p>
<p>创建引用循环并不容易，但也不是不可能。如果你有包含<code>Rc&lt;T&gt;</code>的<code>RefCell&lt;T&gt;</code>值或类似的嵌套结合了内部可变性和引用计数的类型，请务必小心确保你没有形成一个引用循环；你无法指望 Rust 帮你捕获它们。创建引用循环是一个程序上的逻辑 bug，你应该使用自动化测试、代码评审和其他软件开发最佳实践来使其最小化。</p>
<!-- Above-- this seems like a vague solution, just not writing the code that
creates cycles, can you be more specific about which part they should
exclude/change? -->
<!-- Not really, this example was deliberately creating a reference cycle, so
if you don't want reference cycles, you shouldn't write this code. It's similar
to a logic bug-- if you want your program to add 2 to a number instead of 50,
then you have to type 2 rather than typing 50. I'm not sure how to be more
specific or helpful here; I've referenced writing tests and other things that
can help mitigate logic bugs. /Carol -->
<p>另一个解决方案是重新组织数据结构使得一些引用有所有权而另一些则没有。如此，循环将由一些有所有权的关系和一些没有所有权的关系，而只有所有权关系才影响值是否被丢弃。在示例 15-28 中，我们总是希望 <code>Cons</code> 成员拥有其列表，所以重新组织数据结构是不可能的。让我们看看一个由父结点和子结点构成的图的例子，观察何时无所有权关系是一个好的避免引用循环的方法。</p>
<a class="header" href="print.html#a避免引用循环将-rct-变为-weakt" id="a避免引用循环将-rct-变为-weakt"><h3>避免引用循环：将 <code>Rc&lt;T&gt;</code> 变为 <code>Weak&lt;T&gt;</code></h3></a>
<p>到目前为止，我们已经展示了调用 <code>Rc::clone</code> 会增加 <code>Rc</code> 实例的 <code>strong_count</code>，和 <code>Rc</code> 实例只在其 <code>strong_count</code> 为 0 时才会被清理。也可以通过调用 <code>Rc::downgrade</code> 并传递 <code>Rc</code> 实例的引用来创建其值的 <strong>弱引用</strong>（<em>weak reference</em>）。调用 <code>Rc::downgrade</code> 时会得到 <code>Weak&lt;T&gt;</code> 类型的智能指针。不同于将 <code>Rc</code> 实例的 <code>strong_count</code> 加一，调用 <code>Rc::downgrade</code> 会将 <code>weak_count</code> 加一。<code>Rc</code> 类型使用 <code>weak_count</code> 来记录其存在多少个 <code>Weak&lt;T&gt;</code> 引用，类似于 <code>strong_count</code>。其区别在于 <code>weak_count</code> 无需计数为 0 就能使 <code>Rc</code> 实例被清理。</p>
<!-- What is a weak_count? I don't think we've defined that, or strong_count,
really. Are we just giving another variable to store the count that has no
input on whether memory is dropped? When is a count stored in strong_count and
when is it stored in weak_count? -->
<!-- We're not giving `Rc` another variable, the standard library has defined
`Rc` to have both the `strong_count` and `weak_count` as fields. I've tried to
clarify the paragraph above to address your questions. /Carol -->
<p>强引用代表如何共享 <code>Rc</code> 实例的引用。弱引用并不代表所有权关系。他们不会造成引用循环，因为任何引入了弱引用的循环一旦所涉及的强引用计数为 0 就会被打破。</p>
<!-- Below: I'm struggling to follow here, why do we want to get a value from
Weak<T>? This section is losing me somewhat, can you slow this down, make sure
you define anything new up front and give it’s purpose, what we intend it to
do? -->
<!-- I've tried to clarify /Carol -->
<p>因为 <code>Weak&lt;T&gt;</code> 引用的值可能已经被丢弃了，为了使用 <code>Weak&lt;T&gt;</code> 所指向的值，我们必须确保其值仍然有效。为此可以调用 <code>Weak&lt;T&gt;</code> 实例的 <code>upgrade</code> 方法，这会返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。如果 <code>Rc</code> 值还未被丢弃则结果是 <code>Some</code>，如果 <code>Rc</code> 已经被丢弃则结果是 <code>None</code>。因为 <code>upgrade</code> 返回一个 <code>Option</code>，我们确信 Rust 会处理 <code>Some</code> 和 <code>None</code>的情况，并且不会有一个无效的指针。</p>
<p>作为一个例子，不同于使用一个某项只知道其下一项的列表，我们会创建一个某项知道其子项 <strong>和</strong> 父项的树形结构。</p>
<a class="header" href="print.html#a创建树形数据结构带有子结点的-node" id="a创建树形数据结构带有子结点的-node"><h4>创建树形数据结构：带有子结点的 <code>Node</code></h4></a>
<p>让我们从一个叫做 <code>Node</code> 的存放拥有所有权的 <code>i32</code> 值和其子 <code>Node</code> 值引用的结构体开始：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>我们希望能够 <code>Node</code> 拥有其子结点，同时也希望变量可以拥有每个结点以便可以直接访问他们。为此 <code>Vec</code> 的项的类型被定义为 <code>Rc&lt;Node&gt;</code>。我们还希望能改其他结点的子结点，所以 <code>children</code> 中 <code>Vec</code> 被放进了 <code>RefCell</code>。</p>
<p>接下来，使用此结构体定义来创建一个叫做 <code>leaf</code> 的带有值 3 且没有子结点的 <code>Node</code> 实例，和另一个带有值 5 并以 <code>leaf</code> 作为子结点的实例 <code>branch</code>，如示例 15-31 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::Rc;
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">示例 15-31：创建没有子结点的 <code>leaf</code> 结点和以 <code>leaf</code> 作为子结点的 <code>branch</code> 结点</span></p>
<p>这里克隆了 <code>leaf</code> 中的 <code>Rc</code> 并储存在了 <code>branch</code> 中，这意味着 <code>leaf</code> 中的 <code>Node</code> 现在有两个所有者：<code>leaf</code>和<code>branch</code>。可以通过 <code>branch.children</code> 从 <code>branch</code> 中获得 <code>leaf</code>，不过无法从 <code>leaf</code> 到 <code>branch</code>。<code>leaf</code> 没有到 <code>branch</code> 的引用且并不知道他们相互关联。我们希望 <code>leaf</code> 知道 <code>branch</code> 是其父结点。</p>
<a class="header" href="print.html#a增加从子到父的引用" id="a增加从子到父的引用"><h4>增加从子到父的引用</h4></a>
<p>为了使子结点知道其父结点，需要在 <code>Node</code> 结构体定义中增加一个 <code>parent</code> 字段。问题是 <code>parent</code> 的类型应该是什么。我们知道其不能包含 <code>Rc&lt;T&gt;</code>，因为这样 <code>leaf.parent</code> 将会指向 <code>branch</code> 而 <code>branch.children</code> 会包含 <code>leaf</code> 的指针，这会形成引用循环，会造成其 <code>strong_count</code> 永远也不会为 0.</p>
<p>现在换一种方式思考这个关系，父结点应该拥有其子结点：如果父结点被丢弃了，其子结点也应该被丢弃。然而子结点不应该拥有其父结点：如果丢弃子结点，其父结点应该依然存在。这正是弱引用的例子！</p>
<p>所以 <code>parent</code> 使用 <code>Weak&lt;T&gt;</code> 类型而不是 <code>Rc</code>，具体来说是 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>。现在 <code>Node</code> 结构体定义看起来像这样：</p>
<!-- I think because I still don't understand what Weak<T> is, I’m not really
sure what it means for the parent to use Weak<T>, can you make sure that’s
clear at this point -->
<!-- I've tried, I'm not sure though /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<!-- Can you fill out this line, above; talk through the syntax, too? Also,
below, how does this mean a node can refer to a parent without owning it?
What's is actually doing here?-->
<!-- The first line is importing `Weak` from the standard library; the reader
really should be familiar with bringing types into scope by this point, don't
you think? It seems repetitive to explain this every time. /Carol
-->
<p>这样，一个结点就能够引用其父结点，但不拥有其父结点。在示例 15-32 中，我们更新 <code>main</code> 来使用新定义以便 <code>leaf</code> 结点可以引用其父结点：</p>
<!-- Why are we updating it, what are we doing here? Can you make that clear?
-->
<!-- Done /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">示例 15-32：一个 <code>leaf</code> 结点，其拥有指向其父结点 <code>branch</code> 的 <code>Weak</code> 引用</span></p>
<!-- Below: looks similar to what? What are we doing with this listing, can you
talk it through -->
<p>创建 <code>leaf</code> 结点类似于示例 15-31 中如何创建 <code>leaf</code> 结点的，除了 <code>parent</code> 字段有所不同：<code>leaf</code> 开始时没有父结点，所以我们新建了一个空的 <code>Weak</code> 引用实例。</p>
<p>此时，当尝试使用 <code>upgrade</code> 方法获取 <code>leaf</code> 的父结点引用时，会得到一个 <code>None</code> 值。如第一个 <code>println!</code> 输出所示：</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<!-- Is this the explanation of the previous program? If so, can you change the
tone to an active tone, make it clear that it's connected? I'm struggling to
connect things up -->
<!-- I've tried, this will be better with wingdings /Carol -->
<p>当创建 <code>branch</code> 结点时，其也会新建一个 <code>Weak</code> 引用，因为 <code>branch</code> 并没有父结点。<code>leaf</code> 仍然作为 <code>branch</code> 的一个子结点。一旦在 <code>branch</code> 中有了 <code>Node</code> 实例，就可以修改 <code>leaf</code> 使其拥有指向父结点的 <code>Weak</code> 引用。这里使用了 <code>leaf</code> 中 <code>parent</code> 字段里的 <code>RefCell</code> 的 <code>borrow_mut</code> 方法，接着使用了 <code>Rc::downgrade</code> 函数来从 <code>branch</code> 中的 <code>Rc</code> 值创建了一个指向 <code>branch</code> 的 <code>Weak</code> 引用。</p>
<!-- Below: What does this mean for our program, that now leaf recognizes its
parent? -->
<!-- Yes /Carol -->
<p>当再次打印出 <code>leaf</code> 的父结点时，这一次将会得到存放了 <code>branch</code> 的 <code>Some</code> 值：现在 <code>leaf</code> 可以访问其父结点了！当打印出 <code>leaf</code> 时，我们也避免了如示例 15-29 中最终会导致栈溢出的循环：<code>Weak</code> 引用被打印为 <code>(Weak)</code>：</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>没有无限的输出表明这段代码并没有造成引用循环。这一点也可以从观察 <code>Rc::strong_count</code> 和 <code>Rc::weak_count</code> 调用的结果看出。</p>
<a class="header" href="print.html#a可视化-strong_count-和-weak_count-的改变" id="a可视化-strong_count-和-weak_count-的改变"><h4>可视化 <code>strong_count</code> 和 <code>weak_count</code> 的改变</h4></a>
<p>让我们通过创建了一个新的内部作用域并将 <code>branch</code> 的创建放入其中，来观察 <code>Rc</code> 实例的 <code>strong_count</code> 和 <code>weak_count</code> 值的变化。这会展示当 <code>branch</code> 创建和离开作用域被丢弃时会发生什么。这些修改如示例 15-33 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });
        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre>
<p><span class="caption">示例 15-33：在内部作用域创建 <code>branch</code> 并检查其强弱引用计数</span></p>
<p>一旦创建了 <code>leaf</code>，其 <code>Rc</code> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 <code>branch</code> 并与 <code>leaf</code> 相关联，此时 <code>branch</code> 中 <code>Rc</code> 的强引用计数为 1，弱引用计数为 1（因为 <code>leaf.parent</code> 通过 <code>Weak&lt;T&gt;</code> 指向 <code>branch</code>）。这里 <code>leaf</code> 的强引用计数为 2，因为现在 <code>branch</code> 的 <code>branch.children</code> 中储存了 <code>leaf</code> 的 <code>Rc</code> 的拷贝，不过弱引用计数仍然为 0。</p>
<p>当内部作用域结束时，<code>branch</code> 离开作用域，其强引用计数减少为 0，所以其 <code>Node</code> 被丢弃。来自 <code>leaf.parent</code> 的弱引用计数 1 与 <code>Node</code> 是否被丢弃无关，所以并没有产生任何内存泄露！</p>
<p>如果在内部作用域结束后尝试访问 <code>leaf</code> 的父结点，会再次得到 <code>None</code>。在程序的结尾，<code>leaf</code> 中 <code>Rc</code> 的强引用计数为 1，弱引用计数为 0，因为现在 <code>leaf</code> 又是 <code>Rc</code> 唯一的引用了。</p>
<!-- Just to clarify, leaf is pointing to itself? -->
<!-- `leaf` is the variable pointing to the `Rc`, the `Rc` is what has the
strong and weak counts. /Carol -->
<p>所有这些管理计数和值的逻辑都内建于 <code>Rc</code> 和 <code>Weak</code> 以及它们的 <code>Drop</code> trait 实现中。通过在 <code>Node</code> 定义中指定从子结点到父结点的关系为一个<code>Weak&lt;T&gt;</code>引用，就能够拥有父结点和子结点之间的双向引用而不会造成引用循环和内存泄露。</p>
<!-- Ah! This actually cleared up a lot, we specify in the definition that a
reference should be weak and therefore ignored by the Drop trait, is that
right? It would really help to specify that up front, can you add something
like that to the start of the Weak section? -->
<!-- Done /Carol -->
<a class="header" href="print.html#a总结-14" id="a总结-14"><h2>总结</h2></a>
<p>这一章涵盖了如何使用智能指针来做出不同于 Rust 常规引用默认所提供的保证与取舍。<code>Box&lt;T&gt;</code> 有一个已知的大小并指向分配在堆上的数据。<code>Rc&lt;T&gt;</code> 记录了堆上数据的引用数量以便可以拥有多个所有者。<code>RefCell&lt;T&gt;</code> 和其内部可变性提供了一个可以用于当需要不可变类型但是需要改变其内部值能力的类型，并在运行时而不是编译时检查借用规则。</p>
<p>我们还介绍了提供了很多智能指针功能的 trait <code>Deref</code> 和 <code>Drop</code>。同时探索了会造成内存泄露的引用循环，以及如何使用 <code>Weak&lt;T&gt;</code> 来避免它们。</p>
<p>如果本章内容引起了你的兴趣并希望现在就实现你自己的智能指针的话，请阅读 <a href="https://doc.rust-lang.org/stable/nomicon/">“The Nomicon”</a> 来获取更多有用的信息。</p>
<p>接下来，让我们谈谈 Rust 的并发。我们还会学习到一些新的对并发有帮助的智能指针。</p>
<a class="header" href="print.html#a无畏并发" id="a无畏并发"><h1>无畏并发</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-00-concurrency.md">ch16-00-concurrency.md</a>
<br>
commit 90406bd5a4cd4447b46cd7e03d33f34a651e9bb7</p>
</blockquote>
<p>安全并高效的处理并发编程是 Rust 的另一个主要目标。<strong>并发编程</strong>（<em>Concurrent programming</em>），代表程序的不同部分相互独立的执行，而 <strong>并行编程</strong>（<em>parallel programming</em>）代表程序不同部分于同时执行，这两个概念随着计算机越来越多的利用多处理器的优势时显得愈发重要。由于历史原因，在此类上下文中编程一直是困难且容易出错的：Rust 希望能改变这一点。</p>
<p>起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。随着时间的推移，团队发现所有权和类型系统是一系列解决内存安全 <strong>和</strong> 并发问题的强有力的工具！通过改进所有权和类型检查，Rust 很多并发错误都是 <strong>编译时</strong> 错误，而非运行时错误。因此，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，Rust 会拒绝编译不正确的代码并提供解释问题的错误信息。因此，你可以在开发时而不是不慎部署到生产环境后修复代码。我们给 Rust 的这一部分起了一个绰号 <strong>无畏并发</strong>（<em>fearless concurrency</em>）。无畏并发令你的代码免于出现诡异的 bug 并可以轻松重构且无需担心会引入新的 bug。</p>
<blockquote>
<p>注意：出于简洁的考虑，我们将很多问题归为并发，而不是更准确的区分并发和（或）并行。如果这是一本专注于并发和/或并行的书，我们肯定会更加精确的。对于本章，当我们谈到并发时，请自行脑内替换为并发和（或）并行。</p>
</blockquote>
<p>很多语言所提供的处理并发问题的解决方法都非常有特色。例如，Erlang 有着优雅的消息传递并发功能，但只有模糊不清的在线程间共享状态的方法。对于高级语言来说，只实现可能解决方案的子集是一个合理的策略，因为高级语言所许诺的价值来源于牺牲一些控制来换取抽象。然而对于底层语言则期望提供在任何给定的情况下有着最高的性能且对硬件有更少的抽象。因此，Rust 提供了多种工具，以符合实际情况和需求的方式来为问题建模。</p>
<p>如下是本章将要涉及到的内容：</p>
<ul>
<li>如何创建线程来同时运行多段代码。</li>
<li><strong>消息传递</strong>（<em>Message passing</em>）并发，其中通道（channel）被用来在线程间传递消息。</li>
<li><strong>共享状态</strong>（<em>Shared state</em>）并发，其中多个线程可以访问同一片数据。</li>
<li><code>Sync</code> 和 <code>Send</code> trait，他们允许 Rust 的并发保证能被扩展到用户定义的和标准库中提供的类型中。</li>
</ul>
<a class="header" href="print.html#a使用线程同时运行代码" id="a使用线程同时运行代码"><h2>使用线程同时运行代码</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-01-threads.md">ch16-01-threads.md</a>
<br>
commit 90406bd5a4cd4447b46cd7e03d33f34a651e9bb7</p>
</blockquote>
<p>在大部分现代操作系统中，执行中程序的代码运行于一个 <strong>进程</strong>（<em>process</em>）中，操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。这个运行这些独立部分的功能被称为 <strong>线程</strong>（<em>threads</em>）。</p>
<p>将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p>
<ul>
<li>竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源</li>
<li>死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li>
<li>只会发生在特定情况且难以稳定重现和修复的 bug</li>
</ul>
<p>Rust 尝试缓和使用线程的负面影响。不过在多线程上下文中编程仍需格外小心，同时其所要求的代码结构也不同于运行于单线程的程序。</p>
<p>编程语言有一些不同的方法来实现线程。很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模模型有时被称为 <em>1:1</em>，一个 OS 线程对应一个语言线程。</p>
<p>很多编程语言提供了自己特殊的线程实现。编程语言提供的线程被称为 <strong>绿色</strong>（<em>green</em>）线程，使用绿色线程的语言会在不同数量的 OS 线程中执行它们。为此，绿色线程模式被称为 <em>M:N</em> 模型：<code>M</code> 个绿色线程对应 <code>N</code> 个 OS 线程，这里 <code>M</code> 和 <code>N</code> 不必相同。</p>
<p>每一个模型都有其优势和取舍。对于 Rust 来说最重要的取舍是运行时支持。运行时是一个令人迷惑的概念，其在不同上下文中可能有不同的含义。</p>
<p>在当前上下文中，<strong>运行时</strong> 代表二进制文件中包含的由语言自身提供的代码。这些代码根据语言的不同可大可小，不过任何非汇编语言都会有一定数量的运行时代码。为此，通常人们说一个语言 “没有运行时”，一般意味着 “小运行时”。更小的运行时拥有更少的功能不过其优势在于更小的二进制输出，这使其易于在更多上下文中与其他语言相结合。虽然很多语言觉得增加运行时来换取更多功能没有什么问题，但是 Rust 需要做到几乎没有运行时，同时为了保持高性能必需能够调用 C 语言，这点也是不能妥协的。</p>
<p>绿色线程的 M:N 模型更大的语言运行时来管理这些线程。为此，Rust 标准库只提供了 1:1 线程模型实现。Rust 是足够底层的语言，所以有相应的 crate 实现了 M:N 线程模型，如果你宁愿牺牲性能来换取例如更好的线程运行控制和更低的上下文切换成本。</p>
<p>现在我们明白了 Rust 中的线程是如何定义的，让我们开始探索如何使用标准库提供的线程相关的 API 吧。</p>
<a class="header" href="print.html#a使用-spawn-创建新线程" id="a使用-spawn-创建新线程"><h3>使用 <code>spawn</code> 创建新线程</h3></a>
<p>为了创建一个新线程，需要调用 <code>thread::spawn</code> 函数并传递一个闭包（第十三章学习了闭包），其包含希望在新线程运行的代码。示例 16-1 中的例子在主线程打印了一些文本而另一些文本则由新线程打印：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">示例 16-1: 创建一个打印某些内容的新线程，但是主线程打印其它内容</span></p>
<p>注意这个函数编写的方式，当主线程结束时，新线程也会结束，而不管其是否执行完毕。这个程序的输出可能每次都略有不同，不过它大体上看起来像这样：</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p><code>thread::sleep</code> 调用强制线程停止执行一小段时间，这会允许其他不同的线程运行。这些线程可能会轮流运行，不过并不保证如此：这依赖操作系统如何调度线程。在这里，主线程首先打印，即便新创建线程的打印语句位于程序的开头。甚至即便我们告诉新建的线程打印直到 <code>i</code> 等于 9 ，它在主线程结束之前也只打印到了 5。</p>
<p>如果你只看到了主线程的输出，或没有出现重叠打印的现象，尝试增加 range 的数值来增加操作系统切换线程的机会。</p>
<a class="header" href="print.html#a使用-join-等待所有线程结束" id="a使用-join-等待所有线程结束"><h4>使用 <code>join</code> 等待所有线程结束</h4></a>
<p>由于主线程结束，示例 16-1 中的代码大部分时候不光会提早结束新建线程，甚至不能实际保证新建线程会被执行。其原因在于无法保证线程运行的顺序！</p>
<p>可以通过将 <code>thread::spawn</code> 的返回值储存在变量中来修复新建线程部分没有执行或者完全没有执行的问题。<code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code>。<code>JoinHandle</code> 是一个拥有所有权的值，当对其调用 <code>join</code> 方法时，它会等待其线程结束。示例 16-2 展示了如何使用示例 16-1 这个中创建的线程的 <code>JoinHandle</code> 并调用 <code>join</code> 来确保新建线程在 <code>main</code> 退出前结束运行：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">示例 16-2: 从 <code>thread::spawn</code> 保存一个 <code>JoinHandle</code> 以确保该线程能够运行至结束</span></p>
<p>通过调用 handle  的 <code>join</code> 会阻塞当前线程直到 handle 所代表的线程结束。<strong>阻塞</strong>（<em>Blocking</em>） 线程意味着阻止该线程执行工作或退出。因为我们将 <code>join</code> 调用放在了主线程的 <code>for</code> 循环之后，运行示例 16-2 应该会产生类似这样的输出：</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>这两个线程仍然会交替执行，不过主线程会由于 <code>handle.join()</code> 调用会等待直到新建线程执行完毕。</p>
<p>不过让我们看看将 <code>handle.join()</code> 移动到 <code>main</code> 中 <code>for</code> 循环之前会发生什么，如下：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>主线程会等待直到新建线程执行完毕之后才开始执行 <code>for</code> 循环，所以输出将不会交替出现，如下所示：</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>稍微考虑一下将 <code>join</code> 放置于何处这样一个细节会影响线程是否同时运行。</p>
<a class="header" href="print.html#a线程与-move-闭包" id="a线程与-move-闭包"><h3>线程与 <code>move</code> 闭包</h3></a>
<p><code>move</code> 闭包，我们曾在第十三章简要的提到过，其经常与 <code>thread::spawn</code> 一起使用，因为它允许我们在一个线程中使用另一个线程的数据。</p>
<p>第十三章讲到 “如果我们希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 <code>move</code> 关键字。这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。”</p>
<p>现在我们正在创建新线程，所以让我们讨论一下在闭包中获取环境值吧。</p>
<p>注意示例 16-1 中传递给 <code>thread::spawn</code> 的闭包并没有任何参数：并没有在新建线程代码中使用任何主线程的数据。为了在新建线程中使用来自于主线程的数据，需要新建线程的闭包获取它需要的值。示例 16-3 展示了一个尝试在主线程中创建一个 vector 并用于新建线程的例子，不过这么写还不能工作，如下所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">示例 16-3: 尝试在另一个线程使用主线程创建的 vector</span></p>
<p>闭包使用了 <code>v</code>，所以闭包会捕获 <code>v</code> 并使其成为闭包环境的一部分。因为 <code>thread::spawn</code> 在一个新线程中运行这个闭包，所以可以在新线程中访问 <code>v</code>。然而当编译这个例子时，会得到如下错误：</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Rust 会 <strong>推断</strong> 如何捕获 <code>v</code>，因为 <code>println!</code> 只需要 <code>v</code> 的引用，闭包尝试借用 <code>v</code>。然而这有一个问题：Rust 不知道这个新建线程会执行多久，所以无法知晓 <code>v</code> 的引用是否一直有效。</p>
<p>示例 16-4 展示了一个 <code>v</code> 的引用很有可能不再有效的场景：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">示例 16-4: 一个具有闭包的线程，尝试使用一个在主线程中被回收的引用 <code>v</code></span></p>
<p>假如这段代码能正常运行的话，则新建线程则可能会立刻被转移到后台并完全没有机会运行。新建线程内部有一个 <code>v</code> 的引用，不过主线程立刻就使用第十五章讨论的 <code>drop</code> 丢弃了 <code>v</code>。接着当新建线程开始执行，<code>v</code> 已不再有效，所以其引用也是无效的。噢，这太糟了！</p>
<p>为了修复示例 16-3 的编译错误，我们可以听取错误信息的建议：</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>通过在闭包之前增加 <code>move</code> 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值。示例 16-5 中展示的对示例 16-3 代码的修改，这可以按照我们的预期编译并运行：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">示例 16-5: 使用 <code>move</code> 关键字强制获取它使用的值的所有权</span></p>
<p>那么如果使用了 <code>move</code> 闭包，示例 16-4 中主线程调用了 <code>drop</code> 的代码会发生什么呢？不幸的是，我们会因为示例 16-4 尝试进行由于不同的原因所不允许的操作而得到不同的错误。如果为闭包增加 <code>move</code>，将会把 <code>v</code> 移动进闭包的环境中，如此将不能在主线程中对其调用 <code>drop</code> 了。我们会得到如下不同的编译错误：</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>Rust 的所有权规则又一次帮助了我们！示例 16-3 中的错误是因为 Rust 是保守的并只会为线程借用 <code>v</code>，这意味着主线程理论上可能使新建线程的引用无效。通过告诉 Rust 将 <code>v</code> 的所有权移动到新建线程，我们向 Rust 保证主线程不会再使用 <code>v</code>。如果对示例 16-4 也做出如此修改，那么当在主线程中使用 <code>v</code> 时就会违反所有权规则。 <code>move</code> 关键字覆盖了 Rust 默认保守的借用：其也不允许我们违反所有权规则。</p>
<p>现在我们有一个线程和线程 API 的基本了解，让我们讨论一下使用线程实际可以 <strong>做</strong> 什么吧。</p>
<a class="header" href="print.html#a使用消息传递在线程间传送数据" id="a使用消息传递在线程间传送数据"><h2>使用消息传递在线程间传送数据</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-02-message-passing.md">ch16-02-message-passing.md</a>
<br>
commit 90406bd5a4cd4447b46cd7e03d33f34a651e9bb7</p>
</blockquote>
<p>一个人气正在上升的确保安全并发的方式是 <strong>消息传递</strong>（<em>message passing</em>），这里线程或 actor 通过发送包含数据的消息来相互沟通。这个思想来源于 Go 编程语言文档中的口号：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
<p>不要共享内存来通讯；而是要通讯来共享内存。</p>
<p>--<a href="http://golang.org/doc/effective_go.html">Effective Go</a></p>
</blockquote>
<p>Rust 中一个实现消息传递并发的主要工具是 <strong>通道</strong>（<em>channel</em>），一个 Rust 标准库提供了其实现的编程概念。你可以将其想象为一个水流的通道，比如河流或小溪。如果你将诸如橡皮鸭或小船之类的东西放入其中，它们会顺流而下到达下游。</p>
<p>编程中的通道有两部分组成，一个发送者（transmitter）和一个接收者（receiver）。发送者一端位于上游位置，在这里可以将橡皮鸭放入河中，接收者部分则位于下游，橡皮鸭最终会漂流至此。代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到到达的消息。当发送者或接收者任一被丢弃时可以认为通道被 <strong>关闭</strong>（<em>closed</em>）了</p>
<p>这里，我们将开发一个程序，它会在一个线程生成值向通道发送，而在另一个线程会接收值并打印出来。这里会通过通道在线程间发送简单值来演示这个功能。一旦你熟悉了这项技术，就能使用通道来实现聊天系统或利用很多线程进行分布式计算并将部分计算结果发送给一个线程进行聚合。</p>
<p>首先，在示例 16-6 中，创建了一个通道但没有做任何事。注意这还不能编译，因为 Rust 不知道我们想要在通道中发送什么类型：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre></pre>
<p><span class="caption">示例 16-6: 创建一个通道，并将其两端赋值给 <code>tx</code> 和 <code>rx</code></span></p>
<p>这里使用 <code>mpsc::channel</code> 函数创建一个新的通道；<code>mpsc</code> 是 <strong>多个生产者，单个消费者</strong>（<em>multiple producer, single consumer</em>）的缩写。简而言之，Rust 标准库实现通道的方式意味着一个通道可以有多个产生值的 <strong>发送</strong>（<em>sending</em>）端，但只能有一个消费这些值的 <strong>接收</strong>（<em>receiving</em>）端。想象一下多条小河小溪最终汇聚成大河：所有通过这些小河发出的东西最后都会来到大河的下游。目前我们以单个生产者开始，但是当示例可以工作后会增加多个生产者。</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p><code>mpsc::channel</code> 函数返回一个元组：第一个元素是发送端，而第二个元素是接收端。由于历史原因，<code>tx</code> 和 <code>rx</code> 通常作为 <strong>发送者</strong>（<em>transmitter</em>）和 <strong>接收者</strong>（<em>receiver</em>）的缩写，所以这就是我们将用来绑定这两端变量的名字。这里使用了一个 <code>let</code> 语句和模式来解构了此元组；第十八章会讨论 <code>let</code> 语句中的模式和解构。如此使用 <code>let</code> 语句是一个方便提取 <code>mpsc::channel</code> 返回的元组中一部分的手段。</p>
<p>让我们将发送端移动到一个新建线程中并发送一个字符串，这样新建线程就可以和主线程通讯了，如示例 16-7 所示。这类似与在河的上游扔下一只橡皮鸭或从一个线程向另一个线程发送聊天信息：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">示例 16-7: 将 <code>tx</code> 移动到一个新建的线程中并发送 “hi”</span></p>
<p>这里再次使用 <code>thread::spawn</code> 来创建一个新线程并使用 <code>move</code> 将 <code>tx</code> 移动到闭包中这样新建线程就拥有 <code>tx</code> 了。新建线程需要拥有通道的发送端以便能向通道发送消息。</p>
<p>通道的发送端有一个 <code>send</code> 方法用来获取需要放入通道的值。<code>send</code> 方法返回一个 <code>Result&lt;T, E&gt;</code> 类型，所以如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误。在这个例子中，出错的时候调用 <code>unwrap</code> 产生 panic。过对于一个真实程序，需要合理的处理它：回到第九章复习正确处理错误的策略。</p>
<p>在示例 16-8 中，我们在主线程中从通道的接收端获取值。这类似于在河的下游捞起橡皮鸭或接收聊天信息：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">示例 16-8: 在主线程中接收并打印内容 “hi”</span></p>
<p>通道的接收端有两个有用的方法：<code>recv</code> 和 <code>try_recv</code>。这里，我们使用了 <code>recv</code>，它是 <em>receive</em> 的缩写。这个方法会阻塞主线程执行直到从通道中接收一个值。一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它。当通道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了。</p>
<p><code>try_recv</code> 不会阻塞，相反它立刻返回一个 <code>Result&lt;T, E&gt;</code>：<code>Ok</code> 值包含可用的信息，而 <code>Err</code> 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 <code>try_recv</code> 很有用：可以编写一个循环来频繁调用 <code>try_recv</code>，再有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</p>
<p>处于简单的考虑，这个例子使用了 <code>recv</code>；主线程中除了等待消息之外没有任何其他工作，所以阻塞主线程是合适的。</p>
<p>如果运行示例 16-8 中的代码，我们将会看到主线程打印出这个值：</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>完美！</p>
<a class="header" href="print.html#a通道与所有权转移" id="a通道与所有权转移"><h3>通道与所有权转移</h3></a>
<p>所有权规则在消息传递中扮演了重要角色，其有助于我们编写安全的并发代码。在并发编程中避免错误是在整个 Rust 程序中必须思考所有权所换来的一大优势。</p>
<p>现在让我们做一个试验来看看通道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的通道中发送完 <code>val</code> 值 <strong>之后</strong> 再使用它。尝试编译示例 16-9 中的代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">示例 16-9: 在我们已经发送到通道中后，尝试使用 <code>val</code> 引用</span></p>
<p>这里尝试在通过 <code>tx.send</code> 发送 <code>val</code> 到通道中之后将其打印出来。允许这么做是一个坏主意：一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。这会由于不一致或不存在的数据而导致错误或意外的结果。</p>
<p>这是一个坏主意：一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果。然而，尝试编译示例 16-9 的代码时，Rust 会给出一个错误：</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<p>我们的并发错误会造成一个编译时错误。<code>send</code> 函数获取其参数的所有权并移动这个值归接收者所有。这个意味着不可能意外的在发送后再次使用这个值；所有权系统检查一切是否合乎规则。</p>
<a class="header" href="print.html#a发送多个值并观察接收者的等待" id="a发送多个值并观察接收者的等待"><h3>发送多个值并观察接收者的等待</h3></a>
<p>示例 16-8 中的代码可以编译和运行，不过它并没有明确的告诉我们两个独立的线程通过通道相互通讯。示例 16-10 则有一些改进会证明示例 16-8 中的代码是并发执行的：新建线程现在会发送多个消息并在每个消息之间暂停一秒钟。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">示例 16-10: 发送多个消息，并在每次发送后暂停一段时间</span></p>
<p>这一次，在新建线程中有一个字符串 vector 希望发送到主线程。我们遍历他们，单独的发送每一个字符串并通过一个 <code>Duration</code> 值调用 <code>thread::sleep</code> 函数来暂停一秒。</p>
<p>在主线程中，不再显式调用 <code>recv</code> 函数：而是将 <code>rx</code> 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当通道被关闭时，迭代器也将结束。</p>
<p>当运行示例 16-10 中的代码时，将看到如下输出，每一行都会暂停一秒：</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>因为在主线程中并没有任何暂停或位于 <code>for</code> 循环中用于等待的代码，所以可以说主线程是在等待从新建线程中接收值。</p>
<a class="header" href="print.html#a通过克隆发送者来创建多个生产者" id="a通过克隆发送者来创建多个生产者"><h3>通过克隆发送者来创建多个生产者</h3></a>
<p>之前我们提到了<code>mpsc</code>是 <em>multiple producer, single consumer</em> 的缩写。可以运用 <code>mpsc</code> 来扩展示例 16-11 中的代码来以创建都向同一接收者发送值的多个线程。这可以通过克隆通道的发送端在来做到，如示例 16-11 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::sync::mpsc;
# use std::time::Duration;
#
# fn main() {
// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
# }
</code></pre></pre>
<p><span class="caption">示例 16-11: 从多个生产者发送多个消息</span></p>
<p>这一次，在创建新线程之前，我们对通道的发送端调用了 <code>clone</code> 方法。这会给我们一个可以传递给第一个新建线程的发送端句柄。我们会将原始的通道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向通道的接收端发送不同的消息。</p>
<p>如果运行这些代码，你 <strong>可能</strong> 会看到这样的输出：</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>虽然你可能会看到这些值以不同的顺序出现；这依赖于你的系统。这也就是并发既有趣又困难的原因。如果通过 <code>thread::sleep</code> 做实验，在不同的线程中提供不同的值，就会发现他们的运行更加不确定并每次都会产生不同的输出。</p>
<p>现在我们见识过了通道如何工作，再看看另一种不同的并发方式吧。</p>
<a class="header" href="print.html#a共享状态并发" id="a共享状态并发"><h2>共享状态并发</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-03-shared-state.md">ch16-03-shared-state.md</a>
<br>
commit 90406bd5a4cd4447b46cd7e03d33f34a651e9bb7</p>
</blockquote>
<p>虽然消息传递是一个很好的处理并发的方式，但并不是唯一一个。再一次思考一下 Go 编程语言文档中口号的这一部分：“通过共享内存通讯”：</p>
<blockquote>
<p>What would communicating by sharing memory look like? In addition, why would message passing enthusiasts not use it and do the opposite instead?</p>
<p>通过共享内存通讯看起来如何？除此之外，为何消息传递的拥护者并不使用它并反其道而行之呢？</p>
</blockquote>
<p>在某种程度上，任何编程语言中的通道都类似于单所有权，因为一旦将一个值传送到通道中，将无法再使用这个值。共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。第十五章介绍了智能指针如何使得多所有权成为可能，然而这会增加额外的复杂性，因为需要以某种方式管理这些不同的所有者。作为一个例子，让我们看看互斥器，一个更为常见的共享内存并发原语。</p>
<a class="header" href="print.html#a互斥器一次只允许一个线程访问数据" id="a互斥器一次只允许一个线程访问数据"><h3>互斥器一次只允许一个线程访问数据</h3></a>
<p><strong>互斥器</strong>（<em>mutex</em>）是 “mutual exclusion” 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p>
<p>互斥器以难以使用著称，因为你不得不记住：</p>
<ol>
<li>在使用数据之前尝试获取锁。</li>
<li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li>
</ol>
<p>作为一个现实中互斥器的例子，想象一下在某个会议的一次小组座谈会中，只有一个麦克风。如果一位成员要发言，他必须请求或表示希望使用麦克风。一旦得到了麦克风，他可以畅所欲言，然后将麦克风交给下一位希望讲话的成员。如果一位成员结束发言后忘记将麦克风交还，其他人将无法发言。如果对共享麦克风的管理出现了问题，座谈会将无法如期进行！</p>
<p>正确的管理互斥器异常复杂，这也是许多人之所以热衷于通道的原因。然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p>
<a class="header" href="print.html#mutext的-api" id="mutext的-api"><h3><code>Mutex&lt;T&gt;</code>的 API</h3></a>
<p>作为展示如何使用互斥器的例子，让我们从在单线程上下文使用互斥器开始，如示例 16-12 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">示例 16-12: 出于简单的考虑，在一个单线程上下文中探索 <code>Mutex&lt;T&gt;</code> 的 API</span></p>
<p>像很多类型一样，我们使用关联函数 <code>new</code> 来创建一个 <code>Mutex&lt;T&gt;</code>。使用 <code>lock</code> 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p>
<p>如果另一个线程拥有锁，并且那个线程 panic 了，则 <code>lock</code> 调用会失败。在这种情况下，没人能够再获取锁，所以这里选择 <code>unwrap</code> 并在遇到这种情况时使线程 panic。</p>
<p>一旦获取了锁，就可以将返回值（在这里是<code>num</code>）视为一个其内部数据的可变引用了。类型系统确保了我们在使用 <code>m</code> 中的值之前获取锁：<code>Mutex&lt;i32&gt;</code> 并不是一个 <code>i32</code>，所以 <strong>必须</strong> 获取锁才能使用这个 <code>i32</code> 值。我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 <code>i32</code> 值。</p>
<p>正如你所怀疑的，<code>Mutex&lt;T&gt;</code> 是一个智能指针。更准确的说，<code>lock</code> 调用 <strong>返回</strong> 一个叫做 <code>MutexGuard</code> 的智能指针。这个智能指针实现了 <code>Deref</code> 来指向其内部数据；其也提供了一个 <code>Drop</code> 实现当 <code>MutexGuard</code> 离开作用域时自动释放锁，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。</p>
<p>丢弃了锁之后，可以打印出互斥器的值，并发现能够将其内部的 <code>i32</code> 改为 6。</p>
<a class="header" href="print.html#a在线程间共享-mutext" id="a在线程间共享-mutext"><h4>在线程间共享 <code>Mutex&lt;T&gt;</code></h4></a>
<p>现在让我们尝试使用 <code>Mutex&lt;T&gt;</code> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。注意，接下来的几个例子会出现编译错误，而我们将通过这些错误来学习如何使用 <code>Mutex&lt;T&gt;</code>，以及 Rust 又是如何帮助我们正确使用的。示例 16-13 是最开始的例子：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">示例 16-13: 程序启动了 10 个线程，每个线程都通过 <code>Mutex&lt;T&gt;</code> 来增加计数器的值</span></p>
<p>这里创建了一个 <code>counter</code> 变量来存放内含 <code>i32</code> 的 <code>Mutex&lt;T&gt;</code>，类似示例 16-12 那样。接下来遍历 range 创建了 10 个线程。使用了 <code>thread::spawn</code> 并对所有线程使用了相同的闭包：他们每一个都将调用 <code>lock</code> 方法来获取 <code>Mutex&lt;T&gt;</code> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，<code>num</code> 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p>
<p>在主线程中，我们像示例 16-2 那样收集了所有的 join 句柄，调用它们的 <code>join</code> 方法来确保所有线程都会结束。之后，主线程会获取锁并打印出程序的结果。</p>
<p>之前提示过这个例子不能编译，让我们看看为什么！</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>错误信息表明 <code>counter</code> 值被移动进了闭包并当调用 <code>lock</code> 时被捕获。这听起来正是我们需要的，但是这是不允许的！</p>
<p>让我们简化程序来进行分析。不同于在 <code>for</code> 循环中创建 10 个线程，仅仅创建两个线程来观察发生了什么。将示例 16-13 中第一个 <code>for</code> 循环替换为如下代码：</p>
<pre><code class="language-rust ignore">let handle = thread::spawn(move || {
    let mut num = counter.lock().unwrap();

    *num += 1;
});
handles.push(handle);

let handle2 = thread::spawn(move || {
    let mut num2 = counter.lock().unwrap();

    *num2 += 1;
});
handles.push(handle2);
</code></pre>
<p>这里创建了两个线程并将用于第二个线程的变量名改为 <code>handle2</code> 和 <code>num2</code>。这一次当运行代码时，编译会给出如下错误：</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>啊哈！第一个错误信息中说，<code>counter</code> 被移动进了 <code>handle</code> 所代表线程的闭包中。因此我们无法在第二个线程中对其调用 <code>lock</code>，并将结果储存在 <code>num2</code> 中时捕获<code>counter</code>！所以 Rust 告诉我们不能将 <code>counter</code> 的所有权移动到多个线程中。这在之前很难看出，因为我们在循环中创建了多个线程，而 Rust 无法在每次迭代中指明不同的线程。让我们通过一个第十五章讨论过的多所有权手段来修复这个编译错误。</p>
<a class="header" href="print.html#a多线程和多所有权" id="a多线程和多所有权"><h4>多线程和多所有权</h4></a>
<p>在第十五章中，通过使用智能指针 <code>Rc&lt;T&gt;</code> 来创建引用计数的值，以便拥有多所有者。让我们在这也这么做看看会发生什么。将示例 16-14 中的 <code>Mutex&lt;T&gt;</code> 封装进 <code>Rc&lt;T&gt;</code> 中并在将所有权移入线程之前克隆了 <code>Rc&lt;T&gt;</code>。现在我们理解了所发生的错误，同时也将代码改回使用 <code>for</code> 循环，并保留闭包的 <code>move</code> 关键字：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">示例 16-14: 尝试使用 <code>Rc&lt;T&gt;</code> 来允许多个线程拥有 <code>Mutex&lt;T&gt;</code></span></p>
<p>再一次编译并...出现了不同的错误！编译器真是教会了我们很多！</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>哇哦，错误信息太长不看！这里是一些需要注意的重要部分：第一行错误表明 <code>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。其原因是另一个值得注意的部分，经过提炼的错误信息表明 <code>the trait bound `Send` is not satisfied</code>。下一部分会讲到 <code>Send</code>：这是确保所使用的类型意在用于并发环境的 trait 之一。</p>
<p>不幸的是，<code>Rc&lt;T&gt;</code> 并不能安全的在线程间共享。当 <code>Rc&lt;T&gt;</code> 管理引用计数时，它必须在每一个 <code>clone</code> 调用时增加计数，并在每一个克隆被丢弃时减少计数。<code>Rc&lt;T&gt;</code> 并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断。在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 <code>Rc&lt;T&gt;</code>，又以一种线程安全的方式改变引用计数的类型。</p>
<a class="header" href="print.html#a原子引用计数-arct" id="a原子引用计数-arct"><h4>原子引用计数 <code>Arc&lt;T&gt;</code></h4></a>
<p>所幸 <code>Arc&lt;T&gt;</code> <strong>正是</strong> 这么一个类似 <code>Rc&lt;T&gt;</code> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个<strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型。原子性是另一类这里还未涉及到的并发原语：请查看标准库中 <code>std::sync::atomic</code> 的文档来获取更多细节。其中的要点就是：原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。</p>
<p>你可能会好奇为什么不是所有的原始类型都是原子性的？为什么不是所有标准库中的类型都默认使用 <code>Arc&lt;T&gt;</code> 实现？原因在于线程安全带有性能惩罚，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。</p>
<p>回到之前的例子：<code>Arc&lt;T&gt;</code> 和 <code>Rc&lt;T&gt;</code> 有着相同的 API，所以修改程序中的 <code>use</code> 行和 <code>new</code> 调用。示例 16-15 中的代码最终可以编译和运行：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">示例 16-15: 使用 <code>Arc&lt;T&gt;</code> 包装一个 <code>Mutex&lt;T&gt;</code> 能够实现在多线程之间共享所有权</span></p>
<p>这会打印出：</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>成功了！我们从 0 数到了 10，这可能并不是很显眼，不过一路上我们确实学习了很多关于 <code>Mutex&lt;T&gt;</code> 和线程安全的内容！这个例子中构建的结构可以用于比增加计数更为复杂的操作。使用这个策略，可将计算分成独立的部分，分散到多个线程中，接着使用 <code>Mutex&lt;T&gt;</code> 使用各自的结算结果更新最终的结果。</p>
<a class="header" href="print.html#refcelltrct-与-mutextarct-的相似性" id="refcelltrct-与-mutextarct-的相似性"><h3><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 的相似性</h3></a>
<p>你可能注意到了，因为 <code>counter</code> 是不可变的，不过可以获取其内部值的可变引用；这意味着 <code>Mutex&lt;T&gt;</code> 提供了内部可变性，就像 <code>Cell</code> 系列类型那样。正如第十五章中使用 <code>RefCell&lt;T&gt;</code> 可以改变 <code>Rc&lt;T&gt;</code> 中的内容那样，同样的可以使用 <code>Mutex&lt;T&gt;</code> 来改变 <code>Arc&lt;T&gt;</code> 中的内容。</p>
<p>另一个值得注意的细节是 Rust 不能避免使用 <code>Mutex&lt;T&gt;</code> 的全部逻辑错误。回忆一下第十五章使用 <code>Rc&lt;T&gt;</code> 就有造成引用循环的风险，这时两个 <code>Rc&lt;T&gt;</code> 值相互引用，造成内存泄露。同理，<code>Mutex&lt;T&gt;</code> 也有造成 <strong>死锁</strong>（<em>deadlock</em>） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。如果你对这个主题感兴趣，尝试编写一个带有死锁的 Rust 程序，接着研究任何其他语言中使用互斥器的死锁规避策略并尝试在 Rust 中实现他们。标准库中 <code>Mutex&lt;T&gt;</code> 和 <code>MutexGuard</code> 的 API 文档会提供有用的信息。</p>
<p>接下来，为了丰富本章的内容，让我们讨论一下 <code>Send</code>和 <code>Sync</code> trait 以及如何对自定义类型使用他们。</p>
<a class="header" href="print.html#a使用-sync-和-send-trait-的可扩展并发" id="a使用-sync-和-send-trait-的可扩展并发"><h2>使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-04-extensible-concurrency-sync-and-send.md">ch16-04-extensible-concurrency-sync-and-send.md</a>
<br>
commit 90406bd5a4cd4447b46cd7e03d33f34a651e9bb7</p>
</blockquote>
<p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p>
<p>然而有两个并发概念是内嵌于语言中的：<code>std::marker</code> 中的 <code>Sync</code> 和 <code>Send</code> trait。</p>
<a class="header" href="print.html#a通过-send-允许在线程间转移所有权" id="a通过-send-允许在线程间转移所有权"><h3>通过 <code>Send</code> 允许在线程间转移所有权</h3></a>
<p><code>Send</code> 标记 trait 表明类型的所有权可以在线程间传递。几乎所有的 Rust 类型都是<code>Send</code> 的，不过有一些例外，包括 <code>Rc&lt;T&gt;</code>：这是不能 <code>Send</code> 的，因为如果克隆了 <code>Rc&lt;T&gt;</code> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，<code>Rc&lt;T&gt;</code> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。</p>
<p>因此，Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 <code>Rc&lt;T&gt;</code> 在线程间发送。当尝试在示例 16-14 中这么做的时候，会得到错误 <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>。而使用标记为 <code>Send</code> 的 <code>Arc&lt;T&gt;</code> 时，就没有问题了。</p>
<p>任何完全由 <code>Send</code> 的类型组成的类型也会自动被标记为 <code>Send</code>。几乎所有基本类型都是 <code>Send</code> 的，除了第十九章将会讨论的裸指针（raw pointer）。</p>
<a class="header" href="print.html#sync-允许多线程访问" id="sync-允许多线程访问"><h3><code>Sync</code> 允许多线程访问</h3></a>
<p><code>Sync</code> 标记 trait 表明一个实现了 <code>Sync</code> 的类型可以安全的在多个线程中拥有其值的引用。换一种方式来说，对于任意类型 <code>T</code>，如果 <code>&amp;T</code>（<code>T</code> 的引用）是 <code>Send</code> 的话 <code>T</code> 就是 <code>Sync</code> 的，这意味着其引用就可以安全的发送到另一个线程。类似于 <code>Send</code> 的情况，基本类型是 <code>Sync</code> 的，完全由 <code>Sync</code> 的类型组成的类型也是 <code>Sync</code> 的。</p>
<p>智能指针 <code>Rc&lt;T&gt;</code> 也不是 <code>Sync</code> 的，出于其不是 <code>Send</code> 相同的原因。<code>RefCell&lt;T&gt;</code>（第十五章讨论过）和 <code>Cell&lt;T&gt;</code> 系列类型不是 <code>Sync</code> 的。<code>RefCell&lt;T&gt;</code> 在运行时所进行的借用检查也不是线程安全的。<code>Mutex&lt;T&gt;</code> 是 <code>Sync</code> 的，正如 “在线程间共享 <code>Mutex&lt;T&gt;</code>” 部分所讲的它可以被用来在多线程中共享访问。</p>
<a class="header" href="print.html#a手动实现-send-和-sync-是不安全的" id="a手动实现-send-和-sync-是不安全的"><h3>手动实现 <code>Send</code> 和 <code>Sync</code> 是不安全的</h3></a>
<p>通常并不需要手动实现 <code>Send</code> 和 <code>Sync</code> trait，因为由 <code>Send</code> 和 <code>Sync</code> 的类型组成的类型，自动就是 <code>Send</code> 和 <code>Sync</code> 的。因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。</p>
<p>手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，第十九章将会讲述具体的方法；当前重要的是，在创建新的由不是 <code>Send</code> 和 <code>Sync</code> 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。<a href="https://doc.rust-lang.org/stable/nomicon/">The Nomicon</a> 中有更多关于这些保证以及如何维持他们的信息。</p>
<a class="header" href="print.html#a总结-15" id="a总结-15"><h2>总结</h2></a>
<p>这不会是本书最后一个出现并发的章节：第二十章的项目会在更现实的场景中使用这些概念，而不像本章中讨论的这些小例子。</p>
<p>正如之前提到的，因为 Rust 本身很少有处理并发的部分内容，有很多的并发方案都由 crate 实现。他们比标准库要发展的更快；请在网上搜索当前最新的用于多线程场景的 crate。</p>
<p>Rust 提供了用于消息传递的通道，和像 <code>Mutex&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 这样可以安全的用于并发上下文的智能指针。类型系统和借用检查器会确保这些场景中的代码，不会出现数据竞争和无效的引用。一旦代码可以编译了，我们就可以坚信这些代码可以正确的运行于多线程环境，而不会出现其他语言中经常出现的那些难以追踪的 bug。并发编程不再是什么可怕的概念：无所畏惧地并发吧！</p>
<p>接下来，让我们讨论一下当 Rust 程序变得更大时，有哪些符合语言习惯的问题建模方法和结构化解决方案，以及 Rust 的风格是如何与面向对象编程（Object Oriented Programming）中那些你所熟悉的概念相联系的。</p>
<a class="header" href="print.html#rust-的面向对象特性" id="rust-的面向对象特性"><h1>Rust 的面向对象特性</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch17-00-oop.md">ch17-00-oop.md</a>
<br>
commit 07b0ca8c829af09d60ab4eb9e69584b6f4a96f60</p>
</blockquote>
<p>面向对象编程（Object-Oriented Programming，OOP）</p>
<p>面向对象编程（Object-Oriented Programming，OOP）是一种起源于 20 世纪 60 年代的 Simula 编程语言的模式化编程方式，然后在 90 年代随着 C++ 语言开始流行。关于 OOP 是什么有很多相互矛盾的定义，在一些定义下，Rust 是面向对象的；在其他定义下，Rust 不是。在本章节中，我们会探索一些被普遍认为是面向对象的特性和这些特性是如何体现在 Rust 语言习惯中的。接着会展示如何在 Rust 中实现面向对象设计模式，并讨论这么做与利用 Rust 自身的一些优势实现的方案相比有什么取舍。</p>
<a class="header" href="print.html#a什么是面向对象" id="a什么是面向对象"><h2>什么是面向对象？</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch17-01-what-is-oo.md">ch17-01-what-is-oo.md</a>
<br>
commit e7df3050309924827ff828ddc668a8667652d2fe</p>
</blockquote>
<p>关于一个语言被称为面向对象所需的功能，在编程社区内并未达成一致意见。Rust 被很多不同的编程范式影响，包括面向对象编程；比如第十三章提到了来自函数式编程的特性。面向对象编程语言所共享的一些特性往往是对象、封装和继承。让我们看一下这每一个概念的含义以及 Rust 是否支持他们。</p>
<a class="header" href="print.html#a对象包含数据和行为" id="a对象包含数据和行为"><h3>对象包含数据和行为</h3></a>
<!-- Is there a reason we're using this book as the reference, is it generally
accepted as an authority? -->
<!-- Yes, it is. For example, Martin Fowler (himself regarded as an authority)
had this to say about it https://www.martinfowler.com/bliki/GangOfFour.html:
> In my view the Gang of Four is the best book ever written on object-oriented
> design - possibly of any style of design.
/Carol -->
<p><code>Design Patterns: Elements of Reusable Object-Oriented Software</code> 这本书被俗称为 <code>The Gang of Four book</code>，是面向对象编程模式的目录。它这样定义面向对象编程：</p>
<blockquote>
<p>面向对象的程序是由对象组成的。一个 <strong>对象</strong> 包含数据和操作这些数据的过程。这些过程通常被称为 <strong>方法</strong> 或 <strong>操作</strong>。</p>
</blockquote>
<p>在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 <strong>称为</strong> 对象，但是他们提供了与对象相同的功能，参考 Gang of Four 中对象的定义。</p>
<a class="header" href="print.html#a封装隐藏了实现细节" id="a封装隐藏了实现细节"><h3>封装隐藏了实现细节</h3></a>
<p>另一个通常与面向对象编程相关的方面是 <strong>封装</strong>（<em>encapsulation</em>）的思想：对象的实现细节不能被使用对象的代码获取到。唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。</p>
<p>就像我们在第七章讨论的那样：可以使用 <code>pub</code> 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。比如，我们可以定义一个包含一个 <code>i32</code> 类型 vector 的结构体 <code>AveragedCollection</code>。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，<code>AveragedCollection</code> 会为我们缓存平均值结果。示例 17-1 有 <code>AveragedCollection</code> 结构体的定义：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
#}</code></pre></pre>
<p><span class="caption">示例 17-1: <code>AveragedCollection</code> 结构体维护了一个整型列表和集合中所有元素的平均值。</span></p>
<p>注意，结构体自身被标记为 <code>pub</code>，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 <code>add</code>、<code>remove</code> 和 <code>average</code> 方法来做到这一点，如示例 17-2 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct AveragedCollection {
#     list: Vec&lt;i32&gt;,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-2: 在<code>AveragedCollection</code> 结构体上实现了<code>add</code>、<code>remove</code> 和 <code>average</code> 公有方法</span></p>
<p>公有方法 <code>add</code>、<code>remove</code> 和 <code>average</code> 是修改 <code>AveragedCollection</code> 实例的唯一方式。当使用 <code>add</code> 方法把一个元素加入到 <code>list</code> 或者使用 <code>remove</code> 方法来删除时，这些方法的实现同时会调用私有的 <code>update_average</code> 方法来更新 <code>average</code> 字段。</p>
<p><code>list</code> 和 <code>average</code> 是私有的，所以没有其他方式来使得外部的代码直接向 <code>list</code> 增加或者删除元素，否则 <code>list</code> 改变时可能会导致 <code>average</code> 字段不同步。<code>average</code> 方法返回 <code>average</code> 字段的值，这使得外部的代码只能读取 <code>average</code> 而不能修改它。</p>
<p>因为我们已经封装好了 <code>AveragedCollection</code> 的实现细节，将来可以轻松改变类似数据结构这些方面的内容。例如，可以使用 <code>HashSet</code> 代替 <code>Vec</code> 作为 <code>list</code> 字段的类型。只要 <code>add</code>、<code>remove</code> 和 <code>average</code> 公有函数的签名保持不变，使用 <code>AveragedCollection</code> 的代码就无需改变。相反如果使得 <code>list</code> 为公有，就未必都会如此了： <code>HashSet</code> 和 <code>Vec</code> 使用不同的方法增加或移除项，所以如果要想直接修改 <code>list</code> 的话，外部的代码可能不得不做出修改。</p>
<p>如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 <code>pub</code> 与否可以封装其实现细节。</p>
<a class="header" href="print.html#a继承作为类型系统与代码共享" id="a继承作为类型系统与代码共享"><h2>继承，作为类型系统与代码共享</h2></a>
<p><strong>继承</strong>（<em>Inheritance</em>）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。</p>
<p>如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的。无法定义一个结构体继承父结构体的成员和方法。然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。</p>
<p>选择继承有两个主要的原因。第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 trait 方法实现来进行共享，在示例 10-15 中我们见过在 <code>Summarizable</code> trait 上增加的 <code>summary</code> 方法的默认实现。任何实现了 <code>Summarizable</code> trait 的类型都可以使用 <code>summary</code> 方法而无须进一步实现。这类似于父类有一个方法的实现，而通过继承子类也拥有这个方法的实现。当实现 <code>Summarizable</code> trait 时也可以选择覆盖 <code>summary</code> 的默认实现，这类似于子类覆盖从父类继承的方法实现。</p>
<p>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</p>
<!-- What does it mean for objects to have the same shape? -->
<!-- The use of "shape" in this context has to do with the roots of "morph" in
"polymorphism", but it's not very well defined so I've reworded. /Carol -->
<!-- PROD: START BOX -->
<blockquote>
<p>多态（Polymorphism）</p>
<p>很多人将多态描述为继承的同义词。不过它是一个有关可以用于多种类型的代码的更广泛的概念。对于继承来说，这些类型通常是子类。Rust 则通过泛型来使得对多个不同类型的抽象成为可能，并通过 trait bounds 加强对这些类型所必须提供的内容的限制。这有时被称为 <em>bounded parametric polymorphism</em>。</p>
</blockquote>
<!-- PROD: END BOX -->
<p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。子类不应总是共享其父类的多有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。</p>
<p>因为这些原因，Rust 选择了一个不同的途径，使用 trait 对象替代继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。</p>
<a class="header" href="print.html#a为使用不同类型的值而设计的-trait-对象" id="a为使用不同类型的值而设计的-trait-对象"><h2>为使用不同类型的值而设计的 trait 对象</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch17-02-trait-objects.md">ch17-02-trait-objects.md</a>
<br>
commit ccdd9ca7aacea4cefeb6a96e7ffb9ea91a923abd</p>
</blockquote>
<p>在第八章中，我们谈到了 vector 只能存储同种类型元素的局限。示例 8-10 中提供了一个定义 <code>SpreadsheetCell</code> 枚举来储存整型，浮点型和文本成员的替代方案。这意味着可以在每个单元中储存不同类型的数据，并仍能拥有一个代表一排单元的 vector。这在当编译代码时就知道希望可以交替使用的类型为固定集合的情况下是完全可行的。</p>
<p>然而有时，我们希望库用户在特定情况下能够扩展有效的类型集合。为了展示如何实现这一点，这里将创建一个图形用户接口（Graphical User Interface， GUI）工具的例子，其它通过遍历列表并调用每一个项目的 <code>draw</code> 方法来将其绘制到屏幕上；此乃一个 GUI 工具的常见技术。我们将要创建一个叫做 <code>rust_gui</code> 的库 crate，它含一个 GUI 库的结构。这个 GUI 库包含一些可供开发者使用的类型，比如 <code>Button</code> 或 <code>TextField</code>。在此之上，<code>rust_gui</code> 的用户希望创建自定义的可以绘制于屏幕上的类型：比如，一个程序员可能会增加 <code>Image</code>，另一个可能会增加 <code>SelectBox</code>。</p>
<p>这个例子中并不会实现一个功能完善的 GUI 库，不过会展示其中各个部分是如何结合在一起的。编写库的时候，我们不可能知晓并定义所有其他程序员希望创建的类型。我们所知晓的是 <code>rust_gui</code> 需要记录一系列不同类型的值，并需要能够对其中每一个值调用 <code>draw</code> 方法。这里无需知道调用 <code>draw</code> 方法时具体会发生什么，只需提供可供这些值调用的方法即可。</p>
<p>在拥有继承的语言中，可以定义一个名为 <code>Component</code> 的类，该类上有一个 <code>draw</code> 方法。其他的类比如 <code>Button</code>、<code>Image</code> 和 <code>SelectBox</code> 会从 <code>Component</code> 派生并因此继承 <code>draw</code> 方法。它们各自都可以覆盖 <code>draw</code> 方法来定义自己的行为，但是框架会把所有这些类型当作是 <code>Component</code> 的实例，并在其上调用 <code>draw</code>。不过 Rust 并没有继承，我们得另寻出路。</p>
<a class="header" href="print.html#a定义通用行为的-trait" id="a定义通用行为的-trait"><h3>定义通用行为的 trait</h3></a>
<p>为了实现 <code>rust_gui</code> 所期望拥有的行为，定义一个 <code>Draw</code> trait，其包含名为 <code>draw</code> 的方法。接着可以定义一个存放 <strong>trait 对象</strong>（<em>trait object</em>） 的 vector。trait 对象指向一个实现了我们指定 trait 的类型实例。我们通过指定某些指针，比如 <code>&amp;</code> 引用或  <code>Box&lt;T&gt;</code> 智能指针，接着指定相关的 trait（第十九章动态大小类型部分会介绍 trait 对象必须使用指针的原因）。我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。</p>
<!-- What will the trait object do in this case? I've taken this last part of
the line from below, but I'm not 100% on that -->
<!-- I've moved up more and reworded a bit, hope that clarifies /Carol -->
<p>之前提到过，Rust 刻意不将结构体与枚举称为 “对象”，以便与其他语言中的对象相区别。在结构体或枚举中，结构体字段中的数据和 <code>impl</code> 块中的行为是分开的，不同于其他语言中将数据和行为组合进一个称为对象的概念中。trait 对象将数据和行为两者相结合，从这种意义上说 <strong>则</strong> 其更类似其他语言中的对象。不过 trait 对象不同于传统的对象，因为不能向 trait 对象增加数据。trait 对象并不像其他语言中的对象那么通用：其（trait 对象）具体的作用是允许对通用行为的抽象。</p>
<p>示例 17-3 展示了如何定义一个带有 <code>draw</code> 方法的 trait <code>Draw</code>：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn draw(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">示例 17-3：<code>Draw</code> trait 的定义</span></p>
<p>因为第十章已经讨论过如何定义 trait，这看起来应该比较眼熟。接下来就是新内容了：实例 17-4 定义了一个存放了名叫 <code>components</code> 的 vector 的结构体 <code>Screen</code>。这个 vector 的类型是 <code>Box&lt;Draw&gt;</code>，此为一个 trait 对象：它是 <code>Box</code> 中任何实现了 <code>Draw</code> trait 的类型的替身。</p>
<!-- Would it be useful to let the reader know why we need a box here, or will
that be clear at this point? -->
<!-- We get into this in chapter 19; I've added a reference to the start of
this section where we talk about needing a `&` or a `Box` to be a trait object.
/Carol -->
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">示例 17-4: 一个 <code>Screen</code> 结构体的定义，它带有一个字段<code>components</code>，其包含实现了 <code>Draw</code> trait 的 trait 对象的 vector</span></p>
<p>在 <code>Screen</code> 结构体上，我们将定义一个 <code>run</code> 方法，该方法会对其 <code>components</code> 上的每一个组件调用 <code>draw</code> 方法，如示例 17-5 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-5：在 <code>Screen</code> 上实现一个 <code>run</code> 方法，该方法在每个 component 上调用 <code>draw</code> 方法</span></p>
<p>这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。泛型类型参数一次只能替代一个具体类型，而 trait 对象则允许在运行时替代多种具体类型。例如，可以定义 <code>Screen</code> 结构体来使用泛型和 trait bound，如示例 17-6 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-6: 一种 <code>Screen</code> 结构体的替代实现，其 <code>run</code> 方法使用泛型和 trait bound</span></p>
<p>这限制了 <code>Screen</code> 实例必须拥有一个全是 <code>Button</code> 类型或者全是 <code>TextField</code> 类型的组件列表。如果只需要同质（相同类型）集合，则倾向于使用泛型和 trait bound，因为其定义会在编译时采用具体类型进行单态化。</p>
<p>另一方面，通过使用 trait 对象的方法，一个 <code>Screen</code> 实例可以存放一个既能包含 <code>Box&lt;Button&gt;</code>，也能包含 <code>Box&lt;TextField&gt;</code> 的 <code>Vec</code>。让我们看看它是如何工作的，接着会讲到其运行时性能影响。</p>
<a class="header" href="print.html#a实现-trait" id="a实现-trait"><h3>实现 trait</h3></a>
<p>现在来增加一些实现了 <code>Draw</code> trait 的类型。我们将提供 <code>Button</code> 类型。再一次重申，真正实现 GUI 库超出了本书的范畴，所以 <code>draw</code> 方法体中不会有任何有意义的实现。为了想象一下这个实现看起来像什么，一个 <code>Button</code> 结构体可能会拥有 <code>width</code>、<code>height</code> 和 <code>label</code> 字段，如示例 17-7 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code to actually draw a button
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-7: 一个实现了 <code>Draw</code> trait 的 <code>Button</code> 结构体</span></p>
<p>在 <code>Button</code> 上的 <code>width</code>、<code>height</code> 和 <code>label</code> 字段会和其他组件不同，比如 <code>TextField</code> 可能有 <code>width</code>、<code>height</code>、<code>label</code> 以及 <code>placeholder</code> 字段。每一个我们希望能在屏幕上绘制的类型都会使用不同的代码来实现 <code>Draw</code> trait 的 <code>draw</code> 方法来定义如何绘制特定的类型，像这里的 <code>Button</code> 类型（并不包含任何实际的 GUI 代码，这超出了本章的范畴）。除了实现 <code>Draw</code> trait 之外，比如 <code>Button</code> 还可能有另一个包含按钮点击如何响应的方法的 <code>impl</code> 块。这类方法并不适用于像 <code>TextField</code> 这样的类型。</p>
<p>一些库的使用者决定实现一个包含 <code>width</code>、<code>height</code> 和 <code>options</code> 字段的结构体 <code>SelectBox</code>。并也为其实现了 <code>Draw</code> trait，如示例 17-8 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">示例 17-8: 另一个使用 <code>rust_gui</code> 的 crate 中，在 <code>SelectBox</code> 结构体上实现 <code>Draw</code> trait</span></p>
<p>库使用者现在可以在他们的 <code>main</code> 函数中创建一个 <code>Screen</code> 实例。至此可以通过将 <code>SelectBox</code> 和 <code>Button</code> 放入 <code>Box&lt;T&gt;</code> 转变为 trait 对象来增加组件。接着可以调用 <code>Screen</code> 的 <code>run</code> 方法，它会调用每个组件的 <code>draw</code> 方法。示例 17-9 展示了这个实现：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rust_gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">示例 17-9: 使用 trait 对象来存储实现了相同 trait 的不同类型的值</span></p>
<p>当编写库的时候，我们不知道何人会在何时增加 <code>SelectBox</code> 类型，不过 <code>Screen</code> 的实现能够操作并绘制这个新类型，因为 <code>SelectBox</code> 实现了 <code>Draw</code> trait，这意味着它实现了 <code>draw</code> 方法。</p>
<p>这个概念 ———— 只关心值所反映的信息而不是其具体类型 ———— 类似于动态类型语言中称为 <strong>鸭子类型</strong>（<em>duck typing</em>）的概念：如果它走起来像一只鸭子，叫起来像一只鸭子，那么它就是一只鸭子！在示例 17-5 中 <code>Screen</code> 上的 <code>run</code> 实现中，<code>run</code> 并不需要知道各个组件的具体类型是什么。它并不检查组件是 <code>Button</code> 或者 <code>SelectBox</code> 的实例。通过指定 <code>Box&lt;Draw&gt;</code> 作为 <code>components</code> vector 中值的类型，我们就定义了 <code>Screen</code> 需要可以在其上调用 <code>draw</code> 方法的值。</p>
<!-- I may be slow on the uptake here, but it seems like we're saying that
responsibility for how the type trait object behaves with the draw method is
called on it belongs to the trait object, and not to the draw method itself. Is
that an accurate summary? I want to make sure I'm clearly following the
argument! -->
<!-- Each type (like `Button` or `SelectBox`) that implements the `Draw` trait
can customize what happens in the body of the `draw` method. The trait object
is just responsible for making sure that the only things that are usable in
that context are things that implement the `Draw` trait. Does this clear it up
at all? Is there something we should clarify in the text? /Carol -->
<p>使用 trait 对象和 Rust 类型系统来进行类似鸭子类型操作的优势是无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现 trait 对象所需的 trait 则 Rust 不会编译这些代码。</p>
<p>例如，示例 17-10 展示了当创建一个使用 <code>String</code> 做为其组件的 <code>Screen</code> 时发生的情况：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">示例 17-10: 尝试使用一种没有实现 trait 对象的 trait 的类型</span></p>
<p>我们会遇到这个错误，因为 <code>String</code> 没有实现 <code>rust_gui::Draw</code> trait：</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: rust_gui::Draw` is not satisfied
  --&gt;
   |
 4 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `rust_gui::Draw` is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `rust_gui::Draw`
</code></pre>
<p>这告诉了我们，要么是我们传递了并不希望传递给 <code>Screen</code> 的类型并应该提供其他类型，要么应该在 <code>String</code> 上实现 <code>Draw</code> 以便 <code>Screen</code> 可以调用其上的 <code>draw</code>。</p>
<a class="header" href="print.html#trait-对象执行动态分发" id="trait-对象执行动态分发"><h3>trait 对象执行动态分发</h3></a>
<p>回忆一下第十章讨论过的，当对泛型使用 trait bound 时编译器所进行单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了非泛型的函数和方法实现。单态化所产生的代码进行 <strong>静态分发</strong>（<em>static dispatch</em>）。静态分发发生于编译器在编译时就知晓调用了什么方法的时候。这与 <strong>动态分发</strong> （<em>dynamic dispatch</em>）相对，这时编译器在编译时无法知晓调用了什么方法。在这种情况下，编译器会生成在运行时确定调用了什么方法的代码。</p>
<!--I'm struggling to follow the static dispatch definition, can you expand
that a little? Which part of that is the static dispatch, pre-determining the
code called with a method and storing it? -->
<!-- Yes, in a way. We've expanded and moved the definitions of static and
dynamic dispatch together to better contrast, hopefully this helps? /Carol -->
<p>当使用 trait 对象时，Rust 必须使用动态分发。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。动态分发也阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。尽管在编写和支持代码的过程中确实获得了额外的灵活性，但仍然需要权衡取舍。</p>
<a class="header" href="print.html#trait-对象要求对象安全" id="trait-对象要求对象安全"><h3>Trait 对象要求对象安全</h3></a>
<!-- Liz: we're conflicted on including this section. Not being able to use a
trait as a trait object because of object safety is something that
beginner/intermediate Rust developers run into sometimes, but explaining it
fully is long and complicated. Should we just cut this whole section? Leave it
(and finish the explanation of how to fix the error at the end)? Shorten it to
a quick caveat, that just says something like "Some traits can't be trait
objects. Clone is an example of one. You'll get errors that will let you know
if a trait can't be a trait object, look up object safety if you're interested
in the details"? Thanks! /Carol -->
<!-- That sounds like a good solution, since the compiler will warn them in any
case. I read through, editing a little, and I agree we could afford to cut it,
I'm not sure it brings practical skills to the user -->
<!-- Ok, I've cut section way down to the practical pieces, but still explained
a little bit /Carol -->
<p>只有 <strong>对象安全</strong>（<em>object safe</em>）的 trait 才可以组成 trait 对象。围绕所有使得 trait 对象安全的属性存在一些复杂的规则，不过在实践中，只涉及到两条规则。如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的：</p>
<ul>
<li>返回值类型不为 <code>Self</code></li>
<li>方法没有任何泛型类型参数</li>
</ul>
<p><code>Self</code> 关键字是我们要实现 trait 或方法的类型的别名。对象安全对于 trait 对象是必须的，因为一旦有了 trait 对象，就不再知晓实现该 trait 的具体类型是什么了。如果 trait 方法返回具体的 <code>Self</code> 类型，但是 trait 对象忘记了其真正的类型，那么方法不可能使用已经忘却的原始具体类型。同理对于泛型类型参数来说，当使用 trait 时其会放入具体的类型参数：此具体类型变成了实现该 trait 的类型的一部分。当使用 trait 对象时其具体类型被抹去了，故无从得知放入泛型参数类型的类型是什么。</p>
<p>一个 trait 的方法不是对象安全的例子是标准库中的 <code>Clone</code> trait。<code>Clone</code> trait 的 <code>clone</code> 方法的参数签名看起来像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p><code>String</code> 实现了 <code>Clone</code> trait，当在 <code>String</code> 实例上调用 <code>clone</code> 方法时会得到一个 <code>String</code> 实例。类似的，当调用 <code>Vec</code> 实例的 <code>clone</code> 方法会得到一个 <code>Vec</code> 实例。<code>clone</code> 的签名需要知道什么类型会代替 <code>Self</code>，因为这是它的返回值。</p>
<p>如果尝试做一些违反有关 trait 对象的对象安全规则的事情，编译器会提示你。例如，如果尝试实现示例 17-4 中的 <code>Screen</code> 结构体来存放实现了 <code>Clone</code> trait 而不是 <code>Draw</code> trait 的类型，像这样：</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>将会得到如下错误：</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt;
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
  made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>这意味着不能以这种方式使用此 trait 作为 trait 对象。如果你对对象安全的更多细节感兴趣，请查看 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>。</p>
<a class="header" href="print.html#a面向对象设计模式的实现" id="a面向对象设计模式的实现"><h2>面向对象设计模式的实现</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch17-03-oo-design-patterns.md">ch17-03-oo-design-patterns.md</a>
<br>
commit b18f90970ab7223ee8af18ef466a5ba6ff8482ef</p>
</blockquote>
<p><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于一个值有某些内部状态，体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变。状态对象共享功能 —— 当然，在 Rust 中使用结构体和 trait 而不是对象和继承。每一个状态对象代表负责其自身的行为和当需要改变为另一个状态时的规则的状态。持有任何一个这种状态对象的值对于不同状态的行为以及何时状态转移毫不知情。</p>
<!-- Below -- requirements for what, for what we need the value for? -->
<!-- I've clarified /Carol -->
<p>使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。我们只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象。让我们看看一个有关状态模式和如何在 Rust 中使用它的例子。</p>
<p>让我们看看一个状态设计模式的例子以及如何在 Rust 中使用他们。<strong>状态模式</strong>（<em>state pattern</em>）是指一个值有某些内部状态，而它的行为随着其内部状态而改变。内部状态由一系列继承了共享功能的对象表现（我们使用结构体和 trait 因为 Rust 没有对象和继承）。每一个状态对象负责它自身的行为和当需要改变为另一个状态时的规则。持有任何一个这种状态对象的值对于不同状态的行为以及何时状态转移毫不知情。当将来需求改变时，无需改变值持有状态或者使用值的代码。我们只需更新某个状态对象中的代码来改变它的规则，或者是增加更多的状态对象。</p>
<p>为了探索这个概念，我们将实现一个增量式的发布博文的工作流。这个博客的最终功能看起来像这样：</p>
<ol>
<li>博文从空白的草案开始。</li>
<li>一旦草案完成，请求审核博文。</li>
<li>一旦博文过审，它将被发表。</li>
<li>只有被发表的博文的内容会被打印，这样就不会意外打印出没有被审核的博文的文本。</li>
</ol>
<p>任何其他对博文的修改尝试都是没有作用的。例如，如果尝试在请求审核之前通过一个草案博文，博文应该保持未发布的状态。</p>
<p>示例 17-11 展示这个工作流的代码形式。这是一个我们将要在一个叫做 <code>blog</code> 的库 crate 中实现的 API 的示例：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">示例 17-11: 展示了 <code>blog</code> crate 期望行为的代码</span></p>
<p>我们希望允许用户使用 <code>Post::new</code> 创建一个新的博文草案。接着希望能在草案阶段为博文编写一些文本。如果尝试在审核之前立即打印出博文的内容，什么也不会发生因为博文仍然是草案。这里增加的 <code>assert_eq!</code> 出于演示目的。一个好的单元测试将是断言草案博文的 <code>content</code> 方法返回空字符串，不过我们并不准备为这个例子编写单元测试。</p>
<p>接下来，我们希望能够请求审核博文，而在等待审核的阶段 <code>content</code> 应该仍然返回空字符串。最后当博文审核通过，它应该被发表，这意味着当调用 <code>content</code> 时博文的文本将被返回。</p>
<!-- Below -- so this is where we'll implement the state pattern? If so, can
you make that explicit, just to be clear! I've added some text to the second
line, not sure if that's accurate though -->
<!-- Yes, the state pattern will be implemented within the `Post` type. I've
tweaked the wording a bit but you've pretty much got it! /Carol-->
<p>注意我们与 crate 交互的唯一的类型是 <code>Post</code>。这个类型会使用状态模式并会存放处于三种博文所可能的状态之一的值 —— 草案，等待审核和发布。状态上的改变由 <code>Post</code> 类型内部进行管理。状态依库用户对 <code>Post</code> 实例调用的方法而改变，但是不能直接管理状态变化。这也意味着用户不会在状态上犯错，比如在过审前发布博文。</p>
<a class="header" href="print.html#a定义-post-并新建一个草案状态的实例" id="a定义-post-并新建一个草案状态的实例"><h3>定义 <code>Post</code> 并新建一个草案状态的实例</h3></a>
<p>让我们开始实现这个库吧！我们知道需要一个公有 <code>Post</code> 结构体来存放一些文本，所以让我们从结构体的定义和一个创建 <code>Post</code> 实例的公有关联函数 <code>new</code> 开始，如示例 17-12 所示。还需定义一个私有 trait <code>State</code>。<code>Post</code> 将在私有字段 <code>state</code> 中存放一个 <code>Option</code> 类型的 trait 对象 <code>Box&lt;State&gt;</code>。稍后将会看到为何 <code>Option</code> 是必须的。</p>
<p><code>State</code> trait 定义了所有不同状态的博文所共享的行为，同时 <code>Draft</code>、<code>PendingReview</code> 和 <code>Published</code> 状态都会实现 <code>State</code> 状态。现在这个 trait 并没有任何方法，同时开始将只定义 <code>Draft</code> 状态因为这是我们希望博文的初始状态：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#}</code></pre></pre>
<p><span class="caption">示例 17-12: <code>Post</code> 结构体的定义和新建 <code>Post</code> 实例的  <code>new</code> 函数，<code>State</code> trait 和结构体 <code>Draft</code></span></p>
<p>当创建新的 <code>Post</code> 时，我们将其 <code>state</code> 字段设置为一个存放了 <code>Box</code> 的 <code>Some</code> 值。这个 <code>Box</code> 指向一个 <code>Draft</code> 结构体新实例。这确保了无论何时新建一个 <code>Post</code> 实例，它都会从草案开始。因为 <code>Post</code> 的 <code>state</code> 字段是私有的，也就无法创建任何其他状态的 <code>Post</code> 了！。</p>
<a class="header" href="print.html#a存放博文内容的文本" id="a存放博文内容的文本"><h3>存放博文内容的文本</h3></a>
<p>在 <code>Post::new</code> 函数中，我们设置 <code>content</code> 字段为新的空 <code>String</code>。在示例 17-11 中，展示了我们希望能够调用一个叫做 <code>add_text</code> 的方法并向其传递一个 <code>&amp;str</code> 来将文本增加到博文的内容中。选择实现为一个方法而不是将 <code>content</code> 字段暴露为 <code>pub</code> 。这意味着之后可以实现一个方法来控制 <code>content</code> 字段如何被读取。<code>add_text</code> 方法是非常直观的，让我们在示例 17-13 的 <code>impl Post</code> 块中增加一个实现：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-13: 实现方法 <code>add_text</code> 来向博文的 <code>content</code> 增加文本</span></p>
<p><code>add_text</code> 获取一个 <code>self</code> 的可变引用，因为需要改变调用 <code>add_text</code> 的 <code>Post</code> 实例。接着调用 <code>content</code> 中的 <code>String</code> 的 <code>push_str</code> 并传递 <code>text</code> 参数来保存到 <code>content</code> 中。这不是状态模式的一部分，因为它的行为并不依赖博文所处的状态。<code>add_text</code> 方法完全不与 <code>state</code> 状态交互，不过这是我们希望支持的行为的一部分。</p>
<a class="header" href="print.html#a博文草案的内容是空的" id="a博文草案的内容是空的"><h3>博文草案的内容是空的</h3></a>
<p>即使调用 <code>add_text</code> 并向博文增加一些内容之后，我们仍然希望 <code>content</code> 方法返回一个空字符串 slice，因为博文仍然处于草案状态，如示例 17-11 的第 8 行所示。现在让我们使用能满足要求的最简单的方式来实现 <code>content</code> 方法：总是返回一个空字符串 slice。当实现了将博文状态改为发布的能力之后将改变这一做法。但是目前博文只能是草案状态，这意味着其内容应该总是空的。示例 17-14 展示了这个占位符实现：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">列表 17-14: 增加一个 <code>Post</code> 的 <code>content</code> 方法的占位实现，它总是返回一个空字符串 slice</span></p>
<p>通过增加这个 <code>content</code>方法，示例 17-11 中直到第 8 行的代码能如期运行。</p>
<a class="header" href="print.html#a请求审核博文来改变其状态" id="a请求审核博文来改变其状态"><h3>请求审核博文来改变其状态</h3></a>
<p>接下来需要增加请求审核博文的功能，这应当将其状态由 <code>Draft</code> 改为 <code>PendingReview</code>。我们希望为 <code>Post</code> 增加一个获取 <code>self</code> 可变引用的公有方法 <code>request_review</code>。接着将 <code>Post</code> 当前状态内部的 <code>request_review</code> 方法而这第二个 <code>request_review</code> 方法会消费当前的状态并返回一个新状态。示例 17-15 展示了这个代码：</p>
<!-- NOTE TO DE/AU: We might want to move this explanation to after the code if
you want to add wingdings, we can see once we transfer it to Word -->
<!-- I decided to move some of this explanation after the code for this reason
and because we got some questions about this example that I wanted to expand
upon /Carol -->
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-15: 实现 <code>Post</code> 和 <code>State</code> trait 的 <code>request_review</code> 方法</span></p>
<p>这里给 <code>State</code> trait 增加了 <code>request_review</code> 方法；所有实现了这个 trait 的类型现在都需要实现 <code>request_review</code> 方法。注意不同于使用 <code>self</code>、 <code>&amp;self</code> 或者 <code>&amp;mut self</code> 作为方法的第一个参数，这里使用了 <code>self: Box&lt;Self&gt;</code>。这个语法意味着这个方法调用只对这个类型的 <code>Box</code> 有效。这个语法获取了 <code>Box&lt;Self&gt;</code> 的所有权，使老状态无效化以便 <code>Post</code> 的状态值可以将自身转换为新状态。</p>
<!-- Above -- so Post can transform, or so Draft can transform? -->
<!-- Technically it's so the Draft value can transform into another value,
which changes the state of Post-- I've tried to clarify. /Carol -->
<p>为了消费老状态，<code>request_review</code> 方法需要获取状态值的所有权。这也就是 <code>Post</code> 的 <code>state</code> 字段中 <code>Option</code> 的来历：调用 <code>take</code> 方法将 <code>state</code> 字段中的 <code>Some</code> 值取出并留下一个 <code>None</code>，因为 Rust 不允许在结构体中存在空的字段。这使得我们将 <code>state</code> 值移动出 <code>Post</code> 而不是借用它。接着将博文的 <code>state</code> 值设置为这个操作的结果。</p>
<p>这里需要将 <code>state</code> 临时设置为 <code>None</code>，不同于像 <code>self.state = self.state.request_review();</code> 这样的代码直接设置 <code>state</code> 字段，来获取 <code>state</code> 值的所有权。这确保了当 <code>Post</code> 被转换为新状态后其不再能使用老的 <code>state</code> 值。</p>
<p><code>Draft</code> 的方法 <code>request_review</code> 的实现返回一个新的，装箱的 <code>PendingReview</code> 结构体的实例，其用来代表博文处于等待审核状态。结构体 <code>PendingReview</code> 同样也实现了 <code>request_review</code> 方法，不过它不进行任何状态转换。相反它返回自身，因为请求审核已经处于 <code>PendingReview</code> 状态的博文应该保持 <code>PendingReview</code> 状态。</p>
<p>现在开始能够看出状态模式的优势了：<code>Post</code> 的 <code>request_review</code> 方法无论 <code>state</code> 是何值都是一样的。每个状态只负责它自己的规则。</p>
<p>我们将继续保持 <code>Post</code> 的 <code>content</code> 方法不变，返回一个空字符串 slice。现在可以拥有 <code>PendingReview</code> 状态而不仅仅是 <code>Draft</code> 状态的 <code>Post</code> 了，不过我们希望在 <code>PendingReview</code> 状态下其也有相同的行为。现在示例 17-11 中直到 11 行的代码是可以执行的！</p>
<a class="header" href="print.html#a增加改变-content-行为的-approve-方法" id="a增加改变-content-行为的-approve-方法"><h3>增加改变 <code>content</code> 行为的 <code>approve</code> 方法</h3></a>
<p><code>approve</code> 方法将与 <code>request_review</code> 方法类似：它会将 <code>state</code> 设置为审核通过时应处于的状态，如示例 17-16 所示。</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         self
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-16: 为 <code>Post</code> 和 <code>State</code> trait 实现 <code>approve</code> 方法</span></p>
<p>这里为 <code>State</code> trait 增加了 <code>approve</code> 方法，并新增了一个实现了 <code>State</code> 的结构体，<code>Published</code> 状态。</p>
<p>类似于 <code>request_review</code>，如果对 <code>Draft</code> 调用 <code>approve</code> 方法，并没有任何效果，因为它会返回 <code>self</code>。当对 <code>PendingReview</code> 调用 <code>approve</code> 时，它返回一个新的、装箱的 <code>Published</code> 结构体的实例。<code>Published</code> 结构体实现了 <code>State</code> trait，同时对于 <code>request_review</code> 和 <code>approve</code> 两方法来说，它返回自身，因为在这两种情况博文应该保持 <code>Published</code> 状态。</p>
<p>现在更新 <code>Post</code> 的 <code>content</code> 方法：如果状态为 <code>Published</code> 希望返回博文 <code>content</code> 字段的值；否则希望返回空字符串 slice，如示例 17-17 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait State {
#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
# }
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">示例 17-17: 更新 <code>Post</code> 的 <code>content</code> 方法来委托调用 <code>State</code> 的<code>content</code> 方法</span></p>
<p>因为目标是将所有像这样的规则保持在实现了 <code>State</code> 的结构体中，我们将调用 <code>state</code> 中的值的 <code>content</code> 方法并传递博文实例（也就是 <code>self</code>）作为参数。接着返回 <code>state</code> 值的 <code>content</code> 方法的返回值。</p>
<p>这里调用 <code>Option</code> 的 <code>as_ref</code> 方法是因为需要 <code>Option</code> 中值的引用而不是获取其所有权。因为 <code>state</code> 是一个 <code>Option&lt;Box&lt;State&gt;&gt;</code>，调用 <code>as_ref</code> 会返回一个 <code>Option&lt;&amp;Box&lt;State&gt;&gt;</code>。如果不调用 <code>as_ref</code>，怎会得到一个错误，因为不能将 <code>state</code> 移动出借用的 <code>&amp;self</code> 函数参数。</p>
<p>接着调用 <code>unwrap</code> 方法，这里我们知道它永远也不会 panic，因为 <code>Post</code> 的所有方法都确保在他们返回时 <code>state</code> 会有一个 <code>Some</code> 值。这就是一个第十二章讨论过的我们知道 <code>None</code> 是不可能的而编译器却不能理解的情况。</p>
<p>接着我们就有了一个 <code>&amp;Box&lt;State&gt;</code>，当调用其 <code>content</code> 时，解引用强制多态会作用于 <code>&amp;</code> 和 <code>Box</code> 这样最终会调用实现了 <code>State</code> trait 的类型的 <code>content</code> 方法。</p>
<p>这意味着需要为 <code>State</code> trait 定义增加 <code>content</code>，这也是放置根据所处状态返回什么内容的逻辑的地方，如示例 17-18 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String
# }
trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-18: 为 <code>State</code> trait 增加 <code>content</code> 方法</span></p>
<p>这里增加了一个 <code>content</code> 方法的默认实现来返回一个空字符串 slice。这意味着无需为 <code>Draft</code> 和 <code>PendingReview</code> 结构体实现 <code>content</code> 了。<code>Published</code> 结构体会覆盖 <code>content</code> 方法并会返回 <code>post.content</code> 的值。</p>
<p>注意这个方法需要生命周期注解，如第十章所讨论的。这里获取 <code>post</code> 的引用作为参数，并返回 <code>post</code> 一部分的引用，所以返回的引用的生命周期与 <code>post</code> 参数相关。</p>
<!-- Is this it finished, without the touch up we make to get rid of the empty
string? That's pretty awesome coding, maybe give it some ceremony here. Does
all of 17-11 now work? -->
<!-- Yep! Good point, so added! /Carol -->
<p>现在示例完成了 ———— 现在示例 17-11 中所有的代码都能工作！我们通过发布博文工作流的规则实现了状态模式。围绕这些规则的逻辑都存在于状态对象中而不是分散在 <code>Post</code> 之中。</p>
<a class="header" href="print.html#a状态模式的权衡取舍" id="a状态模式的权衡取舍"><h3>状态模式的权衡取舍</h3></a>
<p>我们展示了 Rust 是能够实现面向对象的状态模式的，以便能根据博文所处的状态来封装不同类型的行为。<code>Post</code> 的方法并不知道这些不同类型的行为。通过这种组织代码的方式，为了找到所有已发布的博文不同行为只需查看一处代码：<code>Published</code> 的 <code>State</code> trait 的实现。</p>
<p>如果要创建一个不使用状态模式的替代实现，则可能会在 <code>Post</code> 的方法中，或者甚至于在 <code>main</code> 代码中用到 <code>match</code> 语句，来检查博文状态并在这里改变其行为。这意味着需要查看很多位置来理解处于发布状态的博文的所有逻辑！这在增加更多状态时会变得更糟：每一个 <code>match</code> 语句都会需要另一个分支。</p>
<p>对于状态模式来说，<code>Post</code> 的方法和使用 <code>Post</code> 的位置无需 <code>match</code> 语句，同时增加新状态只涉及到增加一个新 <code>struct</code> 和为其实现 trait 的方法。</p>
<p>这个实现易于扩展增加更多功能。为了体会使用此模式维护代码的简洁性，请尝试如下一些建议：</p>
<ul>
<li>只允许博文处于 <code>Draft</code> 状态时增加文本内容</li>
<li>增加 <code>reject</code> 方法将博文的状态从 <code>PendingReview</code> 变回 <code>Draft</code></li>
<li>在将状态变为 <code>Published</code> 之前需要两次 <code>approve</code> 调用</li>
</ul>
<p>状态模式的一个缺点是因为状态实现了状态之间的转换，一些状态会相互联系。如果在 <code>PendingReview</code> 和 <code>Published</code> 之间增加另一个状态，比如 <code>Scheduled</code>，则不得不修改 <code>PendingReview</code> 中的代码来转移到 <code>Scheduled</code>。如果 <code>PendingReview</code> 无需因为新增的状态而改变就更好了，不过这意味着切换到另一种设计模式。</p>
<p>另一个缺点是我们会发现一些重复的逻辑。为了消除他们，可以尝试为 <code>State</code> trait 中返回 <code>self</code> 的 <code>request_review</code> 和 <code>approve</code> 方法增加默认实现，不过这会违反对象安全性，因为 trait 不知道 <code>self</code> 具体是什么。我们希望能够将 <code>State</code> 作为一个 trait 对象，所以需要其方法是对象安全的。</p>
<p>另一个重复是 <code>Post</code> 中 <code>request_review</code> 和 <code>approve</code> 这两个类似的实现。他们都委托调用了 <code>state</code> 字段中 <code>Option</code> 值的同一方法，并在结果中为 <code>state</code> 字段设置了新值。如果 <code>Post</code> 中的很多方法都遵循这个模式，我们可能会考虑定义一个宏来消除重复（查看附录 D 以了解宏）。</p>
<p>完全按照面向对象语言的定义实现这个模式并没有没有尽可能的利用 Rust 的优势。让我们看看一些代码中可以做出的修改，来将无效的状态和状态转移变为编译时错误。</p>
<a class="header" href="print.html#a将状态和行为编码为类型" id="a将状态和行为编码为类型"><h4>将状态和行为编码为类型</h4></a>
<p>我们将展示如何稍微反思状态模式来进行一系列不同的权衡取舍。不同于完全封装状态和状态转移使得外部代码对其毫不知情，我们将状态编码进不同的类型。如此，Rust 的类型检查就会将任何在只能使用发布博文的地方使用草案博文的尝试变为编译时错误。</p>
<p>让我们考虑一下示例 17-11 中 <code>main</code> 的第一部分：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<p>我们仍然希望能够使用 <code>Post::new</code> 创建一个新的草案博文，并能够增加博文的内容。不过不同于存在一个草案博文时返回空字符串的 <code>content</code> 方法，我们将使草案博文完全没有 <code>content</code> 方法。这样如果尝试获取草案博文的内容，将会得到一个方法不存在的编译错误。这使得我们不可能在生产环境意外显示出草案博文的内容，因为这样的代码甚至就不能编译。示例 17-19 展示了 <code>Post</code> 结构体、<code>DraftPost</code> 结构体以及各自的方法的定义：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
       &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 17-19: 带有 <code>content</code> 方法的 <code>Post</code> 和没有 <code>content</code> 方法的 <code>DraftPost</code></span></p>
<p><code>Post</code> 和 <code>DraftPost</code> 结构体都有一个私有的 <code>content</code> 字段来储存博文的文本。这些结构体不再有 <code>state</code> 字段因为我们将类型编码为结构体的类型。<code>Post</code> 将代表发布的博文，它有一个返回 <code>content</code> 的 <code>content</code> 方法。</p>
<p>仍然有一个 <code>Post::new</code> 函数，不过不同于返回 <code>Post</code> 实例，它返回 <code>DraftPost</code> 的实例。现在不可能创建一个 <code>Post</code> 实例，因为 <code>content</code> 是私有的同时没有任何函数返回 <code>Post</code>。</p>
<p><code>DraftPost</code> 上定义了一个 <code>add_text</code> 方法，这样就可以像之前那样向 <code>content</code> 增加文本，不过注意 <code>DraftPost</code> 并没有定义 <code>content</code> 方法！如此现在程序确保了所有博文都从草案开始，同时草案博文没有任何可供展示的内容。任何绕过这些限制的尝试都会产生编译错误。</p>
<a class="header" href="print.html#a实现状态转移为不同类型的转换" id="a实现状态转移为不同类型的转换"><h4>实现状态转移为不同类型的转换</h4></a>
<p>那么如何得到发布的博文呢？我们希望强制执行的规则是草案博文在可以发布之前必须被审核通过。等待审核状态的博文应该仍然不会显示任何内容。让我们通过增加另一个结构体 <code>PendingReviewPost</code> 来实现这个限制，在 <code>DraftPost</code> 上定义 <code>request_review</code> 方法来返回 <code>PendingReviewPost</code>，并在 <code>PendingReviewPost</code> 上定义 <code>approve</code> 方法来返回 <code>Post</code>，如示例 17-20 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
# pub struct DraftPost {
#     content: String,
# }
#
impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">列表 17-20: <code>PendingReviewPost</code> 通过调用 <code>DraftPost</code> 的 <code>request_review</code> 创建，<code>approve</code> 方法将 <code>PendingReviewPost</code> 变为发布的 <code>Post</code></span></p>
<p><code>request_review</code> 和 <code>approve</code> 方法获取 <code>self</code> 的所有权，因此会消费 <code>DraftPost</code> 和 <code>PendingReviewPost</code> 实例，并分别转换为 <code>PendingReviewPost</code> 和发布的 <code>Post</code>。这样在调用 <code>request_review</code> 之后就不会遗留任何 <code>DraftPost</code> 实例，后者同理。<code>PendingReviewPost</code> 并没有定义 <code>content</code> 方法，所以尝试读取其内容会导致编译错误，<code>DraftPost</code> 同理。因为唯一得到定义了 <code>content</code> 方法的 <code>Post</code> 实例的途径是调用 <code>PendingReviewPost</code> 的 <code>approve</code> 方法，而得到 <code>PendingReviewPost</code> 的唯一办法是调用 <code>DraftPost</code> 的 <code>request_review</code> 方法，现在我们就将发博文的工作流编码进了类型系统。</p>
<p>这也意味着不得不对 <code>main</code> 做出一些小的修改。因为 <code>request_review</code> 和 <code>approve</code> 返回新实例而不是修改被调用的结构体，所以我们需要增加更多的 <code>let post =</code> 覆盖赋值来保存返回的实例。也不再能断言草案和等待审核的博文的内容为空字符串了，我们也不再需要他们：不能编译尝试使用这些状态下博文内容的代码。更新后的 <code>main</code> 的代码如示例 17-21 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">示例 17-21: <code>main</code> 中使用新的博文工作流实现的修改</span></p>
<p>不得不修改 <code>main</code> 来重新赋值 <code>post</code> 使得这个实现不再完全遵守面向对象的状态模式：状态间的转换不再完全封装在 <code>Post</code> 实现中。然而，得益于类型系统和编译时类型检查我们得到了不可能拥有无效状态的属性！这确保了特定的 bug，比如显示未发布博文的内容，将在部署到生产环境之前被发现。</p>
<p>尝试在这一部分开始所建议的增加额外需求的任务来体会使用这个版本的代码是何感觉。</p>
<p>即便 Rust 能够实现面向对象设计模式，也有其他像将状态编码进类型这样的模式存在。这些模式有着不同的权衡取舍。虽然你可能非常熟悉面向对象模式，重新思考这些问题来利用 Rust 提供的像在编译时避免一些 bug 这样有益功能。在 Rust 中面向对象模式并不总是最好的解决方案，因为 Rust 拥有像所有权这样的面向对象语言所没有的功能。</p>
<a class="header" href="print.html#a总结-16" id="a总结-16"><h2>总结</h2></a>
<p>阅读本章后，不管你是否认为 Rust 是一个面向对象语言，现在你都见识了 trait 对象是一个 Rust 中获取部分面向对象功能的方法。动态分发可以通过牺牲少量运行时性能来为你的代码提供一些灵活性。这些灵活性可以用来实现有助于代码可维护性的面向对象模式。Rust 也有像所有权这样不同于面向对象语言的功能。面向对象模式并不总是利用 Rust 实力的最好方式，但也是可用的选项。</p>
<p>接下来，让我们看看另一个提供了多样灵活性的 Rust 功能：模式。贯穿全书的模式, 我们已经和它们打过照面了，但并没有见识过它们的全部本领。让我们开始探索吧！</p>
<a class="header" href="print.html#a模式用来匹配值的结构" id="a模式用来匹配值的结构"><h1>模式用来匹配值的结构</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch18-00-patterns.md">ch18-00-patterns.md</a>
<br>
commit 928790637fb32026643c855915b4b2fd9d5abff3</p>
</blockquote>
<p>模式是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 <code>match</code> 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：</p>
<ul>
<li>字面量</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<p>这些部分描述了我们要处理的数据的形状，接着可以用其匹配值来决定程序是否拥有正确的数据来运行特定部分的代码。</p>
<!-- I think we need a concise description of what we use patterns for here,
what they provide the programmer. Hopefully you can see what I've trying to do,
above! But I think you'll agree it's not quite right, can you have a whack, try
to give the reader that explanation? -->
<!-- We tweaked the wording a bit, how's this? /Carol -->
<p>我们通过将一些值与模式相比较来使用它。如果模式匹配这些值，我们对值部分进行相应处理。回忆一下第六章讨论 <code>match</code> 表达式时像硬币分类器那样使用模式。如果数据符合这个形状，就可以使用这些命名的片段。如果不符合，与该模式相关的代码则不会运行。</p>
<p>本章是所有模式相关内容的参考。我们将涉及到使用模式的有效位置，<em>refutable</em> 与 <em>irrefutable</em> 模式的区别，和你可能会见到的不同类型的模式语法。在最后，你将会看到如何使用模式创建强大而简洁的代码。</p>
<a class="header" href="print.html#a所有可能会用到模式的位置" id="a所有可能会用到模式的位置"><h2>所有可能会用到模式的位置</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch18-01-all-the-places-for-patterns.md">ch18-01-all-the-places-for-patterns.md</a>
<br>
commit b1de391964190a0cec101ecfc86e05c9351af565</p>
</blockquote>
<p>模式出现在 Rust 的很多地方。你已经在不经意间使用了很多模式！本部分是一个所有有效模式位置的参考。</p>
<a class="header" href="print.html#match-分支" id="match-分支"><h3><code>match</code> 分支</h3></a>
<p>如第六章所讨论的，一个模式常用的位置是 <code>match</code> 表达式的分支。在形式上 <code>match</code> 表达式由 <code>match</code> 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式：</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p><code>match</code> 表达式必须是 <strong>穷尽</strong>（<em>exhaustive</em>）的，意为 <code>match</code> 表达式所有可能的值都必须被考虑到。一个确保覆盖每个可能值的方法是在最后一个分支使用捕获所有的模式 —— 比如，一个匹配任何值的名称永远也不会失败，因此可以覆盖所有匹配剩下的情况。</p>
<p>有一个特定的模式 <code>_</code> 可以匹配所有情况，不过它从不绑定任何变量。这在例如希望忽略任何未指定值的情况很有用。本章之后会详细讲解。</p>
<a class="header" href="print.html#if-let-条件表达式" id="if-let-条件表达式"><h3><code>if let</code> 条件表达式</h3></a>
<p>第六章讨论过了 <code>if let</code> 表达式，以及它是如何主要用于编写等同于只关心一个情况的 <code>match</code> 语句简写的。<code>if let</code> 可以对应一个可选的带有代码的 <code>else</code> 在 <code>if let</code> 中的模式不匹配时运行。</p>
<!-- Can you say up front why we'd use this, and not just a match? I've just
added something here, not sure if it's right -->
<!-- The first sentence says why-- it's a shorter way to write a `match` when
there's only one case we care about. Can you elaborate on why that's not clear
or up front? /Carol -->
<p>示例 18-1 展示了也可以组合并匹配 <code>if let</code>、<code>else if</code> 和 <code>else if let</code> 表达式。这相比 <code>match</code> 表达式一次只能将一个值与模式比较提供了更多灵活性；一系列 <code>if let</code>/<code>else if</code>/<code>else if let</code> 分支并不要求其条件相互关联。</p>
<p>示例 18-1 中的代码展示了一系列针对不同条件的检查来决定背景颜色应该是什么。为了达到这个例子的目的，我们创建了硬编码值的变量，在真实程序中则可能由询问用户获得。</p>
<p>如果用户指定了中意的颜色，将使用其作为背景颜色。如果今天是星期二，背景颜色将是绿色。如果用户指定了他们的年龄字符串并能够成功将其解析为数字的话，我们将根据这个数字使用紫色或者橙色。最后，如果没有一个条件符合，背景颜色将是蓝色：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-1: 结合 <code>if let</code>、<code>else if</code>、<code>else if let</code> 以及 <code>else</code></span></p>
<p>这个条件结构允许我们支持复杂的需求。使用这里硬编码的值，例子会打印出 <code>Using purple as the background color</code>。</p>
<p>注意 <code>if let</code> 也可以像 <code>match</code> 分支那样引入覆盖变量：<code>if let Ok(age) = age</code> 引入了一个新的覆盖变量 <code>age</code>，它包含 <code>Ok</code> 成员中的值。这意味着 <code>if age &gt; 30</code> 条件需要位于这个代码块内部；不能将两个条件组合为 <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>，因为我们希望与 30 进行比较的被覆盖的 <code>age</code> 直到大括号开始的新作用域才是有效的。</p>
<p><code>if let</code> 表达式的缺点在于其穷尽性没有为编译器所检查，而 <code>match</code> 表达式则检查了。如果去掉最后的 <code>else</code> 块而遗漏处理一些情况，编译器也不会警告这类可能的逻辑错误。</p>
<!-- So what would happen, we'd just end up with a program that wasn't correct,
in the Rust sense? -->
<!-- Yes, we would have a logic bug. /Carol -->
<a class="header" href="print.html#while-let-条件循环" id="while-let-条件循环"><h3><code>while let</code> 条件循环</h3></a>
<p>一个与 <code>if let</code> 结构类似的是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。示例 18-2 展示了一个使用 <code>while let</code> 的例子，它使用 vector 作为栈并以先进后出的方式打印出 vector 中的值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
#}</code></pre></pre>
<p><span class="caption">列表 18-2: 使用 <code>while let</code> 循环只要 <code>stack.pop()</code> 返回 <code>Some</code> 就打印出其值</span></p>
<!-- Some lovely simple, but edifying, examples in this chapter!-->
<p>这个例子会打印出 3、2 接着是 1。<code>pop</code> 方法取出 vector 的最后一个元素并返回 <code>Some(value)</code>。如果 vector 是空的，它返回 <code>None</code>。<code>while</code> 循环只要 <code>pop</code> 返回 <code>Some</code> 就会一直运行其块中的代码。一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p>
<a class="header" href="print.html#for-循环" id="for-循环"><h3><code>for</code> 循环</h3></a>
<p>如同第三章所讲的，<code>for</code> 循环是 Rust 中最常见的循环结构，不过还没有讲到的是 <code>for</code> 可以获取一个模式。在 <code>for</code> 循环中，模式是 <code>for</code> 关键字直接跟随的值，正如 <code>for x in y</code> 中的 <code>x</code>。</p>
<!-- Can you check the line I added above? I think it'd help to point out the
pattern section of a for loop straight away -->
<!-- Yep, looks good! /Carol -->
<p>示例 18-3 中展示了如何使用 <code>for</code> 循环来解构，或拆开一个元组作为 <code>for</code> 循环的一部分：</p>
<!-- Liz: We've been using the word "destructure" throughout the book in
chapters 3, 4, 5, and 16. In chapter 3, in the "Grouping Values into Tuples"
section, we said "This is called *destructuring*, because it breaks the single
tuple into three parts.". So I don't think we need to define destructure again
in this chapter, but I've added a small parenthetical here in case the reader
forgets. /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
#}</code></pre></pre>
<p><span class="caption">列表 18-3: 在 <code>for</code> 循环中使用模式来解构元组</span></p>
<p>这会打印出：</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>这里使用 <code>enumerate</code> 方法适配一个迭代器来产生一个值和其在迭代器中的索引，他们位于一个元组中。第一个 <code>enumerate</code> 调用会产生元组 <code>(0, 'a')</code>。当这个值匹配模式 <code>(index, value)</code>，<code>index</code> 将会是 0 而 <code>value</code> 将会是 'a'，并打印出第一行输出。</p>
<a class="header" href="print.html#let-语句" id="let-语句"><h3><code>let</code> 语句</h3></a>
<p>在本章之前，我们只明确的讨论过通过 <code>match</code> 和 <code>if let</code> 使用模式，不过事实上也在别地地方使用过模式，包括 <code>let</code> 语句。例如，考虑一下这个直白的 <code>let</code> 变量赋值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>本书进行了不下百次这样的操作。你可能没有发觉，不过你这正是在使用模式！<code>let</code> 语句更为正式的样子如下：</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>像 <code>let x = 5;</code> 这样的语句中变量名位于 <code>PATTERN</code> 位置，变量名不过是形式特别朴素的模式。我们将表达式与模式比较，并为任何找到的名称赋值。所以例如 <code>let x = 5;</code> 的情况，<code>x</code> 是一个模式代表 “将匹配到的值绑定到变量 x”。同时因为名称 <code>x</code> 是整个模式，这个模式实际上等于 “将任何值绑定到变量 <code>x</code>，不管值是什么”。</p>
<p>为了更清楚的理解 <code>let</code> 的模式匹配方面的内容，考虑示例 18-4 中使用 <code>let</code> 和模式解构一个元组：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);
#}</code></pre></pre>
<p><span class="caption">示例 18-4: 使用模式解构元组并一次创建三个变量</span></p>
<p>这里将一个元组与模式匹配。Rust 会比较值 <code>(1, 2, 3)</code> 与模式 <code>(x, y, z)</code> 并发现此值匹配这个模式。在这个例子中，将会把 <code>1</code> 绑定到 <code>x</code>，<code>2</code> 绑定到 <code>y</code> 并将 <code>3</code> 绑定到 <code>z</code>。你可以将这个元组模式看作是将三个独立的变量模式结合在一起。</p>
<!-- so if we have a pattern of four elements, say (w, x, y, z), but only three
values, would the values would not bind at all? -->
<!-- Either too many or too few elements in the pattern is a type error. I've
added a small example below to illustrate. /Carol -->
<p>如果模式中元素的数量不匹配元组中元素的数量，则整个类型不匹配，并会得到一个编译时错误。例如，示例 18-5 展示了尝试用两个变量解构三个元素的元组，这是不行的：</p>
<pre><code class="language-rust ignore">let (x, y) = (1, 2, 3);
</code></pre>
<p><span class="caption">示例 18-5: 一个错误的模式结构，其中变量的数量不符合元组中元素的数量</span></p>
<p>尝试编译这段代码会给出如下类型错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<p>如果希望忽略元组中一个或多个值，也可以使用 <code>_</code> 或 <code>..</code>，如 “忽略模式中的值” 部分所示。如果问题是模式中有太多的变量，则解决方法是通过去掉变量使得变量数与元组中元素数相等。</p>
<a class="header" href="print.html#a函数参数-1" id="a函数参数-1"><h3>函数参数</h3></a>
<p>函数参数也可以是模式。列表 18-6 中的代码声明了一个叫做 <code>foo</code> 的函数，它获取一个 <code>i32</code> 类型的参数 <code>x</code>，现在这看起来应该很熟悉：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">列表 18-6: 在参数中使用模式的函数签名</span></p>
<p><code>x</code> 部分就是一个模式！类似于之前对 <code>let</code> 所做的，可以在函数参数中匹配元组。列表 18-7 将传递给函数的元组拆分为值：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">列表 18-7: 一个在参数中解构元组的函数</span></p>
<p>这会打印出 <code>Current location: (3, 5)</code>。值 <code>&amp;(3, 5)</code> 会匹配模式 <code>&amp;(x, y)</code>，如此 <code>x</code> 得到了值 3，而 <code>y</code>得到了值 5。</p>
<p>因为如第十三章所讲闭包类似于函数，也可以在闭包参数中使用模式。</p>
<p>现在我们见过了很多使用模式的方式了，不过模式在每个使用它的地方并不以相同的方式工作；在一些地方，模式必须是 <em>irrefutable</em> 的，意味着他们必须匹配所提供的任何值。在另一些情况，他们则可以是 refutable 的。接下来让我们讨论这个。</p>
<a class="header" href="print.html#refutability可反驳性-模式是否会匹配失效" id="refutability可反驳性-模式是否会匹配失效"><h2>Refutability（可反驳性）: 模式是否会匹配失效</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch18-02-refutability.md">ch18-02-refutability.md</a>
<br>
commit 267f442fa1c637eab07b4eebb64a6dcd2c943a36</p>
</blockquote>
<p>模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 <strong>不可反驳的</strong>（<em>irrefutable</em>）。一个例子就是 <code>let x = 5;</code> 语句中的 <code>x</code>，因为 <code>x</code> 可以匹配任何值所以不可能会失败。对某些可能的值进行匹配会失败的模式被称为是 <strong>可反驳的</strong>（<em>refutable</em>）。一个这样的例子便是 <code>if let Some(x) = a_value</code> 表达式中的 <code>Some(x)</code>；如果变量 <code>a_value</code> 中的值是 <code>None</code> 而不是 <code>Some</code>，那么 <code>Some(x)</code> 模式不能匹配。</p>
<p><code>let</code> 语句、 函数参数和 <code>for</code> 循环只能接受不可反驳的模式，因为通过不匹配的值程序无法进行有意义的工作。<code>if let</code> 和 <code>while let</code> 表达式被限制为只能接受可反驳的模式，因为根据定义他们意在处理可能的失败 ———— 条件表达式的功能就是根据成功或失败执行不同的操作。</p>
<p>通常无需担心可反驳和不可反驳模式的区别，不过确实需要熟悉可反驳性的概念，这样当在错误信息中看到时就知道如何应对。遇到这些情况，根据代码行为的意图，需要修改模式或者使用模式的结构。</p>
<p>让我们看看一个尝试在 Rust 要求不可反驳模式的地方使用可反驳模式以及相反情况的例子。在示例 18-8 中，有一个 <code>let</code> 语句，不过模式被指定为可反驳模式 <code>Some(x)</code>。如你所见，这会出现错误：</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">示例 18-8: 尝试在 <code>let</code> 中使用可反驳模式</span></p>
<p>如果 <code>some_option_value</code> 的值是 <code>None</code>，其不会成功匹配模式 <code>Some(x)</code>，表明这个模式是可反驳的。然而 <code>let</code> 语句只能接受不可反驳模式因为代码不能通过 <code>None</code> 值进行有效的操作。Rust 会在编译时抱怨我们尝试在要求不可反驳模式的地方使用可反驳模式：</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; &lt;anon&gt;:3:5
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>因为我们没有（也不可能）覆盖到模式 <code>Some(x)</code> 的每一个可能的值, 所以 Rust 会合理的抗议.</p>
<p>为了修复在需要不可反驳模式的地方使用可反驳模式的情况，可以修改使用模式的代码：不同于使用 <code>let</code>，可以使用 <code>if let</code>。如此，如果模式不匹配，大括号中的代码将被忽略，其余代码保持有效。示例 18-9 展示了如何修复示例 18-8 中的代码。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_option_value: Option&lt;i32&gt; = None;
if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p><span class="caption">示例 18-9: 使用 <code>if let</code> 和一个带有可反驳模式的代码块来代替 <code>let</code></span></p>
<!-- Whats the first commented out line here, I had though this was copied from
8-7 but it isn't quite the same -->
<!-- Sorry, that line has to do with the way we test our code examples and I
missed removing it before sending this chapter to you. Sorry about that! /Carol
-->
<p>我们给了代码一个得以继续的出路！这段代码可以完美运行，当让如此意味着我们不能再使用不可反驳模式并免于收到错误。如果为 <code>if let</code> 提供了一个总是会匹配的模式，比如示例 18-10 中的 <code>x</code>，则会出错：</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">示例 18-10: 尝试把不可反驳模式用到 <code>if let</code> 上</span></p>
<p>Rust 会抱怨将不可反驳模式用于 <code>if let</code> 是没有意义的：</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>如此，匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。允许将不可反驳模式用于只有一个分支的 <code>match</code>，不过这么做不是特别有用，并可以被更简单的 <code>let</code> 语句替代。</p>
<p>目前我们已经讨论了所有可以使用模式的地方, 以及可反驳模式与不可反驳模式的区别，下面让我们一起去把可以用来创建模式的语法过目一遍吧。</p>
<a class="header" href="print.html#a所有的模式语法" id="a所有的模式语法"><h2>所有的模式语法</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch18-03-pattern-syntax.md">ch18-03-pattern-syntax.md</a>
<br>
commit 3f91c488ad4261dee6a61db4f60c197074151aac</p>
</blockquote>
<p>通过本书我们已领略过许多不同类型模式的例子. 本节会统一列出所有在模式中有效的语法并且会阐述你为什么可能会希望使用其中的每一个。</p>
<!-- We don't always go over why we might want to use them for each section
here, presumably because it's clear why it's useful. I might recommend you do
just add a line to each, since we've promised it, and just to really hammer the
point home. Definitely keep it short and sweet though, where it's pretty clear.
-->
<a class="header" href="print.html#a匹配字面值" id="a匹配字面值"><h3>匹配字面值</h3></a>
<p>如第六章所示，可以直接匹配字面值模式。如下代码给出了一些例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>这段代码会打印 <code>one</code> 因为 <code>x</code> 的值是 1。</p>
<a class="header" href="print.html#a匹配命名变量" id="a匹配命名变量"><h3>匹配命名变量</h3></a>
<!-- I found this next bit a little tougher to follow, I've tried to clarify in
this opening paragraph, connect it all up, can you please check it? -->
<!-- Yep! Looks good! /Carol -->
<p>命名变量是匹配任何值的不可反驳模式，这在之前已经使用过数次。然而当其用于 <code>match</code> 表达式时情况会有些复杂。因为 <code>match</code> 会开始一个新作用域，<code>match</code> 表达式中作为模式的一部分声明的变量会覆盖 <code>match</code> 结构之外的同名变量 ———— 与所有变量一样。在示例 18-11 中，声明了一个值为 <code>Some(5)</code> 的变量 <code>x</code> 和一个值为 <code>10</code> 的变量 <code>y</code>。接着在值 <code>x</code> 上创建了一个 <code>match</code> 表达式。观察匹配分支中的模式和结尾的 <code>println!</code>，并尝试在运行代码之前计算出会打印什么，或者继续阅读：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">示例 18-11: 一个 <code>match</code> 语句其中一个分支引入了覆盖变量 <code>y</code></span></p>
<p>让我们看看当 <code>match</code> 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 <code>x</code> 中定义的值，所以继续。</p>
<p>第二个匹配分支中的模式引入了一个新变量 <code>y</code>，它会匹配任何 <code>Some</code> 中的值。因为我们在 <code>match</code> 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 <code>y</code>。这个新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值。因此这个 <code>y</code> 绑定了 <code>x</code> 中 <code>Some</code> 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 <code>Matched, y = 5</code>。</p>
<!-- Below -- We haven't fully introduced the underscore yet, is there anything
else we could use for that final arm? -->
<!-- We have *used* the underscore briefly before, though-- we actually
introduced the underscore in chapter 6. There really isn't anything else that
we can put that will still have this example illustrating what we want to
illustrate. /Carol -->
<p>如果 <code>x</code> 的值是 <code>None</code> 而不是 <code>Some(5)</code>，头两个分支的模式不会匹配，所以会匹配下划线。这个分支的模式中没有引入变量 <code>x</code>，所以此时表达式中的 <code>x</code> 会是外部没有被覆盖的 <code>x</code>。在这个假想的例子中，<code>match</code> 将会打印 <code>Default case, x = None</code>。</p>
<p>一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>为了创建能够比较外部 <code>x</code> 和 <code>y</code> 的值，而不引入覆盖变量的 <code>match</code> 表达式，我们需要相应的使用带有条件的匹配守卫（match guard）。本部分的后面会讨论匹配守卫。</p>
<a class="header" href="print.html#a多个模式" id="a多个模式"><h3>多个模式</h3></a>
<p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>（<em>or</em>）的意思。例如，如下代码将 <code>x</code> 的值与匹配分支向比较，第一个分支有 <strong>或</strong> 选项，意味着如果 <code>x</code> 的值匹配此分支的任一个值，它就会运行：</p>
<!-- I've tried to flesh this out a bit, can you check? -->
<!-- Yep, it's fine! /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>上面的代码会打印 <code>one or two</code>。</p>
<!-- Is there a corresponding "and" operator? Is that worth tacking on here? -->
<!-- No, there is not-- how could one value match, say, 1 AND 2? Does it make
sense why there isn't an "and" operator? /Carol -->
<a class="header" href="print.html#a通过--匹配值的范围" id="a通过--匹配值的范围"><h3>通过 <code>...</code> 匹配值的范围</h3></a>
<p><code>...</code> 语法允许你匹配一个闭区间范围内的值。在如下代码中，当模式匹配任何在此范围内的值时，该分支会执行：</p>
<!-- Above--this seems like it's true, that the range allows you to match to
just one of the values? If so, can you say how this differs to using the or
operator? -->
<!-- I'm not sure what you mean by "match to just one of the values". `...`
matches any value between the two specified endpoints, which I thought would be
clear by the text below the code, and I changed "just one of" to "any of the
values within" above, and mentioned what the equivalent "or" pattern would look
like below. Does that clear it up? /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 <code>|</code> 运算符表达相同的意思更为方便；相比 <code>1 ... 5</code>，使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code>。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！</p>
<p>范围只允许用于数字或 <code>char</code> 值，因为编译器会在编译时检查范围不为空。<code>char</code> 和 数字值是 Rust 唯一知道范围是否为空的类型。</p>
<!-- why, because they are the only types with inherent order? -->
<!-- Nope, I've added the explanation /Carol -->
<p>如下是一个使用 <code>char</code> 类型值范围的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'c';

match x {
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>Rust 知道 <code>c</code> 位于第一个模式的范围内，并会打印出 <code>early ASCII letter</code>。</p>
<a class="header" href="print.html#a解构并分解值" id="a解构并分解值"><h3>解构并分解值</h3></a>
<!-- I moved the definition of destructure earlier in the chapter, to when we
first use it -->
<!-- See my comment there; we first use destructure in chapter 3 /Carol -->
<p>也可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。让我们来分别看一看。</p>
<a class="header" href="print.html#a解构结构体" id="a解构结构体"><h4>解构结构体</h4></a>
<p>示例 18-12 展示带有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>，可以通过带有模式的 <code>let</code> 语句将其分解：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">示例 18-12: 解构一个结构体的字段为单独的变量</span></p>
<!-- I'm not sure I follow which part of this is the shorthand, what is it
shorthand for, and which syntax here counts as the shorthand? Can you slow this
down, talk it through a little more. Is the point of this section that we have
a shorthand for destructuring, or that we are able to destructure these items
with patterns at all? -->
<!-- I've reorganized this section to start with the non-shorthand instead, is
this clearer? /Carol -->
<p>这段代码创建了变量 <code>a</code> 和 <code>b</code> 来匹配变量 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段。</p>
<p>这个例子展示了模式中的变量名不必与结构体中的字段名一致，不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。因为变量名匹配字段名是常见的，同时因为 <code>let Point { x: x, y: y } = p;</code> 包含了很多重复，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。示例 18-13 展示了与示例 18-12 有着相同行为的代码，不过 <code>let</code> 模式创建的变量为 <code>x</code> 和 <code>y</code> 而不是 <code>a</code> 和 <code>b</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">示例 18-13: 使用结构体字段简写来解构结构体字段</span></p>
<p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，与变量 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p>
<p>也可以在部分结构体模式中使用字面值进行结构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。</p>
<p>示例 18-14 展示了一个 <code>match</code> 语句将 <code>Point</code> 值分成了三种情况：直接位于 <code>x</code> 轴上（此时 <code>y = 0</code> 为真）、位于 <code>y</code> 轴上（<code>x = 0</code>）或其他的点：</p>
<!-- I'm not sure what you mean by "inner parts of a value" -- that we aren't
matching a whole value but part of it? -->
<!-- I've reworded, is this version clearer? /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-14: 解构和匹配模式中的字面值</span></p>
<p>第一个分支通过指定字段 <code>y</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>x</code> 轴上的点。此模式仍然创建了变量 <code>x</code> 以便在分支的代码中使用。类似的，第二个分支通过指定字段 <code>x</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>y</code> 轴上的点，并为字段 <code>y</code> 创建了变量 <code>y</code>。第三个分支没有指定任何字面值，所以其会匹配任何其他的 <code>Point</code> 并为 <code>x</code> 和 <code>y</code> 两个字段创建变量。</p>
<p>在这个例子中，值 <code>p</code> 因为其 <code>x</code> 包含 0 而匹配第二个分支，因此会打印出 <code>On the y axis at 7</code>。</p>
<a class="header" href="print.html#a解构枚举" id="a解构枚举"><h4>解构枚举</h4></a>
<p>本书之前的部分曾经解构过枚举，比如第六章中示例 6-5 中解构了一个 <code>Option&lt;i32&gt;</code>。一个当时没有明确提到的细节是解构枚举的模式需要对应枚举所定义的储存数据的方式。让我们以示例 6-2 中的 <code>Message</code> 枚举为例，编写一个 <code>match</code> 使用模式解构每一个内部值，如示例 18-15 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-15: 解构包含不同类型值成员的枚举</span></p>
<p>这段代码会打印出 <code>Change the color to red 0, green 160, and blue 255</code>。尝试改变 <code>msg</code> 的值来观察其他分支代码的运行。</p>
<p>对于像 <code>Message::Quit</code> 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 <code>Message::Quit</code>，因此模式中没有任何变量。</p>
<p>对于像 <code>Message::Move</code> 这样的类结构体枚举成员，可以采用类似于匹配结构体的模式。在成员名称后，使用大括号并列出字段变量以便将其分解以供此分支的代码使用。这里使用了示例 18-13 所真实的简写。</p>
<p>对于像 <code>Message::Write</code> 这样的包含一个元素，以及像 <code>Message::ChangeColor</code> 这样包含两个元素的类元组枚举成员，其模式则类似于用于解构元组的模式。模式中变量的数量必须与成员中元素的数量一致。</p>
<a class="header" href="print.html#a解构引用" id="a解构引用"><h4>解构引用</h4></a>
<p>当模式所匹配的值中包含引用时，需要解构引用之中的值，这可以通过在模式中指定 <code>&amp;</code> 做到。这让我们得到一个包含引用所指向数据的变量，而不是包含引用的变量。</p>
<!-- What does it mean, to separate the reference and the value, precisely? So
that we specify Rust use the value in place of the reference? And what does &
here do, tell Rust to follow the reference to the value itself, rather than
work on the reference?-->
<!-- Yes, pretty much. I've tried rewording, is this clearer? /Carol -->
<p>这在迭代器遍历引用，不过我们需要使用闭包中的值而不是其引用时非常有用</p>
<p>示例 18-16 中的例子遍历一个 vector 中的 <code>Point</code> 实例的引用，并同时解构引用和其中的结构体以方便对 <code>x</code> 和 <code>y</code> 值进行计算：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];

let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point { x, y }| x * x + y * y)
    .sum();
#}</code></pre></pre>
<p><span class="caption">示例 18-16: 将结构体的引用解构到其字段值中</span></p>
<!-- and what do we actually get, instead of the error? -->
<!-- Added explanation text below /Carol -->
<p>这段代码的结果是变量 <code>sum_of_squares</code> 的值为 135，这个结果是将 <code>points</code> vector 中每一个 <code>Point</code> 的 <code>x</code> 和 <code>y</code> 的平方相加后求和得到的数字。</p>
<p>如果没有在 <code>&amp;Point { x, y }</code> 中包含 <code>&amp;</code> 则会得到一个类型不匹配错误，因为这样 <code>iter</code> 会遍历 vector 中项的引用而不是值本身。这个错误看起来像这样：</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point { x, y }| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<p>这个错误表明 Rust 期望闭包匹配 <code>&amp;Point</code>，不过我们尝试直接匹配 <code>Point</code> 值，而不是 <code>Point</code> 的引用。</p>
<a class="header" href="print.html#a解构结构体和元组" id="a解构结构体和元组"><h4>解构结构体和元组</h4></a>
<p>甚至可以用复杂的方式来合成、匹配和嵌套解构模式。如下是一个负责结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
#}</code></pre></pre>
<p>这将复杂的类型分解成部分组件以便可以单独使用我们感兴趣的值。</p>
<!-- Can you round up the destructuring section here before we move on. For
this bit, maybe say explicitly what this would be useful for -->
<!-- Done /Carol -->
<p>通过模式解构是一个方便利用部分值片段的手段，比如结构体中每个单独字段的值。</p>
<a class="header" href="print.html#a忽略模式中的值" id="a忽略模式中的值"><h3>忽略模式中的值</h3></a>
<p>有时忽略模式中的一些值是有用的，比如 <code>match</code> 中最后捕获全部情况的分支实际上没有做任何事，但是它确实对所有剩余情况负责。有一些简单的方法可以忽略模式中全部或部分值：使用 <code>_</code> 模式（我们已经见过了），在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。让我们来分别探索如何以及为什么要这么做。</p>
<a class="header" href="print.html#a使用-_-忽略整个值" id="a使用-_-忽略整个值"><h4>使用 <code>_</code> 忽略整个值</h4></a>
<p>我们已经使用过下划线作为匹配但不绑定任何值的通配符模式了。虽然下划线模式作为 <code>match</code> 表达式最后的分支特别有用，也可以将其用于任意模式，包括函数参数中，如示例 18-17 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">示例 18-17: 在函数签名中使用 <code>_</code></span></p>
<!-- What is this doing exactly, can you help the reader out here? Are we
letting the function run without a parameter at all? I'm not sure the purpose
clear enough at the moment -->
<!-- Done /Carol -->
<p>这段代码会完全忽略作为第一个参数传递的值，3，并会打印出 <code>This code only uses the y parameter: 4</code>。大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。</p>
<p>在一些情况下忽略函数参数会变得特别有用，比如实现 trait 时，当你需要特定类型签名但是函数实现并不需要某个参数时。此时编译器就不会警告说存在未使用的函数参数，就跟使用命名参数一样。</p>
<a class="header" href="print.html#a使用嵌套的-_-忽略部分值" id="a使用嵌套的-_-忽略部分值"><h4>使用嵌套的 <code>_</code> 忽略部分值</h4></a>
<!-- When would we want to do this? -->
<!-- Done, moved the explanation up and made the example have a bit more
motivation /Carol -->
<p>当只需要测试部分值但在期望运行的代码部分中没有使用它们时，也可以在另一个模式内部使用 <code>_</code> 来只忽略部分值。示例 18-18 展示了负责从设置中获取一个值的代码。业务需求是用户不允许覆盖某个设置中已经存在的自定义配置，但是可以重设设置和在目前未设置时提供新的设置。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
#}</code></pre></pre>
<p><span class="caption">使用 18-18: 当不需要 <code>Some</code> 中的值时在模式内使用下划线来匹配 <code>Some</code> 成员</span></p>
<p>这段代码会打印出 <code>Can't overwrite an existing customized value</code> 接着是 <code>setting is Some(5)</code>。在第一个匹配分支，我们不需要匹配或使用任一个 <code>Some</code> 成员中的值；重要的部分是需要测试 <code>setting_value</code> 和 <code>new_setting_value</code> 都为 <code>Some</code> 成员的情况。在这种情况，我们希望打印出为何不改变 <code>setting_value</code>，并且不会改变它。</p>
<p>对于所有其他情况（<code>setting_value</code> 或 <code>new_setting_value</code> 任一为 <code>None</code>），这由第二个分支的 <code>_</code> 模式体现，这时确实希望允许 <code>new_setting_value</code> 变为 <code>setting_value</code>。</p>
<!-- So when we need to match but don't actually need the value, is that what
we're saying? -->
<!-- Yes /Carol -->
<p>也可以在一个模式中的多处使用下划线来忽略特定值，如示例 18-19 所示，这里忽略了一个五元元组中的第二和第四个值：</p>
<p>我们也可以在一个模式中多处使用下划线, 在例18-17中我们将忽略掉一个五元元组中的第二和第四个值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
#}</code></pre></pre>
<p><span class="caption">示例 18-19: 忽略元组的多个部分</span></p>
<p>这会打印出 <code>Some numbers: 2, 8, 32</code>, 值 4 和 16 会被忽略。</p>
<a class="header" href="print.html#a通过在名字前以一个下划线开头来忽略未使用的变量" id="a通过在名字前以一个下划线开头来忽略未使用的变量"><h4>通过在名字前以一个下划线开头来忽略未使用的变量</h4></a>
<p>如果你创建了一个变量却不在任何地方使用它, Rust 通常会给你一个警告，因为这可能会是个 bug。但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。示例 18-20 中创建了两个未使用变量，不过当运行代码时只会得到其中一个的警告：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">示例 18-20: 以下划线开始变量名以便去掉未使用变量警告</span></p>
<p>这里得到了警告说未使用变量 <code>y</code>，不过没有警告说未使用下划线开头的变量。</p>
<p>注意, 只使用<code>_</code>和使用以下划线开头的名称有些微妙的不同：比如 <code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。为了展示这个区别的意义，示例 18-21 会产生一个错误。</p>
<pre><code class="language-rust ignore">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">示例 18-21: 以下划线开头的未使用变量仍然会绑定值，它可能会获取值的所有权</span></p>
<p>我们会得到一个错误，因为 <code>s</code> 的值仍然会移动进 <code>_s</code>，并阻止我们再次使用 <code>s</code>。然而只使用下划线本身，并不会绑定值。示例 18-22 能够无错编译，因为 <code>s</code> 没有被移动进 <code>_</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
#}</code></pre></pre>
<p><span class="caption">示例 18-22: 单独使用下划线不会绑定值</span></p>
<p>上面的代码能很好的运行；因为没有把 <code>s</code> 绑定到任何变量，它没有被移动。</p>
<a class="header" href="print.html#a用--忽略剩余值" id="a用--忽略剩余值"><h4>用 <code>..</code> 忽略剩余值</h4></a>
<p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分并忽略其它值，同时避免不得不每一个忽略值列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分。在示例 18-23 中，有一个 <code>Point</code> 结构体存放了三维空间中的坐标。在 <code>match</code> 表达式中，我们希望只操作 <code>x</code> 坐标并忽略 <code>y</code> 和 <code>z</code> 字段的值：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
#}</code></pre></pre>
<p><span class="caption">示例 18-23: 通过使用 <code>..</code> 来忽略 <code>Point</code> 中除 <code>x</code> 以外的字段</span></p>
<p>这里列出了 <code>x</code> 值，接着仅仅包含了 <code>..</code> 模式。这比不得不列出 <code>y: _</code> 和 <code>z: _</code> 要来得简单，特别是在处理有很多字段的结构体，但只涉及一到两个字段时的情形。</p>
<p><code>..</code> 会扩展为所需要的值的数量。示例 18-24 展示了元组中 <code>..</code> 的应用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">示例 18-24: 用 <code>..</code> 匹配元组中的第一个和最后一个值并忽略掉所有其它值</span></p>
<p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p>
<p>然而使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。示例 18-25 展示了一个带有歧义的 <code>..</code> 应用，因此其不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">示例 18-25: 尝试以有歧义的方式运用 <code>..</code></span></p>
<p>如果编译上面的例子，会得到下面的错误：</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>Rust 不可能决定在元组中匹配 <code>second</code> 值之前应该忽略多少个值，以及在之后忽略多少个值。这段代码可能表明我们意在忽略 2，绑定 <code>second</code> 为 4，接着忽略 8、16 和 32；抑或是意在忽略 2 和 4，绑定 <code>second</code> 为 8，接着忽略 16 和 32，以此类推。变量名 <code>second</code> 对于 Rust 来说并没有任何特殊意义，所以会得到编译错误，因为在这两个地方使用 <code>..</code> 是有歧义的。</p>
<a class="header" href="print.html#a使用-ref-和-ref-mut-在模式中创建引用" id="a使用-ref-和-ref-mut-在模式中创建引用"><h3>使用 <code>ref</code> 和 <code>ref mut</code> 在模式中创建引用</h3></a>
<p>这里我们将看到使用 <code>ref</code> 来创建引用，这样值的所有权就不会移动到模式的变量中。通常当匹配模式时，模式所引入的变量将绑定一个值。Rust 的所有权规则意味着这个值将被移动到 <code>match</code> 中，或者任何使用此模式的位置。示例 18-26 展示了一个带有变量的模式的例子，并接着在 <code>match</code> 之后使用这整个值。这会编译失败，因为值 <code>robot_name</code> 的一部分在第一个 <code>match</code> 分支时被移动到了模式的变量 <code>name</code> 中：</p>
<!-- Can you lay out what is supposed to happen with this code, that doesn't
work? -->
<!-- Done /Carol -->
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<p><span class="caption">示例 18-26: 在匹配分支的模式中创建获取值所有权的变量</span></p>
<p>这个例子会编译失败，因为当 <code>name</code> 绑定 <code>robot_name</code> 的 <code>Some</code> 中的值时，其被移动到了 <code>match</code> 中。因为 <code>robot_name</code> 的部分所有权被移动到了 <code>name</code> 中，就不再能够在 <code>match</code> 之后的 <code>println!</code> 中使用 <code>robot_name</code>，因为 <code>robot_name</code> 不再有所有权。</p>
<!-- Above -- why will that make it fail, because the bind is then invalid? -->
<!-- Yes, I've clarified a bit /Carol -->
<!--Below -- Is this then the solution, introducing &? I assume so, because we
don’t have & in the example above, but the connection isn't clear -->
<!-- No, the solution is introducing `ref`. I've clarified /Carol -->
<p>为了修复这段代码，需要让 <code>Some(name)</code> 模式借用部分 <code>robot_name</code> 而不是获取其所有权。在模式之外，我们见过了使用 <code>&amp;</code> 创建引用来借用值，所以可能会想到的解决方案是将 <code>Some(name)</code> 改为 <code>Some(&amp;name)</code>。</p>
<p>然而，在 “解构并分解值” 部分我们见过了模式中的 <code>&amp;</code> 并不能 <strong>创建</strong> 引用，它会 <strong>匹配</strong> 值中已经存在的引用。因为 <code>&amp;</code> 在模式中已经有其他意义，不能够使用 <code>&amp;</code> 在模式中创建引用。</p>
<p>相对的，为了在模式中创建引用，可以在新变量前使用 <code>ref</code> 关键字，如示例 18-27 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">示例 18-27: 创建一个引用以便模式变量不会获取其所有权</span></p>
<p>这个例子可以编译，因为 <code>robot_name</code> 中 <code>Some</code> 成员的值没有被移动到 <code>match</code> 中；<code>match</code> 值获取了 <code>robot_name</code> 中数据的引用而没有移动它。</p>
<p>为了能够修改模式中匹配的值需要创建可变引用，使用 <code>ref mut</code> 替代 <code>&amp;mut</code>，类似于上面用 <code>ref</code> 替代 <code>&amp;</code>：模式中的 <code>&amp;mut</code> 用于匹配已经存在的可变引用，而不是新建一个。示例 18-28 展示了一个创建可变引用模式的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">示例 18-28: 在模式中使用 <code>ref mut</code> 来创建一个值的可变引用</span></p>
<p>上例可以编译并打印出 <code>robot_name is: Some(&quot;Another name&quot;)</code>。因为 <code>name</code> 是一个可变引用，我们需要在匹配分支代码中使用 <code>*</code> 运算符解引用以便能够修改它。</p>
<a class="header" href="print.html#a匹配守卫提供的额外条件" id="a匹配守卫提供的额外条件"><h3>匹配守卫提供的额外条件</h3></a>
<!-- Can you give a full definition of a match guard here, and what we use it
for, before covering how to do it? -->
<p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定与 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。</p>
<p>这个条件可以使用模式中创建的变量。示例 18-29 展示了一个 <code>match</code>，其中第一个分支有模式 <code>Some(x)</code> 还有匹配守卫 <code>if x &lt; 5</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">示例 18-29: 在模式中加入匹配守卫</span></p>
<p><span class="caption">例18-27: 往一个模式中加入匹配守卫</span></p>
<p>上例会打印出 <code>less than five: 4</code>。当 <code>num</code> 与模式中第一个分支比较时，因为 <code>Some(4)</code> 匹配 <code>Some(x)</code> 所以可以匹配。接着匹配守卫检查 <code>x</code> 值是否小于 5，因为 4 小于 5，所以第一个分支被选择。</p>
<p>相反如果 <code>num</code> 为 <code>Some(10)</code>，因为 10 不小于 5 所以第一个分支的匹配守卫为假。接着 Rust 会前往第二个分支，这会匹配因为它没有匹配守卫所以会匹配任何 <code>Some</code> 成员。</p>
<p>无法在模式中表达 <code>if x &lt; 5</code> 的条件，所以匹配守卫提供了表现此逻辑的能力。</p>
<!-- I think we need this spelled out, can you say what it is the match guard
is doing here? I've had a guess above, but I think it needs your review! -->
<!-- Reviewed and tweaked a bit! /Carol -->
<p>在示例 18-11 中，我们提到可以使用匹配守卫来解决模式中变量覆盖的问题，那里 <code>match</code> 表达式的模式中新建了一个变量而不是使用 <code>match</code> 之外的同名变量。新变量意味着不能够测试外部变量的值。实例 18-30 展示了如何使用匹配守卫修复这个问题：</p>
<!-- Can you check this above -- I've tried to paraphrase the final paragraph
from that section. -->
<!-- Checked and reworded a bit /Carol -->
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">示例 18-30: 使用匹配守卫来测试与外部变量的相等性</span></p>
<p>现在这会打印出 <code>Default case, x = Some(5)</code>。现在第二个匹配分支中的模式不会引入一个覆盖外部 <code>y</code> 的新变量 <code>y</code>，这意味着可以在匹配守卫中使用外部的 <code>y</code>。相比指定会覆盖外部 <code>y</code> 的模式 <code>Some(y)</code>，这里指定为 <code>Some(n)</code>。此新建的变量 <code>n</code> 并没有覆盖任何值，因为 <code>match</code> 外部没有变量 <code>n</code>。</p>
<p>在匹配守卫 <code>if n == y</code> 中，这并不是一个模式所以没有引入新变量。这个 <code>y</code> <strong>正是</strong> 外部的 <code>y</code> 而不是新的覆盖变量 <code>y</code>，这样就可以通过比较 <code>n</code> 和 <code>y</code> 来表达寻找一个与外部 <code>y</code> 相同的值的概念了。</p>
<!-- Why is this one not introducing a new variable y but 18-10 was? Instead we
create a new variable n and then compare it to the outer y, is that it? In
which case, I'm not understanding how we get n from destructuring x, can you
lay this out?-->
<!-- I've elaborated a bit, does this clear it up? /Carol -->
<p>也可以在匹配守卫中使用或运算符 <code>|</code> 来指定多个模式，同时匹配守卫的条件会作用域所有的模式。示例 18-31 展示了结合匹配守卫与使用了 <code>|</code> 的模式的优先级。这个例子中重要的部分是匹配守卫 <code>if y</code> 作用于 4、5 <strong>和</strong> 6，即使这看起来好像 <code>if y</code> 只作用于 6：</p>
<!-- What's the match condition actually doing here, with y having a value of
`false`? Can you let us know how that's being applied to all the values in that
match arm? -->
<!-- The point of the example here is to illustrate operator precedence, that
this code might look like it's saying `4 | 5 | (6 if y)` but it's actually
saying `(4 | 5 | 6) if y`. I've tried to elaborate above and below, does that
make sense now? /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<p><span class="caption">示例 18-31: 结合多个模式与匹配守卫</span></p>
<p>这个匹配条件表明此分支值匹配 <code>x</code> 值为 4、5 或 6 <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。运行这段代码时会发生的是第一个分支的模式因 <code>x</code> 为 4 而匹配，不过匹配守卫 <code>if y</code> 为假，所以第一个分支不会被选择。代码移动到第二个分支，这会匹配，此程序会打印出 <code>no</code>。</p>
<!-- Is this what we mean, if 4 or 5 or 6 being equal to x is false, run the
first arm? And so, because it's applying that to all of the values (including
4), the second arm is run and not the first? -->
<!-- It seems like `if y` was confusing, I've tried to spell it out a bit more.
Does this make sense now? /Carol -->
<p>这是因为 <code>if</code> 条件作用于整个 <code>4 | 5 | 6</code> 模式，而不仅是最后的值 <code>6</code>。换句话说，匹配守卫与模式的优先级关系看起来像这样：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>可以通过运行代码时的情况看出这一点：如果匹配守卫只作用于由 <code>|</code> 运算符指定的值列表的最后一个值，这个分支就会匹配且程序会打印出 <code>yes</code>。</p>
<a class="header" href="print.html#a-绑定" id="a-绑定"><h3><code>@</code> 绑定</h3></a>
<!-- Below - use @ to what, can you say explicitly what it does. Also what the
name of the operator is? -->
<!-- I don't think it has a name other than "the at operator". And we tried to
say what it does-- it creates a variable at the same time as letting us test
it, I've tried rewording a bit but I'm not sure why that wasn't explicit
enough, can you clarify if this still doesn't make sense? /Carol -->
<p>at 运算符 <code>@</code> 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。示例 18-32 展示了一个例子，这里我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3...7</code> 范围内，同时也希望能其值绑定到 <code>id_variable</code> 变量中以便此分支相关联的代码可以使用它。可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
#}</code></pre></pre>
<p><span class="caption">示例 18-32: 使用 <code>@</code> 在模式中绑定值的同时测试它</span></p>
<p>上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3...7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时测试其值匹配这个范围模式。</p>
<p>第二个分支只在模式中指定了一个范围，分支相关代码代码没有一个包含 <code>id</code> 字段实际值的变量。<code>id</code> 字段的值将会是 10、11 或 12，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p>
<p>最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>，因为这里使用了结构体字段简写语法。不过此分支中不能像头两个分支那样对 <code>id</code> 字段的值进行任何测试：任何值都会匹配此分支。</p>
<p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值。</p>
<a class="header" href="print.html#a总结-17" id="a总结-17"><h2>总结</h2></a>
<p>模式是 Rust 中一个很有用的功能，它帮助我们区分不同类型的数据。当用于 <code>match</code> 语句时，Rust 确保模式会包含每一个可能的值，否则程序将不能编译。<code>let</code> 语句和函数参数的模式使得这些结构更强大，可以在将值解构为更小部分的同时为变量赋值。可以创建简单或复杂的模式来满足我们的要求。</p>
<p>现在，作为本书的倒数第二个章节，让我们看看一些 Rust 众多功能中较为高级的部分。</p>
<a class="header" href="print.html#a高级特征" id="a高级特征"><h1>高级特征</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-00-advanced-features.md">ch19-00-advanced-features.md</a>
<br>
commit 9f03d42e2f47871fe813496b9324548ef4457862</p>
</blockquote>
<p>我们已经走得很远了！现在我们已经学习了 99% 的编写 Rust 时需要了解的内容。在第二十章开始另一个新项目之前，让我们聊聊你可能会遇到的最后 1% 的内容。当你不经意间遇到未知的内容时请随意将本章作为参考；这里将要学习的特征在某些非常特定的情况下很有用处。我们并不希望忽略这些特性，但是你会发现很少会碰到它们。</p>
<p>本章将涉及如下内容：</p>
<ul>
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并由你自己负责维持这些保证</li>
<li>高级生命周期：用于复杂生命周期情况的语法</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）和 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，“never” 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
</ul>
<p>对所有人而言，这都是一个介绍 Rust 迷人特性的宝典！让我们翻开它吧！</p>
<a class="header" href="print.html#a不安全-rust" id="a不安全-rust"><h2>不安全 Rust</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-01-unsafe-rust.md">ch19-01-unsafe-rust.md</a>
<br>
commit c2b43bd978a9176ac9aba22595e33d2335b2d04b</p>
</blockquote>
<p>目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：不安全 Rust。它与常规 Rust 代码无异，但是会提供额外的超级力量。</p>
<p>不安全 Rust 之所以存在，是因为静态分析本质上是保守的。当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些。这必然意味着有时代码可能是合法的，但是 Rust 不这么认为！在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”这么做的缺点就是你只能靠自己了：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用。</p>
<p>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。Rust 需要能够进行像直接与操作系统交互，甚至于编写你自己的操作系统这样的底层系统编程！这也是 Rust 语言的目标之一。让我们看看不安全 Rust 能做什么，和怎么做。</p>
<a class="header" href="print.html#a不安全的超级力量" id="a不安全的超级力量"><h3>不安全的超级力量</h3></a>
<p>可以通过 <code>unsafe</code> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有四类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作。称之为 “不安全的超级力量。”这些超级力量是：</p>
<ol>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
</ol>
<p>有一点很重要，<code>unsafe</code> 并不会关闭借用检查器或禁用任何其他 Rust 安全检查：如果在不安全代码中使用引用，其仍会被检查。<code>unsafe</code> 关键字只是提供了那四个不会被编译器检查内存安全的功能。你仍然能在不安全块中获得某种程度的安全！</p>
<p>再者，<code>unsafe</code> 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员你将会确保 <code>unsafe</code> 块中的代码以有效的方式访问内存。</p>
<p>人是会犯错误的，错误总会发生，不过通过要求这四类操作必须位于标记为 <code>unsafe</code> 的块中，就能够知道任何与内存安全相关的错误必定位于 <code>unsafe</code> 块内。保持 <code>unsafe</code> 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了。</p>
<p>为了尽可能隔离不安全代码，将不安全代码封装进一个安全的抽象并提供安全 API 是一个好主意，当我们学习不安全函数和方法时会讨论到。标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象。这个计数防止了 <code>unsafe</code> 泄露到所有你或者用户希望使用由 <code>unsafe</code> 代码实现的功能的地方，因为使用其安全抽象是安全的。</p>
<p>让我们按顺序依次介绍上述四个超级力量，同时我们会看到一些提供不安全代码的安全接口的抽象。</p>
<a class="header" href="print.html#a解引用裸指针" id="a解引用裸指针"><h3>解引用裸指针</h3></a>
<p>回到第四章的 “悬垂引用” 部分，那里提到了编译器会确保引用总是有效的。不安全 Rust 有两个被称为 <strong>裸指针</strong>（<em>raw pointers</em>）的类似于引用的新类型。和引用一样，裸指针是可变或不可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号不是解引用运算符；它是类型名称的一部分。在裸指针的上下文中，“裸指针” 意味着指针解引用之后不能直接赋值。</p>
<p>与引用和智能指针的区别在于，记住裸指针</p>
<ul>
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>
<p>通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用。</p>
<!-- Can you say here what benefits these provide, over smart pointers and
references, and using the aspects in these bullets? -->
<!-- There aren't really benefits to each of these individually. These are the
caveats that the reader needs to be aware of when working with raw pointers.
You'd choose to use raw pointers to do something that you can't do with smart
pointers or references. I've tried to clarify above /Carol -->
<p>示例 19-1 展示了如何从引用同时创建不可变和可变裸指针。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
#}</code></pre></pre>
<p><span class="caption">示例 19-1: 通过引用创建裸指针</span></p>
<!--So we create a raw pointer using the dereference operator? Is that the same
operator? Is it worth touching on why? -->
<!-- It's not the dereference operator, the * is part of the type. Tried to
clarify above where the types are introduced /Carol -->
<p>注意这里没有引入 <code>unsafe</code> 关键字 ———— 可以在安全代码中 <strong>创建</strong> 裸指针，只是不能在不安全块之外 <strong>解引用</strong> 裸指针，稍后便会看到。</p>
<p>这里使用 <code>as</code> 将不可变和可变引用强转为对应的裸指针类型。因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设。</p>
<p>接下来会创建一个不能确定其有效性的裸指针，示例 19-2 展示了如何创建一个指向任意内存地址的裸指针。尝试使用任意内存是未定义行为：此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误（segfault）。通常没有好的理由编写这样的代码，不过却是可行的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let address = 0x012345usize;
let r = address as *const i32;
#}</code></pre></pre>
<p><span class="caption">示例 19-2: 创建指向任意内存地址的裸指针</span></p>
<p>记得我们说过可以在安全代码中创建裸指针，不过不能 <strong>解引用</strong> 裸指针和读取其指向的数据。现在我们要做的就是对裸指针使用解引用运算符 <code>*</code>，只要求一个 <code>unsafe</code> 块，如示例 19-3 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
#}</code></pre></pre>
<p><span class="caption">示例 19-3: 在 <code>unsafe</code> 块中解引用裸指针</span></p>
<p>创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。</p>
<p>还需注意示例 19-1 和 19-3 中创建了同时指向相同内存位置 <code>num</code> 的裸指针 <code>*const i32</code> 和 <code>*mut i32</code>。相反如果尝试创建 <code>num</code> 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用。通过裸指针，就能够同时创建同一地址的可变指针和不可变指针，若通过可变指针修改数据，则可能潜在造成数据竞争。请多加小心！</p>
<p>既然存在这么多的危险，为何还要使用裸指针呢？一个主要的应用场景便是调用 C 代码接口，这在下一部分不安全函数中会讲到。另一个场景是构建借用检查器无法理解的安全抽象。让我们先介绍不安全函数，接着看一看使用不安全代码的安全抽象的例子。</p>
<a class="header" href="print.html#a调用不安全函数或方法" id="a调用不安全函数或方法"><h3>调用不安全函数或方法</h3></a>
<p>第二类要求使用不安全块的操作是调用不安全函数。不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <code>unsafe</code>。<code>unsafe</code> 表明我们作为程序需要满足其要求，因为 Rust 不会保证满足这些要求。通过在 <code>unsafe</code> 块中调用不安全函数，我们表明已经阅读过此函数的文档并对其是否满足函数自身的契约负责。</p>
<!-- Above -- so what is the difference, when and why would we ever use the
unsafe function? -->
<!-- Tried to clarify /Carol -->
<p>如下是一个没有做任何操作的不安全函数 <code>dangerous</code> 的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
#}</code></pre></pre>
<p>必须在一个单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。如果尝试不使用 <code>unsafe</code> 块调用 <code>dangerous</code>，则会得到一个错误：</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>通过将 <code>dangerous</code> 调用插入 <code>unsafe</code> 块中，我们就向 Rust 保证了我们已经阅读过函数的文档，理解如何正确，并验证过所有内容的正确性。</p>
<p>不安全函数体也是有效的 <code>unsafe</code> 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 <code>unsafe</code> 块。</p>
<a class="header" href="print.html#a创建不安全代码的安全抽象" id="a创建不安全代码的安全抽象"><h4>创建不安全代码的安全抽象</h4></a>
<p>仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。作为一个例子，标准库中的函数，<code>split_at_mut</code>，它需要一些不安全代码，让我们探索如何可以实现它。这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。<code>split_at_mut</code> 的用法如示例 19-4 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
#}</code></pre></pre>
<p><span class="caption">示例 19-4: 使用安全的 <code>split_at_mut</code> 函数</span></p>
<p>这个函数无法只通过安全 Rust 实现。一个尝试可能看起来像示例 19-5，它不能编译。处于简单考虑，我们将 <code>split_at_mut</code> 实现为函数而不是方法，并只处理 <code>i32</code> 值而非泛型 <code>T</code> 的 slice。</p>
<p>用安全的Rust代码是不能实现这个函数的. 如果要试一下用安全的Rust来实现它可以参考例19-5. 简单起见, 我们把<code>split_at_mut</code>实现成一个函数而不是一个方法, 这个函数只处理<code>i32</code>类型的切片而不是泛型类型<code>T</code>的切片:</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">示例 19-5: 尝试只使用安全 Rust 来实现 <code>split_at_mut</code></span></p>
<p>此函数有限获取 slice 的长度，然后通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中。该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic。</p>
<p>次后我们在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 <code>mid</code> 索引，另一个从 <code>mid</code> 直到原 slice 的结尾。</p>
<p>如果尝试编译此代码，会得到一个错误：</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>Rust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。本质上借用 slice 的不同部分是可以的，因为这样两个 slice 不会重叠，不过 Rust 还没有智能到理解这些。当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了</p>
<p>示例 19-6 展示了如何使用 <code>unsafe</code> 块，裸指针和一些不安全函数调用来实现 <code>split_at_mut</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 19-6: 在 <code>split_at_mut</code> 函数的实现中使用不安全代码</span></p>
<p>回忆第四章的 “Slice” 部分，slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 <code>len</code> 方法获取 slice 的长度，使用 <code>as_mut_ptr</code> 方法访问 slice 的裸指针。在这个例子中，因为有一个 <code>i32</code> 值的可变 slice，<code>as_mut_ptr</code> 返回一个 <code>*mut i32</code> 类型的裸指针，储存在 <code>ptr</code> 变量中。</p>
<p>我们保持索引 <code>mid</code> 位于 slice 中的断言。接着是不安全代码：<code>slice::from_raw_parts_mut</code> 函数获取一个裸指针和一个长度来创建一个 slice。这里使用此函数从 <code>ptr</code> 中创建了一个有 <code>mid</code> 个项的 slice。之后在 <code>ptr</code> 上调用 <code>offset</code> 方法并使用 <code>mid</code> 作为参数来获取一个从 <code>mid</code> 开始的裸指针，使用这个裸指针并以 <code>mid</code> 之后项的数量为长度创建一个 slice。</p>
<p><code>slice::from_raw_parts_mut</code> 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。裸指针上的 <code>offset</code> 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。因此必须将 <code>slice::from_raw_parts_mut</code> 和 <code>offset</code> 放入 <code>unsafe</code> 块中以便能调用它们。通过观察代码，和增加 <code>mid</code> 必然小于等于 <code>len</code> 的断言，我们可以说 <code>unsafe</code> 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 <code>unsafe</code> 的恰当用法。</p>
<p>注意无需将 <code>split_at_mut</code> 函数的结果标记为 <code>unsafe</code>，并可以在安全 Rust 中调用此函数。我们创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 <code>unsafe</code> 代码，因为其只从这个函数访问的数据中创建了有效的指针。</p>
<p>与此相对，示例 19-7 中的 <code>slice::from_raw_parts_mut</code> 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
#}</code></pre></pre>
<p><span class="caption">示例 19-7: 通过任意内存地址创建 slice</span></p>
<p>我们并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 <code>i32</code> 值。试图使用臆测为有效的 <code>slice</code> 会导致未定义的行为。</p>
<a class="header" href="print.html#a使用-extern-函数调用外部代码" id="a使用-extern-函数调用外部代码"><h4>使用 <code>extern</code> 函数调用外部代码</h4></a>
<p>有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字，<code>extern</code>，有助于创建和使用 <strong>外部函数接口</strong>（<em>Foreign Function Interface</em>， FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。</p>
<!-- Can you give a definition for FFI? -->
<!-- Done /Carol -->
<p>示例 19-8 展示了如何集成 C 标准库中的 <code>abs</code> 函数。<code>extern</code> 块中声明的函数在 Rust 代码中总是不安全的，因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任：</p>
<p>有时, 你的Rust代码需要与其它语言交互. Rust有一个<code>extern</code>关键字可以实现这个功能, 这有助于创建并使用<em>外部功能接口(Foreign Function Interface)</em> (FFI). 例19-8演示了如何与定义在一个非Rust语言编写的外部库中的<code>some_function</code>进行交互. 在Rust中调用<code>extern</code>声明的代码块永远都是不安全的:</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">示例 19-8: 声明并调用另一个语言中定义的 <code>extern</code> 函数</span></p>
<p>在 <code>extern &quot;C&quot;</code> 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。<code>&quot;C&quot;</code> 部分定义了外部函数所使用的 <strong>应用程序接口</strong>（<em>application binary interface</em>，ABI） —— ABI 定义了如何在汇编语言层面调用此函数。<code>&quot;C&quot;</code> ABI 是最常见的，并遵循 C 编程语言的 ABI。</p>
<!-- PROD: START BOX -->
<a class="header" href="print.html#a通过其它语言调用-rust-函数" id="a通过其它语言调用-rust-函数"><h5>通过其它语言调用 Rust 函数</h5></a>
<p>也可以使用 <code>extern</code> 来创建一个允许其他语言调用 Rust 函数的接口。不同于 <code>extern</code> 块，就在 <code>fn</code> 关键字之前增加 <code>extern</code> 关键字并指定所用到的 ABI。还需增加 <code>#[no_mangle]</code> 注解来告诉 Rust 编译器不要 mangle 此函数的名称。mangle 发生于当编译器将我们指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读。每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling。</p>
<!-- have we discussed mangling before this? It doesn't ring a bell with me,
though it may have been in an early chapter that I forgot --- if not could you
give a quick explanation here? -->
<!-- I've tried, without going into too much detail! /Carol -->
<p>在如下的例子中，一旦其编译为动态库并从 C 语言中链接，<code>call_from_c</code> 函数就能够在 C 代码中访问：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
#}</code></pre></pre>
<p><code>extern</code> 的使用无需 <code>unsafe</code>。</p>
<!-- PROD: END BOX -->
<a class="header" href="print.html#a访问或修改可变静态变量" id="a访问或修改可变静态变量"><h3>访问或修改可变静态变量</h3></a>
<p>目前为止全书都尽量避免讨论 <strong>全局变量</strong>（<em>global variables</em>），Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的。如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争。</p>
<p>全局变量在 Rust 中被称为 <strong>静态</strong>（<em>static</em>）变量。示例 19-9 展示了一个拥有字符串 slice 值的静态变量的声明和应用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">示例 19-9: 定义和使用一个不可变静态变量</span></p>
<p><code>static</code> 变量类似于第三章 “变量和常量的区别” 部分讨论的常量。通常静态变量的名称采用 <code>SCREAMING_SNAKE_CASE</code> 写法，并 <strong>必须</strong> 标注变量的类型，在这个例子中是 <code>&amp;'static str</code>。静态变量只能储存拥有 <code>'static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。</p>
<p>常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是静态变量中的值有一个固定的内存地址。使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据。</p>
<p>常量与静态变量的另一个区别在于静态变量可以是可变的。访问和修改可变静态变量都是 <strong>不安全</strong> 的。示例 19-10 展示了如何声明、访问和修改名为 <code>COUNTER</code> 的可变静态变量：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">示例 19-10: 读取或修改一个可变静态变量是不安全的</span></p>
<p>就像常规变量一样，我们使用 <code>mut</code> 关键来指定可变性。任何读写 <code>COUNTER</code> 的代码都必须位于 <code>unsafe</code> 块中。这段代码可以编译并如期打印出 <code>COUNTER: 3</code>，因为这是单线程的。拥有多个线程访问 <code>COUNTER</code> 则可能导致数据竞争。</p>
<p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，请优先使用第十六章讨论的并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是安全的。</p>
<a class="header" href="print.html#a实现不安全-trait" id="a实现不安全-trait"><h3>实现不安全 trait</h3></a>
<p>最后一个只能用在 <code>unsafe</code> 中的操作是实现不安全 trait。当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 关键字将 trait 声明为 <code>unsafe</code>，同时 trait 的实现也必须标记为 <code>unsafe</code>，如示例 19-11 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
#}</code></pre></pre>
<p><span class="caption">示例 19-11: 定义并实现不安全 trait</span></p>
<p>通过 <code>unsafe impl</code>，我们承诺将保证编译器所不能验证的不变量。</p>
<p>作为一个例子，回忆第十六章 “使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发” 部分中的 <code>Sync</code> 和 <code>Send</code> 标记 trait，编译器会自动为完全由 <code>Send</code> 和 <code>Sync</code> 类型组成的类型自动实现他们。如果实现了一个包含一些不是 <code>Send</code> 或 <code>Sync</code> 的类型，比如裸指针，并希望将此类型标记为 <code>Send</code> 或 <code>Sync</code>，则必须使用 <code>unsafe</code>。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 <code>unsafe</code> 表明。</p>
<a class="header" href="print.html#a何时使用不安全代码" id="a何时使用不安全代码"><h3>何时使用不安全代码</h3></a>
<p>使用 <code>unsafe</code> 来进行这四个操作之一是没有问题的，甚至是不需要深思熟虑的，不过使得 <code>unsafe</code> 代码正确也实属不易因为编译器不能帮助保证内存安全。当有理由使用 <code>unsafe</code> 代码时，是可以这么做的，通过使用显式的 <code>unsafe</code> 标注使得在出现错误时易于追踪问题的源头。</p>
<a class="header" href="print.html#a高级生命周期" id="a高级生命周期"><h2>高级生命周期</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-02-advanced-lifetimes.md">ch19-02-advanced-lifetimes.md</a>
<br>
commit f7f5e4835c1c4f8ddb502a1dd09a1584ed6f4b6f</p>
</blockquote>
<p>回顾第十章 “生命周期与引用有效性” 部分，我们学习了怎样使用生命周期参数注解引用来帮助 Rust 理解不同引用的生命周期如何相互联系。我们理解了每一个引用都有生命周期，不过大部分情况 Rust 允许我们省略生命周期。这里我们会看到三个还未涉及到的生命周期高级特征：</p>
<ul>
<li>生命周期子类型（lifetime subtyping），一个确保某个生命周期长于另一个生命周期的方式</li>
<li>生命周期 bound（lifetime bounds），用于指定泛型引用的生命周期</li>
<li>trait 对象生命周期（trait object lifetimes），以及他们是如何推断的，以及何时需要指定</li>
</ul>
<!-- maybe add a small summary of each here? That would let us launch straight
into examples in the next section -->
<!-- I've switched to bullets and added a small summary /Carol -->
<a class="header" href="print.html#a生命周期子类型确保某个生命周期长于另一个生命周期" id="a生命周期子类型确保某个生命周期长于另一个生命周期"><h3>生命周期子类型确保某个生命周期长于另一个生命周期</h3></a>
<p>生命周期子类型是一个指定某个生命周期应该长于另一个生命周期的方式。为了探索生命周期子类型，想象一下我们想要编写一个解析器。为此会有一个储存了需要解析的字符串的引用的结构体 <code>Context</code>。解析器将会解析字符串并返回成功或失败。其实现看起来像示例 19-12 中的代码，除了缺少了必须的生命周期注解，所以这还不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">示例 19-12: 定义一个不带生命周期注解的解析器</span></p>
<p>编译代码会导致一个表明 Rust 期望 <code>Context</code> 中字符串 slice 和 <code>Parser</code> 中 <code>Context</code> 的引用的生命周期的错误。</p>
<!-- What will the compile time error be here? I think it'd be worth showing
that to the reader -->
<!-- The errors just say "expected lifetime parameter", they're pretty boring.
We've shown error messages like that before so I've explained in words instead.
/Carol -->
<p>为了简单起见，<code>parse</code> 方法返回 <code>Result&lt;(), &amp;str&gt;</code>。也就是说，成功时不做任何操作，失败时则返回字符串 slice 没有正确解析的部分。真实的实现将会包含比这更多的错误信息，并将会在解析成功时返回实际结果，不过我们将去掉这些部分的实现，因为他们与这个例子的生命周期部分并不相关。</p>
<p>为了保持代码简单，我们不准备实际编写任何解析逻辑。解析逻辑的某处非常有可能通过返回引用输入中无效部分的错误来处理无效输入，而考虑到生命周期，这个引用是使得这个例子有趣的地方。所以我们将假设解析器的逻辑为输入的第一个字节之后是无效的。注意如果第一个字节并不位于一个有效的字符范围内（比如 Unicode）代码将会 panic；这里又一次简化了例子以专注于涉及到的生命周期。</p>
<!-- why do we want to always error after the first byte? -->
<!-- For simplicity of the example to avoid cluttering up the code with actual
parsing logic, which isn't the point. I've explained a bit more above /Carol -->
<p>为了使代码能够编译，我们需要放入 <code>Context</code> 中字符串 slice 和 <code>Parser</code> 中 <code>Context</code> 引用的生命周期参数。最直接的方法是在每处都使用相同的生命周期，如示例 19-13 所示：</p>
<p>那么我们如何为 <code>Context</code> 中的字符串 slice 和 <code>Parser</code> 中 <code>Context</code> 的引用放入生命周期参数呢？最直接的方法是在每处都使用相同的生命周期，如列表 19-13 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 19-13: 将所有 <code>Context</code> 和 <code>Parser</code> 中的引用标注为相同的生命周期参数</span></p>
<p>这次可以编译了，并告诉了 Rust <code>Parser</code> 存放了一个 <code>Context</code> 的引用，拥有生命周期 <code>'a</code>，且 <code>Context</code> 存放了一个字符串 slice，它也与 <code>Parser</code> 中 <code>Context</code> 的引用存在的一样久。Rust 编译器的错误信息表明这些引用需要生命周期参数，现在我们增加了这些生命周期参数。</p>
<!-- can you let the reader know they should be taking away from this previous
example? I'm not totally clear on why adding lifetimes here saved the code -->
<!-- Done -->
<p>接下来，在示例 19-14 中，让我们编写一个获取 <code>Context</code> 的实例，使用 <code>Parser</code> 来解析其内容，并返回 <code>parse</code> 的返回值的函数。这还不能运行：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">示例 19-14: 一个增加获取 <code>Context</code> 并使用 <code>Parser</code> 的函数 <code>parse_context</code> 的尝试</span></p>
<p>当尝试编译这段额外带有 <code>parse_context</code> 函数的代码时会得到两个相当冗长的错误：</p>
<pre><code class="language-text">error[E0597]: borrowed value does not live long enough
  --&gt; src/lib.rs:14:5
   |
14 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
15 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^

error[E0597]: `context` does not live long enough
  --&gt; src/lib.rs:14:24
   |
14 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
15 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^
</code></pre>
<p>这些错误表明我们创建的两个 <code>Parser</code> 实例和 <code>context</code> 参数从 <code>Parser</code> 被创建开始一直存活到 <code>parse_context</code> 函数结束，不过他们都需要在整个函数的生命周期中都有效。</p>
<p>换句话说，<code>Parser</code> 和 <code>context</code> 需要比整个函数 <strong>长寿</strong>（<em>outlive</em>）并在函数开始之前和结束之后都有效以确保代码中的所有引用始终是有效的。虽然我们创建的两个 <code>Parser</code> 和 <code>context</code> 参数在函数的结尾就离开了作用域（因为 <code>parse_context</code> 获取了 <code>context</code> 的所有权）。</p>
<!-- Oh interesting, why do they need to outlive the function, simply to
absolutely ensure they will live for as long as the function? -->
<!-- Yes, which is what I think we've said in the first sentence of the
previous paragraph. Is there something that's unclear? /Carol -->
<p>为了理解为什么会得到这些错误，让我们再次看看示例 19-13 中的定义，特别是 <code>parse</code> 方法的签名中的引用：</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<!-- What exactly is it the reader should be looking at in this signature? -->
<!-- Added above /Carol -->
<p>还记得（生命周期）省略规则吗？如果标注了引用生命周期而不加以省略，签名看起来应该是这样：</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>正是如此，<code>parse</code> 返回值的错误部分的生命周期与 <code>Parser</code> 实例的生命周期（<code>parse</code> 方法签名中的 <code>&amp;self</code>）相绑定。这就可以理解了：因为返回的字符串 slice 引用了 <code>Parser</code> 存放的 <code>Context</code> 实例中的字符串 slice，同时在 <code>Parser</code> 结构体的定义中指定了 <code>Parser</code> 中存放的 <code>Context</code> 引用的生命周期和 <code>Context</code> 中存放的字符串 slice 的生命周期应该一致。</p>
<p>问题是 <code>parse_context</code> 函数返回 <code>parse</code> 的返回值，所以 <code>parse_context</code> 返回值的生命周期也与 <code>Parser</code> 的生命周期相联系。不过 <code>parse_context</code> 函数中创建的 <code>Parser</code> 实例并不能存活到函数结束之后（它是临时的），同时 <code>context</code> 将会在函数的结尾离开作用域（<code>parse_context</code> 获取了它的所有权）。</p>
<p>Rust 认为我们尝试返回一个在函数结尾离开作用域的值，因为我们将所有的生命周期都标注为相同的生命周期参数。这告诉了 Rust <code>Context</code> 中存放的字符串 slice 的生命周期与 <code>Parser</code> 中存放的 <code>Context</code> 引用的生命周期一致。</p>
<p><code>parse_context</code> 函数并不知道 <code>parse</code> 函数里面是什么，返回的字符串 slice 将比 <code>Context</code> 和 <code>Parser</code> 都存活的更久，同时 <code>parse_context</code> 返回的引用指向字符串 slice，而不是 <code>Context</code> 或 <code>Parser</code>。</p>
<p>通过了解 <code>parse</code> 实现所做的工作，可以知道 <code>parse</code> 的返回值（的生命周期）与 <code>Parser</code> 相联系的唯一理由是它引用了 <code>Parser</code> 的 <code>Context</code>，也就是引用了这个字符串 slice，这正是 <code>parse_context</code> 所需要关心的生命周期。需要一个方法来告诉 Rust <code>Context</code> 中的字符串 slice 与 <code>Parser</code> 中 <code>Context</code> 的引用有着不同的生命周期，而且 <code>parse_context</code> 返回值与 <code>Context</code> 中字符串 slice 的生命周期相联系。</p>
<p>首先尝试像示例 19-15 那样给予 <code>Parser</code> 和 <code>Context</code> 不同的生命周期参数。这里选择了生命周期参数名 <code>'s</code> 和 <code>'c</code> 是为了使得 <code>Context</code> 中字符串 slice 与 <code>Parser</code> 中 <code>Context</code> 引用的生命周期显得更明了（英文首字母）。注意这并不能完全解决问题，不过这是一个开始，我们将看看为什么这还不足以能够编译代码。</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">示例 19-15: 为字符串 slice 和 <code>Context</code> 的引用指定不同的生命周期参数</span></p>
<p>这里在与示例 19-13 完全相同的地方标注了引用的生命周期，不过根据引用是字符串 slice 或 <code>Context</code> 与否使用了不同的参数。另外还在 <code>parse</code> 返回值的字符串 slice 部分增加了注解来表明它与 <code>Context</code> 中字符串 slice 的生命周期相关联。</p>
<p>这里是现在尝试编译时得到的错误：</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/lib.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>Rust 并不知道 <code>'c</code> 与 <code>'s</code> 之间的任何联系。为了保证有效性，<code>Context</code> 中引用的带有生命周期 <code>'s</code> 的数据需要遵守它比带有生命周期 <code>'c</code> 的 <code>Context</code> 的引用存活得更久的保证。如果 <code>'s</code> 不比 <code>'c</code> 更长久，那么 <code>Context</code> 的引用可能不再有效。</p>
<p>这就引出了本部分的要点：Rust 的 <strong>生命周期子类型</strong>（<em>lifetime subtyping</em>）功能，这是一个指定一个生命周期不会短于另一个的方法。在声明生命周期参数的尖括号中，可以照常声明一个生命周期 <code>'a</code>，并通过语法 <code>'b: 'a</code> 声明一个不短于 <code>'a</code> 的生命周期 <code>'b</code>。</p>
<p>在 <code>Parser</code> 的定义中，为了表明 <code>'s</code>（字符串 slice 的生命周期）保证至少与 <code>'c</code>（<code>Context</code> 引用的生命周期）一样长，需将生命周期声明改为如此：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
#}</code></pre></pre>
<p>现在 <code>Parser</code> 中 <code>Context</code> 的引用与 <code>Context</code> 中字符串 slice 就有了不同的生命周期，并且保证了字符串 slice 的生命周期比 <code>Context</code> 引用的要长。</p>
<p>这是一个非常冗长的例子，不过正如本章的开头所提到的，这类功能是很小众的。你并不会经常需要这个语法，不过当出现类似这样的情形时，却还是有地方可以参考的。</p>
<a class="header" href="print.html#a生命周期-bound-用于泛型的引用" id="a生命周期-bound-用于泛型的引用"><h3>生命周期 bound 用于泛型的引用</h3></a>
<p>在第十章 “trait bound” 部分，我们讨论了如何在泛型类型上使用 trait bound。也可以像泛型那样为生命周期参数增加限制，这被称为 <strong>生命周期 bound</strong>（<em>lifetime bounds</em>）。生命周期 bound 帮助 Rust 验证泛型的引用不会存在的比其引用的数据更久。</p>
<!-- Can you say up front why/when we use these? -->
<!-- Done -->
<p>例如，考虑一下一个封装了引用的类型。回忆一下第十五章 “<code>RefCell&lt;T&gt;</code> 和内部可变性模式” 部分的 <code>RefCell&lt;T&gt;</code> 类型：其 <code>borrow</code> 和 <code>borrow_mut</code> 方法分别返回 <code>Ref</code> 和 <code>RefMut</code> 类型。这些类型是引用的封装，他们在运行时记录检查借用规则。<code>Ref</code> 结构体的定义如示例 19-16 所示，目前还不带有生命周期 bound：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Ref&lt;'a, T&gt;(&amp;'a T);
</code></pre>
<p><span class="caption">示例 19-16: 定义结构体来封装泛型的引用；开始时没有生命周期约束</span></p>
<p>若不显式限制生命周期 <code>'a</code> 为与泛型参数 <code>T</code> 有关，会得到一个错误因为 Rust 不知道泛型 <code>T</code> 会存活多久：</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>因为 <code>T</code> 可以是任意类型，<code>T</code> 自身也可能是一个引用，或者是一个存放了一个或多个引用的类型，而他们各自可能有着不同的生命周期。Rust 不能确认 <code>T</code> 会与 <code>'a</code> 存活的一样久。</p>
<p>幸运的是，Rust 提供了这个情况下如何指定生命周期 bound 的有用建议：</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at
</code></pre>
<p>示例 19-17 展示了如何按照这个建议，在声明泛型 <code>T</code> 时指定生命周期 bound。。</p>
<p>列表 19-17 展示了按照这个建议，在声明泛型 <code>T</code> 时指定生命周期约束。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
#}</code></pre></pre>
<p><span class="caption">示例 19-17: 为 <code>T</code> 增加生命周期 bound 来指定 <code>T</code> 中的任何引用需至少与 <code>'a</code> 存活的一样久</span></p>
<p>现在代码可以编译了，因为 <code>T: 'a</code> 语法指定了 <code>T</code> 可以为任意类型，不过如果它包含任何引用的话，其生命周期必须至少与 <code>'a</code> 一样长。</p>
<p>我们可以选择不同的方法来解决这个问题，如示例 19-18 中 <code>StaticRef</code> 的结构体定义所示，通过在 <code>T</code> 上增加 <code>'static</code> 生命周期约束。这意味着如果 <code>T</code> 包含任何引用，他们必须有 <code>'static</code> 生命周期：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
#}</code></pre></pre>
<p><span class="caption">示例 19-18: 在 <code>T</code> 上增加 <code>'static</code> 生命周期 bound，来限制 <code>T</code> 为只拥有 <code>'static</code> 生命周期的引用或没有引用的类型</span></p>
<p>因为 <code>'static</code> 意味着引用必须同整个程序存活的一样长，一个不包含引用的类型满足所有引用都与整个程序存活的一样长的标准（因为他们没有引用）。对于借用检查器来说它关心的是引用是否存活的足够久，没有引用的类型与有永远存在的引用的类型并没有真正的区别；对于确定引用是否比其所引用的值存活得较短的目的来说两者是一样的。</p>
<a class="header" href="print.html#trait-对象生命周期的推断" id="trait-对象生命周期的推断"><h3>trait 对象生命周期的推断</h3></a>
<p>在第十七章的 “为使用不同类型的值而设计的 trait 对象” 部分，我们讨论了 trait 对象，它包含一个位于引用之后的 trait，这允许我们进行动态分发。我们所没有讨论的是如果 trait 对象中实现 trait 的类型带有生命周期时会发生什么。考虑一下示例 19-19，其中有 trait <code>Red</code> 和结构体 <code>Ball</code>。<code>Ball</code> 存放了一个引用（因此有一个生命周期参数）并实现了 trait <code>Red</code>。我们希望使用一个作为 trait 对象 <code>Box&lt;Red&gt;</code> 的 <code>Ball</code> 实例：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Red { }

struct Ball&lt;'a&gt; {
    diameter: &amp;'a i32,
}

impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }

fn main() {
    let num = 5;

    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;Red&gt;;
}
</code></pre></pre>
<p><span class="caption">示例 19-19: 使用一个带有生命周期的类型用于 trait 对象</span></p>
<p>这段代码能没有任何错误的编译，即便并没有明确指出 <code>obj</code> 中涉及的任何生命周期。这是因为有如下生命周期与 trait 对象必须遵守的规则：</p>
<ul>
<li>trait 对象的默认生命周期是 <code>'static</code>。</li>
<li>如果有 <code>&amp;'a X</code> 或 <code>&amp;'a mut X</code>，则默认生命周期是 <code>'a</code>。</li>
<li>如果只有 <code>T: 'a</code> 从句， 则默认生命周期是 <code>'a</code>。</li>
<li>如果有多个类似 <code>T: 'a</code> 的从句，则没有默认生命周期；必须明确指定。</li>
</ul>
<p>当必须明确指定时，可以为像 <code>Box&lt;Red&gt;</code> 这样的 trait 对象增加生命周期 bound，根据需要使用语法 <code>Box&lt;Foo + 'a&gt;</code> 或 <code>Box&lt;Foo + 'static&gt;</code>。正如其他的 bound，这意味着任何 <code>Red</code> trait 的实现如果在内部包含有引用, 这些引用就必须拥有与 trait 对象 bound 中所指定的相同的生命周期。</p>
<p>接下来，让我们看看一些其他处理 trait 的高级功能吧！</p>
<a class="header" href="print.html#a高级-trait" id="a高级-trait"><h2>高级 trait</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-03-advanced-traits.md">ch19-03-advanced-traits.md</a>
<br>
commit 9d5b9a573daf5fa0c98b3a3005badcea4a0a5211</p>
</blockquote>
<p>第十章 “trait：定义共享的行为” 部分，我们第一次涉及到了 trait，不过就像生命周期一样，我们并没有覆盖一些较为高级的细节。现在我们更加了解 Rust 了，可以深入理解其本质了。</p>
<a class="header" href="print.html#a关联类型在-trait-定义中指定占位符类型" id="a关联类型在-trait-定义中指定占位符类型"><h3>关联类型在 trait 定义中指定占位符类型</h3></a>
<p><strong>关联类型</strong>（<em>associated types</em>）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么。</p>
<!-- Can you say what this is useful for -- it seems like a way to not to have
to specify a type prior to use, is that right? -->
<!-- Prior to trait implementation, yes. /Carol -->
<p>本章所描述的大部分内容都非常少见。关联类型则比较适中；它们比本书其他的内容要少见，不过比本章中的很多内容要更常见。</p>
<p>一个带有关联类型的 trait 的例子是标准库提供的 <code>Iterator</code> trait。它有一个叫做 <code>Item</code> 的关联类型来替代遍历的值的类型。第十三章的 “<code>Iterator</code> trait 和 <code>next</code> 方法” 部分曾提到过 <code>Iterator</code> trait 的定义如示例 19-20 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p><span class="caption">示例 19-20: <code>Iterator</code> trait 的定义中带有关联类型 <code>Item</code></span></p>
<p><code>Iterator</code> trait 有一个关联类型 <code>Item</code>。<code>Item</code> 是一个占位类型，同时 <code>next</code> 方法会返回 <code>Option&lt;Self::Item&gt;</code> 类型的值。这个 trait 的实现者会指定 <code>Item</code> 的具体类型，然而不管实现者指定何种类型, <code>next</code> 方法都会返回一个包含了此具体类型值的 <code>Option</code>。</p>
<a class="header" href="print.html#a关联类型-vs-泛型" id="a关联类型-vs-泛型"><h4>关联类型 vs 泛型</h4></a>
<p>这可能看起来像一个类似泛型的概念，因为它允许定义一个函数而不指定其可以处理的类型。那么为什么要使用关联类型呢？</p>
<p>让我们通过一个在第十三章中出现的 <code>Counter</code> 结构体上实现 <code>Iterator</code> trait 的例子来检视其中的区别。在示例 13-21 中，指定了 <code>Item</code> 的类型为 <code>u32</code>：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<p>这类似于泛型。那么为什么 <code>Iterator</code> trait 不像示例 19-21 那样定义呢？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<p><span class="caption">示例 19-21: 一个使用泛型的 <code>Iterator</code> trait 假象定义</span></p>
<p>区别在于当如示例 19-21 那样使用泛型时，则不得不在每一个实现中标注类型。这是因为我们也可以实现为 <code>Iterator&lt;String&gt; for Counter</code>，或任何其他类型，这样就可以有多个 <code>Counter</code> 的 <code>Iterator</code> 的实现。换句话说，当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型。接着当使用 <code>Counter</code> 的 <code>next</code> 方法时，必须提供类型注解来表明希望使用 <code>Iterator</code> 的哪一个实现。</p>
<p>通过关联类型，则无需标注类型因为不能多次实现这个 trait。对于示例 19-20，我们只能选择一次 <code>Item</code> 会是什么类型，因为只能有一个 <code>impl Iterator for Counter</code>。当调用 <code>Counter</code> 的 <code>next</code> 时不必每次指定我们需要 <code>u32</code> 值的迭代器。</p>
<a class="header" href="print.html#a默认泛型类型参数和运算符重载" id="a默认泛型类型参数和运算符重载"><h3>默认泛型类型参数和运算符重载</h3></a>
<p>当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时使用 <code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p>
<p>这种情况的一个非常好的例子是用于运算符重载。运算符重载是指在特定情况下自定义运算符（比如 <code>+</code>）行为的操作。</p>
<!-- Are we safe in assuming the reader is familiar with operator overloading
and why/when to use it, or is it worth giving a quick definition here? -->
<!-- Added /Carol -->
<p>Rust 并不允许创建自定义运算符或重载任意运算符，不过 <code>std::ops</code> 中所列出的运算符和相应的 trait <strong>可以</strong> 通过实现运算符相关 trait 来重载。例如，示例 19-22 中展示了如何在 <code>Point</code> 结构体上实现 <code>Add</code> trait 来重载 <code>+</code> 运算符，这样就可以将两个 <code>Point</code> 实例相加了：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">示例 19-22: 实现 <code>Add</code> trait 重载 <code>Point</code> 实例的 <code>+</code> 运算符</span></p>
<p><code>add</code> 方法将两个 <code>Point</code> 实例的 <code>x</code> 值和 <code>y</code> 值分别相加来创建一个新的 <code>Point</code>。<code>Add</code> trait 有一个叫做 <code>Output</code> 的关联类型，它用来决定 <code>add</code> 方法的返回值类型。</p>
<p>这里默认泛型类型位于 <code>Add</code> trait 中。这里是其定义：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<p>这看来应该很熟悉，这是一个带有一个方法和一个关联类型的 trait。比较陌生的部分是尖括号中的 <code>RHS=Self</code>：这个语法叫做 <strong>默认类型参数</strong>（<em>default type parameters</em>）。<code>RHS</code> 是一个泛型类型参数 —— “right hand side” 的缩写 —— 它用于 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add</code> trait 时不指定 <code>RHS</code> 的具体类型，<code>RHS</code> 的类型将是默认的 <code>Self</code> 类型，也就是在其上实现 <code>Add</code> 的类型。</p>
<!-- Can you say what we're looking out for in this next trait -->
<!-- Done/reworked to be less repetitive with the Point example /Carol -->
<p>当为 <code>Point</code> 实现 <code>Add</code> 时，使用了默认的 <code>RHS</code>，因为我们希望将两个 <code>Point</code> 实例相加。让我们看看一个实现 <code>Add</code> trait 时希望自定义 <code>RHS</code> 类型而不是使用默认类型的例子</p>
<p>这里有两个存放不同单元值的结构体，<code>Millimeters</code> 和 <code>Meters</code>。我们希望能够将毫米值与米值相加，并让 <code>Add</code> 的实现正确处理转换。可以为 <code>Millimeters</code> 实现 <code>Add</code> 并以 <code>Meters</code> 作为右手边，如示例 19-23 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 19-23: 在 <code>Millimeters</code> 上实现 <code>Add</code>，以便能够将 <code>Millimeters</code> 与 <code>Meters</code> 相加</span></p>
<p>为了使 <code>Millimeters</code> 和 <code>Meters</code> 能够相加，我们指定 <code>impl Add&lt;Meters&gt;</code> 来设定 <code>RHS</code> 类型参数的值而不是使用默认的 <code>Self</code>。</p>
<p>默认参数类型主要用于如下两个方面：</p>
<ol>
<li>扩展类型而不破坏现有代码。</li>
<li>在大部分用户都不需要的特定情况进行自定义。</li>
</ol>
<!-- Above, in 2., do you mean customization used in corner cases? -->
<!-- Yes, I'm not sure how that's different than what we've stated here or how
it could be clearer /Carol-->
<p>标准库的 <code>Add</code> trait 就是一个第二个目的例子：大部分时候你会将两个相似的类型相加，不过它提供了自定义额外行为的能力。在 <code>Add</code> trait 定义中使用默认类型参数意味着大部分时候无需指定额外的参数。换句话说，一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了。</p>
<p>第一个目的是相似的，但过程是反过来的：如果需要为现有 trait 增加类型参数，为其提供一个默认类型将允许我们在不破坏现有实现代码的基础上扩展 trait 的功能。</p>
<a class="header" href="print.html#a完全限定语法与消歧义调用相同名称的方法" id="a完全限定语法与消歧义调用相同名称的方法"><h3>完全限定语法与消歧义：调用相同名称的方法</h3></a>
<p>Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait。甚至直接在类型上实现开始已经有的同名方法也是可能的！</p>
<!-- Same name as the type, you mean? -->
<!-- No, the same name as methods implemented from traits. I've tried to
clarify /Carol -->
<p>不过，当调用这些同名方法时，需要告诉 Rust 我们希望使用哪一个。考虑一下示例 19-24 中的代码，这里定义了 trait <code>Pilot</code> 和 <code>Wizard</code> 都拥有方法 <code>fly</code>。接着在一个本身已经实现了名为 <code>fly</code> 方法的类型 <code>Human</code> 上实现这两个 trait。每一个 <code>fly</code> 方法都进行了不同的操作：</p>
<p>甚至也可以直接在类型上实现相同名称的方法！那么为了能使用相同的名称调用每一个方法，需要告诉 Rust 我们希望使用哪个方法。考虑一下列表 19-27 中的代码，trait <code>Foo</code> 和 <code>Bar</code> 都拥有方法 <code>f</code>，并在结构体 <code>Baz</code> 上实现了这两个 trait，结构体也有一个叫做 <code>f</code> 的方法：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 19-24: 两个 trait 定义为拥有 <code>fly</code> 方法，并在直接定义有 <code>fly</code> 方法的 <code>Human</code> 类型上实现这两个 trait</span></p>
<p>当调用 <code>Human</code> 实例的 <code>fly</code> 时，编译器默认调用直接是现在类型上的方法，如示例 19-25 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">示例 19-25: 调用 <code>Human</code> 实例的 <code>fly</code></span></p>
<p>运行这段代码会打印出 <code>*waving arms furiously*</code>，这表明 Rust 调用了直接实现在 <code>Human</code> 上的 <code>fly</code> 方法。</p>
<p>为了能够调用 <code>Pilot</code> trait 或 <code>Wizard</code> trait 的 <code>fly</code> 方法，我们需要使用更明显的语法以便能指定我们指的是哪个 <code>fly</code> 方法。这个语法展示在示例 19-26 中：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">示例 19-26: 指定我们希望调用哪一个 trait 的 <code>fly</code> 方法</span></p>
<p>在方法名前指定 trait 名向 Rust 澄清了我们希望调用哪个 <code>fly</code> 实现。也可以选择写成 <code>Human::fly(&amp;person)</code>，这等同于示例 19-26 中的 <code>person.fly()</code>，不过如果无需消歧义的话这么写就有点长了。</p>
<p>运行这段代码会打印出：</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>因为 <code>fly</code> 方法获取一个 <code>self</code> 参数，如果有两个 <strong>类型</strong> 都实现了同一 <strong>trait</strong>，Rust 可以根据 <code>self</code> 的类型计算出应该使用哪一个 trait 实现。</p>
<p>然而，关联函数是 trait 的一部分，但没有 <code>self</code> 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出我们期望的是哪一个类型，除非使用 <strong>完全限定语法</strong>（<em>fully qualified syntax</em>）。例如，拿示例 19-27 中的 <code>Animal</code> trait 来说，它有关联函数 <code>baby_name</code>，结构体 <code>Dog</code> 实现了 <code>Animal</code>，同时有关联函数 <code>baby_name</code> 直接定义于 <code>Dog</code> 之上：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">示例 19-27: 一个带有关联函数的 trait 和一个带有同名关联函数并实现了此 trait 的类型</span></p>
<p>这段代码用于一个动物收容所，他们将所有的小狗起名为 Spot，这实现为定义于 <code>Dog</code> 之上的关联函数 <code>baby_name</code>。<code>Dog</code> 类型还实现了 <code>Animal</code> trait，它描述了所有动物的共有的特征。小狗被称为 puppy，这表现为 <code>Dog</code> 的 <code>Animal</code> trait 实现中与 <code>Animal</code> trait 相关联的函数 <code>baby_name</code>。</p>
<p>在 <code>main</code> 调用了 <code>Dog::baby_name</code> 函数，它直接调用了定义于 <code>Dog</code> 之上的关联函数。这段代码会打印出：</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<p>这并不是我们需要的。我们希望调用的是 <code>Dog</code> 上 <code>Animal</code> trait 实现那部分的 <code>baby_name</code> 函数，这样能够打印出 <code>A baby dog is called a puppy</code>。示例 19-26 中用到的技术在这并不管用；如果将 <code>main</code> 改为示例 19-28 中的代码，则会得到一个编译错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">示例 19-28: 尝试调用 <code>Animal</code> trait 的 <code>baby_name</code> 函数，不过 Rust 并不知道该使用哪一个实现</span></p>
<p>因为 <code>Animal::baby_name</code> 是关联函数而不是方法，因此它没有 <code>self</code> 参数，Rust 无法计算出所需的是哪一个 <code>Animal::baby_name</code> 实现。我们会得到这个编译错误：</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
</code></pre>
<p>为了消歧义并告诉 Rust 我们希望使用的是 <code>Dog</code> 的 <code>Animal</code> 实现，需要使用 <strong>完全限定语法</strong>，这是调用函数时最为明确的方式。示例 19-29 展示了如何使用完全限定语法：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Animal {
#     fn baby_name() -&gt; String;
# }
#
# struct Dog;
#
# impl Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;Spot&quot;)
#     }
# }
#
# impl Animal for Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;puppy&quot;)
#     }
# }
#
fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">示例 19-29: 使用完全限定语法来指定我们希望调用的是 <code>Dog</code> 上 <code>Animal</code> trait 实现中的 <code>baby_name</code> 函数</span></p>
<p>我们在尖括号中向 Rust 提供了类型注解，并通过在此函数调用中将 <code>Dog</code> 类型当作 <code>Animal</code> 对待，来指定希望调用的是 <code>Dog</code> 上 <code>Animal</code> trait 实现中的 <code>baby_name</code> 函数。现在这段代码会打印出我们期望的数据：</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<p>通常，完全限定语法定义为：</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>对于关联函数，其没有一个 <code>receiver</code>，故只会有其他参数的列表。可以选择在任何函数或方法调用处使用完全限定语法。然而，允许省略任何 Rust 能够从程序中的其他信息中计算出的部分。只有当存在多个同名实现而 Rust 需要帮助以便知道我们希望调用哪个实现时，才需要使用这个较为冗长的语法。</p>
<a class="header" href="print.html#a父-trait-用于在另一个-trait-中使用某-trait-的功能" id="a父-trait-用于在另一个-trait-中使用某-trait-的功能"><h3>父 trait 用于在另一个 trait 中使用某 trait 的功能</h3></a>
<p>有时我们可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现。这个所需的 trait 是我们实现的 trait 的 <strong>父（超） trait</strong>（<em>supertrait</em>）。</p>
<p>例如我们希望创建一个带有 <code>outline_print</code> 方法的 trait <code>OutlinePrint</code>，它会打印出带有星号框的值。也就是说，如果 <code>Point</code> 实现了 <code>Display</code> 并返回 <code>(x, y)</code>，调用以 1 作为 <code>x</code> 和 3 作为 <code>y</code> 的 <code>Point</code> 实例的 <code>outline_print</code> 会显示如下：</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>在 <code>outline_print</code> 的实现中，因为希望能够使用 <code>Display</code> trait 的功能，则需要说明 <code>OutlinePrint</code> 只能用于同时也实现了 <code>Display</code> 并提供了 <code>OutlinePrint</code> 需要的功能的类型。可以通过在 trait 定义中指定 <code>OutlinePrint: Display</code> 来做到这一点。这类似于为 trait 增加 trait bound。示例 19-30 展示了一个 <code>OutlinePrint</code> trait 的实现：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 19-30: 实现 <code>OutlinePrint</code> trait，它要求来自 <code>Display</code> 的功能</span></p>
<p>因为指定了 <code>OutlinePrint</code> 需要 <code>Display</code> trait，则可以在 <code>outline_print</code> 中使用 <code>to_string</code>， 其会为任何实现 <code>Display</code> 的类型自动实现。如果不在 trait 名后增加 <code>: Display</code> 并尝试在 <code>outline_print</code> 中使用 <code>to_string</code>，则会得到一个错误说在当前作用域中没有找到用于 <code>&amp;Self</code> 类型的方法 <code>to_string</code>。</p>
<p>让我们看看如果尝试在一个没有实现 <code>Display</code> 的类型上实现 <code>OutlinePrint</code> 会发生什么，比如 <code>Point</code> 结构体：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<p>这样会得到一个错误说 <code>Display</code> 是必须的而未被实现：</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
   try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<p>一旦在 <code>Point</code> 上实现 <code>Display</code> 并满足 <code>OutlinePrint</code> 要求的限制，比如这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<p>那么在 <code>Point</code> 上实现 <code>OutlinePrint</code> trait 将能成功编译并可以在 <code>Point</code> 实例上调用 <code>outline_print</code> 来显示位于星号框中的点的值。</p>
<a class="header" href="print.html#newtype-模式用以在外部类型上实现外部-trait" id="newtype-模式用以在外部类型上实现外部-trait"><h3>newtype 模式用以在外部类型上实现外部 trait</h3></a>
<p>在第十章的 “为类型实现 trait” 部分，我们提到了孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。一个绕开这个限制的方法是使用<strong>newtype 模式</strong>（<em>newtype pattern</em>），它涉及到在一个元组结构体（第五章 “用没有命名字段的元组结构体来创建不同的类型” 部分介绍了元组结构体）中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait。“Newtype” 是一个源自（U.C.0079，逃）Haskell 编程语言的概念。使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。</p>
<p>例如，如果想要在 <code>Vec</code> 上实现 <code>Display</code>，而孤儿规则阻止我们直接这么做，因为 <code>Display</code> trait 和 <code>Vec</code> 都定义于我们的 crate 之外。可以创建一个包含 <code>Vec</code> 实例的 <code>Wrapper</code> 结构体，接着可以如列表 19-31 那样在 <code>Wrapper</code> 上实现 <code>Display</code> 并使用 <code>Vec</code> 的值：</p>
<p>可以创建一个包含 <code>Vec</code> 实例的 <code>Wrapper</code> 结构体。接着可以如列表 19-30 那样在 <code>Wrapper</code> 上实现 <code>Display</code> 并使用 <code>Vec</code> 的值：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">示例 19-31: 创建 <code>Wrapper</code> 类型封装 <code>Vec&lt;String&gt;</code> 以便能够实现 <code>Display</code></span></p>
<p><code>Display</code> 的实现使用 <code>self.0</code> 来访问其内部的 <code>Vec</code>，因为 <code>Wrapper</code> 是元组结构体而 <code>Vec</code> 是结构体总位于索引 0 的项。接着就可以使用 <code>Wrapper</code> 中 <code>Display</code> 的功能了。</p>
<!-- What is self.0? I think the syntax here might need a bit more talking
through -->
<!-- `Wrapper` is a tuple struct; we covered those in chapter 5, added a back
reference to that section in the first paragraph of this section but we've used
the `.0` syntax in multiple places before here /Carol -->
<p>此方法的缺点是，因为 <code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法；必须直接在 <code>Wrapper</code> 上实现 <code>Vec</code> 的所有方法，这样就可以代理到<code>self.0</code> 上 —— 这就允许我们完全像 <code>Vec</code> 那样对待 <code>Wrapper</code>。如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 <code>Deref</code> trait（第十五章 “通过 <code>Deref</code> trait 将智能指针当作常规引用处理” 部分讨论过）并返回其内部类型是一种解决方案。如果不希望封装类型拥有所有内部类型的方法，比如为了限制封装类型的行为，则必须只自行实现所需的方法。</p>
<p>上面便是 newtype 模式如何与 trait 结合使用的；还有一个不涉及 trait 的实用模式。现在让我们将话题的焦点转移到一些与 Rust 类型系统交互的高级方法上来吧。</p>
<a class="header" href="print.html#a高级类型" id="a高级类型"><h2>高级类型</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-04-advanced-types.md">ch19-04-advanced-types.md</a>
<br>
commit 9d5b9a573daf5fa0c98b3a3005badcea4a0a5211</p>
</blockquote>
<p>Rust 的类型系统有一些我们曾经提到但没有讨论过的功能。首先我们从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始。接着会转向类型别名（type aliases），一个类似于 newtype 但有着稍微不同的语义的功能。我们还会讨论 <code>!</code> 类型和动态大小类型。</p>
<a class="header" href="print.html#a为了类型安全和抽象而使用-newtype-模式" id="a为了类型安全和抽象而使用-newtype-模式"><h3>为了类型安全和抽象而使用 newtype 模式</h3></a>
<blockquote>
<p>这一部分假设你已经阅读了 “高级 trait” 部分的 newtype 模式相关内容。</p>
</blockquote>
<p>newtype 模式可以用于一些其他我们还未讨论的功能，包括静态的确保某值不被混淆，和用来表示一个值的单元。实际上示例 19-23 中已经有一个这样的例子：<code>Millimeters</code> 和 <code>Meters</code> 结构体都在 newtype 中封装了 <code>u32</code> 值。如果编写了一个有 <code>Millimeters</code> 类型参数的函数，不小心使用 <code>Meters</code> 或普通的 <code>u32</code> 值来调用该函数的程序是不能编译的。</p>
<p>另一个 newtype 模式的应用在于抽象掉一些类型的实现细节：例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的 API，以便限制其功能。</p>
<p>newtype 也可以隐藏其内部的泛型类型。例如，可以提供一个封装了 <code>HashMap&lt;i32, String&gt;</code> 的 <code>People</code> 类型，用来储存人名以及相应的 ID。使用 <code>People</code> 的代码只需与提供的公有 API 交互即可，比如向 <code>People</code> 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 <code>i32</code> ID 赋予了这个名字了。newtype 模式是一种实现第十七章 “封装隐藏了实现细节” 部分所讨论的隐藏实现细节的封装的轻量级方法。</p>
<a class="header" href="print.html#a类型别名用来创建类型同义词" id="a类型别名用来创建类型同义词"><h3>类型别名用来创建类型同义词</h3></a>
<p>连同 newtype 模式，Rust 还提供了声明 <strong>类型别名</strong>（<em>type alias</em>）的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;
#}</code></pre></pre>
<p>这意味着 <code>Kilometers</code> 是 <code>i32</code> 的 <strong>同义词</strong>（<em>synonym</em>）；不同于示例 19-23 中创建的 <code>Millimeters</code> 和 <code>Meters</code> 类型。<code>Kilometers</code> 不是一个新的、单独的类型。<code>Kilometers</code> 类型的值将被完全当作 <code>i32</code> 类型值来对待：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
#}</code></pre></pre>
<p>因为 <code>Kilometers</code> 是 <code>i32</code> 的别名，他们是同一类型，可以将 <code>i32</code> 与 <code>Kilometers</code> 相加，也可以将 <code>Kilometers</code> 传递给获取 <code>i32</code> 参数的函数。但通过这种手段无法获得上一部分讨论的 newtype 模式所提供的类型检查的好处。</p>
<p>类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<p>在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。想象一下如示例 19-32 这样全是如此代码的项目：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">示例 19-32: 在很多地方使用名称很长的类型</span></p>
<p>类型别名通过减少项目中重复代码的数量来使其更加易于控制。这里我们为这个冗长的类型引入了一个叫做 <code>Thunk</code> 的别名，这样就可以如示例 19-33 所示将所有使用这个类型的地方替换为更短的 <code>Thunk</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">示例 19-33: 引入类型别名 <code>Thunk</code> 来减少重复</span></p>
<p>这样就读写起来就容易多了！为类型别名选择一个好名字也可以帮助你表达意图（单词 <em>thunk</em> 表示会在之后被计算的代码，所以这是一个存放闭包的合适的名字）。</p>
<p>类型别名也经常与 <code>Result&lt;T, E&gt;</code> 结合使用来减少重复。考虑一下标准库中的 <code>std::io</code> 模块。I/O 操作通常会返回一个 <code>Result&lt;T, E&gt;</code>，因为这些操作可能会失败。标准库中的 <code>std::io::Error</code> 结构体代表了所有可能的 I/O 错误。<code>std::io</code> 中大部分函数会返回 <code>Result&lt;T, E&gt;</code>，其中 <code>E</code> 是 <code>std::io::Error</code>，比如 <code>Write</code> trait 中的这些函数：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
#}</code></pre></pre>
<p>这里出现了很多的 <code>Result&lt;..., Error&gt;</code>。为此，<code>std::io</code> 有这个类型别名声明：</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>因为这位于 <code>std::io</code> 中，可用的完全限定的别名是 <code>std::io::Result&lt;T&gt;</code>；也就是说，<code>Result&lt;T, E&gt;</code> 中 <code>E</code> 放入了 <code>std::io::Error</code>。<code>Write</code> trait 中的函数最终看起来像这样：</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>类型别名在两个方面有帮助：易于编写 <strong>并</strong> 在整个 <code>std::io</code> 中提供了一致的接口。因为这是一个别名，它只是另一个 <code>Result&lt;T, E&gt;</code>，这意味着可以在其上使用 <code>Result&lt;T, E&gt;</code> 的任何方法，以及像 <code>?</code> 这样的特殊语法。</p>
<a class="header" href="print.html#a从不返回的-never-type" id="a从不返回的-never-type"><h3>从不返回的 <code>!</code>，never type</h3></a>
<p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <em>empty type</em>，因为它没有值。我们更倾向于称之为 <em>never type</em>。这个名字描述了它的作用：在函数从不返回的时候充当返回值。例如：</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<p>这读 “函数 <code>bar</code> 从不返回”，而从不返回的函数被称为 <strong>发散函数</strong>（<em>diverging functions</em>）。不能创建 <code>!</code> 类型的值，所以 <code>bar</code> 也不可能返回。</p>
<p>不过一个不能创建值的类型有什么用呢？如果你回想一下第二章，曾经有一些看起来像这样的代码，如示例 19-34 所重现的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }
#}</code></pre></pre>
<p><span class="caption">示例 19-34: <code>match</code> 语句和一个以 <code>continue</code> 结束的分支</span></p>
<p>当时我们忽略了代码中的一些细节。在第六章 “<code>match</code> 控制流运算符” 部分，我们学习了 <code>match</code> 的分支必须返回相同的类型。如下代码不能工作：</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse()  {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>这里的 <code>guess</code> 必须既是整型也是字符串，而 Rust 要求 <code>guess</code> 只能是一个类型。那么 <code>continue</code> 返回了什么呢？为什么示例 19-34 中会允许一个分支返回 <code>u32</code> 而另一个分支却以 <code>continue</code> 结束呢？</p>
<p>正如你可能猜到的，<code>continue</code> 的值是 <code>!</code>。也就是说，当 Rust 要计算 <code>guess</code> 的类型时，它查看这两个分支。前者是 <code>u32</code> 值，而后者是 <code>!</code> 值。因为 <code>!</code> 并没有一个值，Rust 决定 <code>guess</code> 的类型是 <code>u32</code>。</p>
<p>描述 <code>!</code> 的行为的正式方式是 never type 可以强转为任何其他类型。允许 <code>match</code> 的分支以 <code>continue</code> 结束是因为 <code>continue</code> 并不真正返回一个值；相反它把控制权交回上层循环，所以在 <code>Err</code> 的情况，事实上并未对 <code>guess</code> 赋值。</p>
<!-- I'm not sure I'm following what would then occur in the event of an error,
literally nothing? -->
<!-- The block returns control to the enclosing loop; I'm not sure how to
clarify this other than what we already have here, do you have any suggestions?
I wouldn't say it's "literally nothing" because it does do something, it
returns control to the loop and the next iteration of the loop happens...
/Carol -->
<p>never type 的另一个用途是 <code>panic!</code>。还记得 <code>Option&lt;T&gt;</code> 上的 <code>unwrap</code> 函数吗？它产生一个值或 panic。这里是它的定义：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>这里与示例 19-34 中的 <code>match</code> 发生了相同的情况：我们知道 <code>val</code> 是 <code>T</code> 类型，<code>panic!</code> 是 <code>!</code> 类型，所以整个 <code>match</code> 表达式的结果是 <code>T</code> 类型。这能工作是因为 <code>panic!</code> 并不产生一个值；它会终止程序。对于 <code>None</code> 的情况，<code>unwrap</code> 并不返回一个值，所以这些代码是有效。</p>
<p>最后一个有着 <code>!</code> 类型的表达式是 <code>loop</code>：</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>这里，循环永远也不结束，所以此表达式的值是 <code>!</code>。但是如果引入 <code>break</code> 这就不为真了，因为循环在执行到 <code>break</code> 后就会终止。</p>
<a class="header" href="print.html#a动态大小类型和-sized-trait" id="a动态大小类型和-sized-trait"><h3>动态大小类型和 <code>Sized</code> trait</h3></a>
<p>因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 <strong>动态大小类型</strong>（<em>dynamically sized types</em>）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。</p>
<p>让我们深入研究一个贯穿本书都在使用的动态大小类型的细节：<code>str</code>。没错，不是 <code>&amp;str</code>，而是 <code>str</code> 本身。<code>str</code> 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着不能创建 <code>str</code> 类型的变量，也不能获取 <code>str</code> 类型的参数。考虑一下这些代码，他们不能工作：</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<!-- Why do they need to have the same memory layout? Perhaps I'm not
understanding fully what is meant by the memory layout, is it worth explaining
that a little in this section? -->
<!-- I've reworded /Carol -->
<p>Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 <code>str</code> 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。</p>
<p>那么该怎么办呢？你已经知道了这种问题的答案：<code>s1</code> 和 <code>s2</code> 的类型是 <code>&amp;str</code> 而不是 <code>str</code>。如果你回想第四章 “字符串 slice” 部分，slice 数据结储存了开始位置和 slice 的长度。</p>
<p>所以虽然 <code>&amp;T</code> 是一个储存了 <code>T</code> 所在的内存位置的单个值，<code>&amp;str</code> 则是 <strong>两个</strong> 值：<code>str</code> 的地址和其长度。这样，<code>&amp;str</code> 就有了一个在编译时可以知道的大小：它是 <code>usize</code> 长度的两倍。也就是说，我们总是知道 <code>&amp;str</code> 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。</p>
<p>可以将 <code>str</code> 与所有类型的指针结合：比如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。事实上，之前我们已经见过了，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。在第十七章 “为使用不同类型的值而设计的 trait 对象” 部分，我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 <code>&amp;Trait</code> 或 <code>Box&lt;Trait&gt;</code>（<code>Rc&lt;Trait&gt;</code> 也可以）。trait 之所以是动态大小类型的是因为只有这样才能使用它。</p>
<a class="header" href="print.html#sized-trait" id="sized-trait"><h4><code>Sized</code> trait</h4></a>
<!-- If we end up keeping the section on object safety in ch 17, we should add
a back reference here. /Carol -->
<!-- I think we dropped that one, right? -->
<!-- We cut a large portion of it, including the part about `Sized`, so I
didn't add a back reference. /Carol -->
<p>为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 <code>Sized</code> trait。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 <code>Sized</code> bound。也就是说，对于如下泛型函数定义：</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>实际上被当作如下处理：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p><code>?Sized</code> trait bound 与 <code>Sized</code> 相对；也就是说，它可以读作 “<code>T</code> 可能是也可能不是 <code>Sized</code> 的”。这个语法只能用于 <code>Sized</code> ，而不能用于其他 trait。</p>
<p>另外注意我们将 <code>t</code> 参数的类型从 <code>T</code> 变为了 <code>&amp;T</code>：因为其类型可能不是 <code>Sized</code> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p>
<p>接下来，让我们讨论一下函数和闭包！</p>
<a class="header" href="print.html#a高级函数与闭包" id="a高级函数与闭包"><h2>高级函数与闭包</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-05-advanced-functions-and-closures.md">ch19-05-advanced-functions-and-closures.md</a>
<br>
commit 9d5b9a573daf5fa0c98b3a3005badcea4a0a5211</p>
</blockquote>
<p>最后让我们讨论一些有关函数和闭包的高级功能：函数指针、发散函数和返回值闭包。</p>
<a class="header" href="print.html#a函数指针" id="a函数指针"><h3>函数指针</h3></a>
<!-- Maybe give an example of when we'd want to use this? -->
<!-- Added a short sentence, but we discuss interfacing with languages that
don't have closures below, which I don't think makes sense until we define how
function pointers are different than closures... /Carol -->
<p>我们讨论过了如何向函数传递闭包；也可以向函数传递常规函数！这在我们希望传递已经定义的函数而不是重新定义闭包作为参数是很有用。通过函数指针允许我们使用函数作为另一个函数的参数。函数的类型是 <code>fn</code>，使用小写的 “f” 以便不与 <code>Fn</code> 闭包 trait 向混淆。<code>fn</code> 被称为<strong>函数指针</strong>（<em>function pointer</em>）。指定参数为函数指针的语法类似于闭包，如示例 19-34 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">示例 19-35: 使用 <code>fn</code> 类型接受函数指针作为参数</span></p>
<p>这会打印出 <code>The answer is: 12</code>。<code>do_twice</code> 中的 <code>f</code> 被指定为一个接受一个 <code>i32</code> 参数并返回 <code>i32</code> 的 <code>fn</code>。接着就可以在 <code>do_twice</code> 函数体中调用 <code>f</code>。在  <code>main</code> 中，可以将函数名 <code>add_one</code> 作为第一个参数传递给 <code>do_twice</code>。</p>
<p>不同于闭包，<code>fn</code> 是一个类型而不是一个 trait，所以直接指定 <code>fn</code> 作为参数而不是声明一个带有 <code>Fn</code> 作为 trait bound 的泛型参数。</p>
<p>函数指针实现了所有三个闭包 trait（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 trait 的函数，这样它就能接受函数或闭包作为参数。</p>
<p>一个只期望接受 <code>fn</code> 而不接受闭包的情况的例子是与不存在闭包的外部代码交互时：C 语言的函数可以接受函数作为参数，但没有闭包。</p>
<p>作为一个既可以使用内联定义的闭包又可以使用命名函数的例子，让我们看看一个 <code>map</code> 的应用。使用 <code>map</code> 函数将一个数字 vector 转换为一个字符串 vector，就可以使用闭包：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
#}</code></pre></pre>
<p>或者可以将函数作为 <code>map</code> 的参数来代替闭包：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
#}</code></pre></pre>
<p>注意这里必须使用 “高级 trait” 部分讲到的完全限定语法，因为存在多个叫做 <code>to_string</code> 的函数；这里使用了定义于 <code>ToString</code> trait 的 <code>to_string</code> 函数，标准库为所有实现了 <code>Display</code> 的类型实现了这个 trait。</p>
<p>一些人倾向于函数风格，一些人喜欢闭包。他们最终都会产生同样的代码，所以请使用对你来说更明白的吧。</p>
<a class="header" href="print.html#a返回闭包" id="a返回闭包"><h3>返回闭包</h3></a>
<p>闭包表现为 trait，这意味着不能直接返回闭包。对于大部分需要返回 trait 的情况，可以使用是实现了期望返回的 trait 的具体类型替代函数的返回值。但是这不能用于闭包，因为他们没有一个可返回的具体类型；例如不允许使用函数指针 <code>fn</code> 作为返回值类型。</p>
<p>这段代码尝试直接返回闭包，它并不能编译：</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>编译器给出的错误是：</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<p>错误有一次指向了 <code>Sized</code> trait！Rust 并不知道需要多少空间来储存闭包。不过我们在上一部分见过这种情况的解决办法：可以使用 trait 对象：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<p>这段代码正好可以编译。关于 trait 对象的更多内容，请回顾第十七章的 “trait 对象” 部分。</p>
<a class="header" href="print.html#a总结-18" id="a总结-18"><h2>总结</h2></a>
<p>好的！现在我们学习了 Rust 并不常用但在特定情况下你可能用得着的功能。我们介绍了很多复杂的主题，这样若你在错误信息提示或阅读他人代码时遇到他们，至少可以说之前已经见过这些概念和语法了。你可以使用本章作为一个解决方案的参考。</p>
<p>现在，让我们再开始一个项目，将本书所学的所有内容付与实践！</p>
<a class="header" href="print.html#a最后的项目-构建多线程-web-server" id="a最后的项目-构建多线程-web-server"><h1>最后的项目: 构建多线程 web server</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch20-00-final-project-a-web-server.md">ch20-00-final-project-a-web-server.md</a>
<br>
commit e2a38b44f3a7f796fa8000e558dc8dd2ddf340a3</p>
</blockquote>
<p>这是一次漫长的旅途，不过我们做到了！这一章便是本书的结束。离别是如此甜蜜的悲伤。不过在我们结束之前，再来一起构建另一个项目，来展示最后几章所学，同时复习更早的章节。</p>
<p>作为最后的项目，我们将要实现一个只返回 “hello” 的 web server；它在浏览器中看起来就如图例 20-1 所示：</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">图例 20-1: 我们最好将一起分享的项目</span></p>
<p>如下是我们将怎样构建此 web server 的计划：</p>
<ol>
<li>学习一些 TCP 与 HTTP 知识</li>
<li>在套接字（socket）上监听 TCP 请求</li>
<li>解析少量的 HTTP 请求</li>
<li>创建一个合适的 HTTP 响应</li>
<li>通过线程池改善 server 的吞吐量</li>
</ol>
<p>不过在开始之前，需要提到一点：这里使用的方法并不是使用 Rust 构建 web server 最好的方法。<em>https://crates.io</em> 上有很多可用于生产环境的 crate，它们提供了比我们所要编写的更为完整的 web server 和线程池实现。</p>
<p>然而，本章的目的在于学习，而不是走捷径。因为 Rust 是一个系统编程语言，我们能够选择处理什么层次的抽象，并能够选择比其他语言可能或可用的层次更低的层次。因此我们将自己编写一个基础的 HTTP server 和线程池，以便学习将来可能用到的 crate 背后的通用理念和技术。</p>
<a class="header" href="print.html#a构建单线程-web-server" id="a构建单线程-web-server"><h2>构建单线程 web server</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch20-01-single-threaded.md">ch20-01-single-threaded.md</a>
<br>
commit 90e6737d534cb66102674d183d2ef1966b190c2c</p>
</blockquote>
<p>首先让我们创建一个可运行的单线程 web server，不过在开始之前，我们将快速了解一下构建 web server 所涉及到的协议。这些协议的细节超出了本书的范畴，不过一个简单的概括会提供你所需的信息。</p>
<p>web server 中涉及到的两个主要协议是 <strong>超文本传输协议</strong>（<em>Hypertext Transfer Protocol</em>，<em>HTTP</em>）和 <strong>传输控制协议</strong>（<em>Transmission Control Protocol</em>，<em>TCP</em>）。这两者都是 <strong>请求-响应</strong>（<em>request-response</em>）协议，也就是说，有 <strong>客户端</strong>（<em>client</em>）来初始化请求，并有 <strong>服务端</strong>（<em>server</em>）监听请求并向客户端提供响应。请求与响应的内容由协议本身定义。</p>
<p>TCP 是一个底层协议，它描述了信息如何从一个 server 到另一个的细节，不过其并不指定信息是什么。HTTP 构建于 TCP 之上，它定义了请求和响应的内容。为此，技术上讲可将 HTTP 用于其他协议之上，不过对于绝大部分情况，HTTP 通过 TCP 传输。我们将要做的就是处理 TCP 和 HTTP 请求与响应的原始字节数据。</p>
<a class="header" href="print.html#a监听-tcp-连接" id="a监听-tcp-连接"><h3>监听 TCP 连接</h3></a>
<p>所以我们的 web server 所需做的第一件事便是能够监听 TCP 连接。标准库提供了 <code>std::net</code> 模块处理这些功能。让我们一如既往新建一个项目：</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>并在 <code>src/main.rs</code> 输入示例 20-1 中的代码作为开始。这段代码会在地址 <code>127.0.0.1:7878</code> 上监听传入的 TCP 流。当获取到传入的流，它会打印出 <code>Connection established!</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">示例 20-1: 监听传入的流并在接收到流时打印信息</span></p>
<p><code>TcpListener</code> 用于监听 TCP 连接。我们选择监听地址 <code>127.0.0.1:7878</code>。将这个地址拆开，冒号之前的部分是一个代表本机的 IP 地址（这个地址在每台计算机上都相同，并不特指作者的计算机），而 <code>7878</code> 是端口。选择这个端口出于两个原因：通常 HTTP 接受这个端口而且 7878 在电话上打出来就是 &quot;rust&quot;（译者注：九宫格键盘上的英文）。注意连接 80 端口需要管理员权限；非管理员用户只能监听大于 1024 的端口。</p>
<p>在这个场景中 <code>bind</code> 函数类似于 <code>new</code> 函数，在这里它返回一个新的 <code>TcpListener</code> 实例。这个函数叫做 <code>bind</code> 是因为，在网络领域，连接到监听端口被称为 “绑定到一个端口”（“binding to a port”）</p>
<p><code>bind</code> 函数返回 <code>Result&lt;T, E&gt;</code>，这表明绑定可能会失败，例如，如果不是管理员尝试连接 80 端口，或是如果运行两个此程序的实例这样会有两个程序监听相同的端口，绑定会失败。因为我们是出于学习目的来编写一个基础的 server，将不用关心处理这类错误，使用 <code>unwrap</code> 在出现这些情况时直接停止程序。</p>
<p><code>TcpListener</code> 的 <code>incoming</code> 方法返回一个迭代器，它提供了一系列的流（更准确的说是 <code>TcpStream</code> 类型的流）。<strong>流</strong>（<em>stream</em>）代表一个客户端和服务端之间打开的连接。<strong>连接</strong>（<em>connection</em>）代表客户端连接服务端、服务端生成响应以及服务端关闭连接的全部请求 / 响应过程。为此，<code>TcpStream</code> 允许我们读取它来查看客户端发送了什么，并可以编写响应。总体来说，这个 <code>for</code> 循环会依次处理每个连接并产生一系列的流供我们处理。</p>
<!-- Below -- What if there aren't errors, how is the stream handled? Or is
there no functionality for that yet, only functionality for errors?
Also, highlighted below -- can you specify what errors we're talking
about---errors in *producing* the streams or connecting to the port?-->
<!--
There is no functionality for a stream without errors yet; I've clarified.
The errors happen when a client attempts to connect to the server; I've
clarified.
/Carol -->
<p>目前为止，处理流的过程包含 <code>unwrap</code> 调用，如果出现任何错误会终止程序，如果没有任何错误，则打印出信息。下一个示例我们将为成功的情况增加更多功能。当客户端连接到服务端时 <code>incoming</code> 方法返回错误是可能的，因为我们实际上没有遍历连接，而是遍历 <strong>连接尝试</strong>（<em>connection attempts</em>）。连接可能会因为很多原因不能成功，大部分是操作系统相关的。例如，很多系统限制同时打开的连接数；新连接尝试产生错误，直到一些打开的连接关闭为止。</p>
<p>让我们试试这段代码！首先在终端执行 <code>cargo run</code>，接着在浏览器中加载 <code>127.0.0.1:7878</code>。浏览器会显示出看起来类似于“连接重置”（“Connection reset”）的错误信息，因为 server 目前并没响应任何数据。但是如果我们观察终端，会发现当浏览器连接 server 时会打印出一系列的信息！</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>有时会看到对于一次浏览器请求会打印出多条信息；这可能是因为浏览器在请求页面的同时还请求了其他资源，比如出现在浏览器 tab 标签中的 <code>favicon.ico</code>。</p>
<p>这也可能是因为浏览器尝试多次连接 server，因为 server 没有响应任何数据。当 <code>stream</code> 在循环的结尾离开作用域并被丢弃，其连接将被关闭，作为 <code>drop</code> 实现的一部分。浏览器有时通过重连来处理关闭的连接，因为这些问题可能是暂时的。现在重要的是我们成功的处理了 TCP 连接！</p>
<p>记得当运行完特定版本的代码后使用 <span class="keystroke">ctrl-C</span> 来停止程序，并在做出最新的代码修改之后执行 <code>cargo run</code> 重启服务。</p>
<a class="header" href="print.html#a读取请求" id="a读取请求"><h3>读取请求</h3></a>
<p>让我们实现读取来自浏览器请求的功能！为了分离获取连接和接下来对连接的操作的相关内容，我们将开始一个新函数来处理连接。在这个新的 <code>handle_connection</code> 函数中，我们从 TCP 流中读取数据并打印出来以便观察浏览器发送过来的数据。将代码修改为如示例 20-2 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">示例 20-2: 读取 <code>TcpStream</code> 并打印数据</span></p>
<p>这里将 <code>std::io::prelude</code> 引入作用域来获取读写流所需的特定 trait。在 <code>main</code> 函数的 <code>for</code> 循环中，相比获取到连接时打印信息，现在调用新的 <code>handle_connection</code> 函数并向其传递 <code>stream</code>。</p>
<p>在 <code>handle_connection</code> 中，<code>stream</code> 参数是可变的。</p>
<p>我们将从流中读取数据，所以它需要是可修改的。这是因为 <code>TcpStream</code> 实例在内部记录了所返回的数据。它可能读取了多于我们请求的数据并保存它们以备下一次请求数据。因此它需要是 <code>mut</code> 的因为其内部状态可能会改变；通常我们认为 “读取” 不需要可变性，不过在这个例子中则需要 <code>mut</code> 关键字。</p>
<!-- Above -- I'm not clear what state will change here, the content of stream
when the program tempers what data it takes? -->
<!-- Yes, which is what we mean by "internally". I've tried to reword a bit,
not sure if it's clearer. /Carol -->
<p>接下来，需要实际读取流。这里分两步进行：首先，在栈上声明一个 <code>buffer</code> 来存放读取到的数据。这里创建了一个 512 字节的缓冲区，它足以存放基本请求的数据并满足本章的目的需要。如果希望处理任意大小的请求，缓冲区管理将更为复杂，不过现在一切从简。接着将缓冲区传递给 <code>stream.read</code> ，它会从 <code>TcpStream</code> 中读取字节并放入缓冲区中。</p>
<p>接下来将缓冲区中的字节转换为字符串并打印出来。<code>String::from_utf8_lossy</code> 函数获取一个 <code>&amp;[u8]</code> 并产生一个 <code>String</code>。函数名的 “lossy” 部分来源于当其遇到无效的 UTF-8 序列时的行为：它使用  �，<code>U+FFFD REPLACEMENT CHARACTER</code>，来代替无效序列。你可能会在缓冲区的剩余部分看到这些替代字符，因为他们没有被请求数据填满。</p>
<p>让我们试一试！启动程序并再次在浏览器中发起请求。注意浏览器中仍然会出现错误页面，不过终端中程序的输出现在看起来像这样：</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>根据使用的浏览器不同可能会出现稍微不同的数据。现在我们打印出了请求数据，可以通过观察 <code>Request: GET</code> 之后的路径来解释为何会从浏览器得到多个连接。如果重复的连接都是请求 <code>/</code>，就知道了浏览器尝试重复获取 <code>/</code> 因为它没有从程序得到响应。</p>
<p>拆开请求数据来理解浏览器向程序请求了什么。</p>
<a class="header" href="print.html#a仔细观察-http-请求" id="a仔细观察-http-请求"><h4>仔细观察 hTTP 请求</h4></a>
<p>HTTP 是一个基于文本的协议，同时一个请求有如下格式：</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>第一行叫做 <strong>请求行</strong>（<em>request line</em>），它存放了客户端请求了什么的信息。请求行的第一部分是所使用的 <em>method</em>，比如 <code>GET</code> 或 <code>POST</code>，这描述了客户端如何进行请求。这里客户端使用了 <code>GET</code> 请求。</p>
<!-- Below, is that right that the / part is the URI *being requested*, and not
the URI of the requester? -->
<!-- Yes /Carol -->
<p><code>Request</code> 行接下来的部分是 <code>/</code>，它代表客户端请求的 <strong>统一资源标识符</strong>（<em>Uniform Resource Identifier</em>，<em>URI</em>） —— URI 大体上类似，但也不完全类似于 URL（<strong>统一资源定位符</strong>，<em>Uniform Resource Locators</em>）。URI 和 URL 之间的区别对于本章的目的来说并不重要，不过 HTTP 规范使用术语 URI，所以这里可以简单的将 URL 理解为 URI。</p>
<p>最后，是客户端使用的 HTTP 版本，接着请求行以一个 CRLF 序列结尾。CRLF 序列也可以写作 <code>\r\n</code>：<code>\r</code> 是 <strong>回车</strong>（<em>carriage return</em>）而 <code>\n</code> 是 <strong>换行</strong>（<em>line feed</em>）（这些术语来自打字机时代！）。注意当 CRLF 被打印时，会看到开始了一个新行而不是 <code>\r\n</code>。</p>
<!-- Above, I don't see a CRLF here in the request line in the actual output,
is it just implied because the next line begins on the next line? -->
<!-- Yes, I've clarified. /Carol -->
<p>观察目前运行程序所接收到的数据的请求行，可以看到 <code>GET</code> 是 method，<code>/</code> 是请求 URI，而 <code>HTTP/1.1</code> 是版本。</p>
<p>从 <code>Host:</code> 开始的其余的行是 headers；<code>GET</code> 请求没有 body。</p>
<p>如果你希望的话，尝试用不同的浏览器发送请求，或请求不同的地址，比如 <code>127.0.0.1:7878/test</code>，来观察请求数据如何变化。</p>
<p>现在我们知道了浏览器请求了什么。让我们返回一些数据！</p>
<a class="header" href="print.html#a编写响应" id="a编写响应"><h3>编写响应</h3></a>
<p>我们将实现在客户端请求的响应中发送数据的功能。响应有如下格式：</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>第一行叫做 <strong>状态行</strong>（<em>status line</em>），它包含响应的 HTTP 版本、一个数字状态码用以总结请求的结果和一个描述之前状态码的文本原因短语。CRLF 序列之后是任意 header，另一个 CRLF 序列，和响应的 body。</p>
<p>这里是一个使用 HTTP 1.1 版本的响应例子，其状态码为 <code>200</code>，原因短语为 <code>OK</code>，没有 header，也没有 body：</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>状态码 200 是一个标准的成功响应。这些文本是一个微型的成功 HTTP 响应。让我们将这些文本写入流作为成功请求的响应！</p>
<p>在 <code>handle_connection</code> 函数中，我们需要去掉打印请求数据的 <code>println!</code>，并替换为示例 20-3 中的代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">示例 20-3: 将一个微型成功 HTTP 响应写入流</span></p>
<!-- Flagging for addition of wingdings later -->
<p>新代码中的第一行定义了变量 <code>response</code> 来存放将要返回的成功响应的数据。接着，在 <code>response</code> 上调用 <code>as_bytes</code>，因为 <code>stream</code> 的 <code>write</code> 方法获取一个 <code>&amp;[u8]</code> 并直接将这些字节发送给连接。</p>
<!-- Above--So what does adding as_bytes actually do, *allow* us to send bytes
directly? -->
<!-- It converts the string data to bytes, I've clarified /Carol -->
<p>因为 <code>write</code> 操作可能会失败，所以像之前那样对任何错误结果使用 <code>unwrap</code>。同理，在真实世界的应用中这里需要添加错误处理。最后，<code>flush</code> 会等待并阻塞程序执行直到所有字节都被写入连接中；<code>TcpStream</code> 包含一个内部缓冲区来最小化对底层操作系统的调用。</p>
<!-- Above -- Will flush wait until all bytes are written and then do
something? I'm not sure what task it's performing -->
<!-- `flush` just makes sure all the bytes we sent to `write` are actually
written to the stream before the function ends. Because writing to a stream
takes time, the `handle_connection` function could potentially finish and
`stream` could go out of scope before all the bytes given to `write` are sent,
unless we call `flush`. This is how streams work in many languages and is a
small detail I don't think is worth going into in depth. /Carol -->
<p>有了这些修改，运行我们的代码并进行请求！我们不再向终端打印任何数据，所以不会再看到除了 Cargo 以外的任何输出。不过当在浏览器中加载 <code>127.0.0.1:7878</code> 时，会得到一个空页面而不是错误。太棒了！我们刚刚手写了一个 HTTP 请求与响应。</p>
<a class="header" href="print.html#a返回真正的-html" id="a返回真正的-html"><h3>返回真正的 HTML</h3></a>
<p>让我们实现不只是返回空页面的功能。在项目根目录创建一个新文件，<em>hello.html</em> —— 也就是说，不是在 <code>src</code> 目录。在此可以放入任何你期望的 HTML；列表 20-4 展示了一个可能的文本：</p>
<p><span class="filename">文件名: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">示例 20-4: 一个简单的 HTML 文件用来作为响应</span></p>
<p>这是一个极小化的 HTML 5 文档，它有一个标题和一小段文本。为了在 server 接受请求时返回它，需要如示例 20-5 所示修改 <code>handle_connection</code> 来读取 HTML 文件，将其加入到响应的 body 中，并发送：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs::File;

// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">示例 20-5: 将 <em>hello.html</em> 的内容作为响应 body 发送</span></p>
<p>在开头增加了一行来将标准库中的 <code>File</code> 引入作用域。打开和读取文件的代码应该看起来很熟悉，因为第十二章 I/O 项目的示例 12-4 中读取文件内容时出现过类似的代码。</p>
<p>接下来，使用 <code>format!</code> 将文件内容加入到将要写入流的成功响应的 body 中。</p>
<p>使用 <code>cargo run</code> 运行程序，在浏览器加载 <code>127.0.0.1:7878</code>，你应该会看到渲染出来的 HTML 文件！</p>
<p>目前忽略了 <code>buffer</code> 中的请求数据并无条件的发送了 HTML 文件的内容。这意味着如果尝试在浏览器中请求 <code>127.0.0.1:7878/something-else</code> 也会得到同样的 HTML 响应。如此其作用是非常有限的，也不是大部分 server 所做的；让我们检查请求并只对格式良好（well-formed）的请求 <code>/</code> 发送 HTML 文件。</p>
<a class="header" href="print.html#a验证请求并有选择的进行响应" id="a验证请求并有选择的进行响应"><h3>验证请求并有选择的进行响应</h3></a>
<p>目前我们的 web server 不管客户端请求什么都会返回相同的 HTML 文件。让我们增加在返回 HTML 文件前检查浏览器是否请求 <code>/</code>，并在其请求任何其他内容时返回错误的功能。为此需要如示例 20-6 那样修改 <code>handle_connection</code>。新代码接收到的请求的内容与已知的 <code>/</code> 请求的一部分做比较，并增加了 <code>if</code> 和 <code>else</code> 块来区别处理请求：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 20-6: 匹配请求并区别处理 <code>/</code> 请求与其他请求</span></p>
<p>首先，将与 <code>/</code> 请求相关的数据硬编码进变量 <code>get</code>。因为我们将原始字节读取进了缓冲区，所以在 <code>get</code> 的数据开头增加 <code>b&quot;&quot;</code> 字节字符串语法将其转换为字节字符串。接着检查 <code>buffer</code> 是否以 <code>get</code> 中的字节开头。如果是，这就是一个格式良好的 <code>/</code> 请求，也就是 <code>if</code> 块中期望处理的成功情况，并会返回 HTML 文件内容的代码。</p>
<p>如果 <code>buffer</code> <strong>不</strong> 以 <code>get</code> 中的字节开头，就说明接收的是其他请求。之后会在  <code>else</code> 块中增加代码来响应所有其他请求。</p>
<p>现在如果运行代码并请求 <code>127.0.0.1:7878</code>，就会得到 <em>hello.html</em> 中的 HTML。如果进行任何其他请求，比如 <code>127.0.0.1:7878/something-else</code>，则会得到像运行示例 20-1 和 20-2 中代码那样的连接错误。</p>
<p>现在向示例 20-7 的 <code>else</code> 块增加代码来返回一个带有 <code>404</code> 状态码的响应，这代表了所请求的内容没有找到。接着也会返回一个 HTML 向浏览器终端用户表明此意：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
#}</code></pre></pre>
<p><span class="caption">示例 20-7: 对于任何不是 <code>/</code> 的请求返回 <code>404</code> 状态码的响应和错误页面</span></p>
<p>这里，响应的状态行有状态码 <code>404</code> 和原因短语 <code>NOT FOUND</code>。仍然没有返回任何 header，而其 body 将是 <em>404.html</em> 文件中的 HTML。需要在 <em>hello.html</em> 同级目录创建 <em>404.html</em> 文件作为错误页面；这一次也可以随意使用任何 HTML 或使用示例 20-8 中的示例 HTML：</p>
<p><span class="filename">文件名: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">示例 20-8: 任何 <code>404</code> 响应所返回错误页面内容样例</span></p>
<p>有了这些修改，再次运行 server。请求 <code>127.0.0.1:7878</code> 应该会返回 <em>hello.html</em> 的内容，而对于任何其他请求，比如 <code>127.0.0.1:7878/foo</code>，应该会返回 <em>404.html</em> 中的错误 HTML！</p>
<a class="header" href="print.html#a少量代码重构" id="a少量代码重构"><h3>少量代码重构</h3></a>
<p>目前 <code>if</code> 和 <code>else</code> 块中的代码有很多的重复：他们都读取文件并将其内容写入流。唯一的区别是状态行和文件名。为了使代码更为简明，将这些区别分别提取到一行 <code>if</code> 和 <code>else</code> 中，对状态行和文件名变量赋值；然后在读取文件和写入响应的代码中无条件的使用这些变量。重构后取代了大段 <code>if</code> 和 <code>else</code> 块代码后的结果如示例 20-9 所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
#
#     let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">示例 20-9: 重构使得 <code>if</code> 和 <code>else</code> 块中只包含两个情况所不同的代码</span></p>
<p>现在 <code>if</code> 和 <code>else</code> 块所做的唯一的事就是在一个元组中返回合适的状态行和文件名的值；接着使用第十八章讲到的使用模式的 <code>let</code> 语句通过解构元组的两部分为 <code>filename</code> 和 <code>header</code> 赋值。</p>
<p>之前读取文件和写入响应的冗余代码现在位于 <code>if</code> 和 <code>else</code> 块之外，并会使用变量 <code>status_line</code> 和 <code>filename</code>。这样更易于观察这两种情况真正有何不同，还意味着如果需要改变如何读取文件或写入响应时只需要更新一处的代码。示例 20-9 中代码的行为与示例 20-8 完全一样。</p>
<p>好极了！我们有了一个 40 行左右 Rust 代码的小而简单的 server，它对一个请求返回页面内容而对所有其他请求返回 <code>404</code> 响应。</p>
<p>目前 server 运行于单线程中，它一次只能处理一个请求。让我们模拟一些慢请求来看看这如何会成为一个问题，并进行修复以便 server 可以一次处理多个请求。</p>
<a class="header" href="print.html#a将单线程-server-变为多线程-server" id="a将单线程-server-变为多线程-server"><h2>将单线程 server 变为多线程 server</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch20-02-multithreaded.md">ch20-02-multithreaded.md</a>
<br>
commit 1f0136399ba2f5540ecc301fab04bd36492e5554</p>
</blockquote>
<!-- Reading ahead, the original heading didn't seem to fit all of the sub
headings -- this might not be totally right either, so feel free to replace
with something more appropriate -->
<!-- This is fine! /Carol -->
<p>目前 server 会依次处理每一个请求，意味着它在完成第一个连接的处理之前不会处理第二个连接。如果 server 正接收越来越多的请求，这类串行操作会使性能越来越差。如果一个请求花费很长时间来处理，随后而来的请求则不得不等待这个长请求结束，即便这些新请求可以很快就处理完。我们需要修复这种情况，不过首先让我们实际尝试一下这个问题。</p>
<a class="header" href="print.html#a在当前-server-实现中模拟慢请求" id="a在当前-server-实现中模拟慢请求"><h3>在当前 server 实现中模拟慢请求</h3></a>
<p>让我们看看一个慢请求如何影响当前 server 实现中的其他请求。示例 20-10 通过模拟慢响应实现了 <code>/sleep</code> 请求处理，它会使 server 在响应之前休眠五秒。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">示例 20-10: 通过识别 <code>/sleep</code> 并休眠五秒来模拟慢请求</span></p>
<p>这段代码有些凌乱，不过对于模拟的目的来说已经足够！这里创建了第二个请求 <code>sleep</code>，我们会识别其数据。在 <code>if</code> 块之后增加了一个 <code>else if</code> 来检查 <code>/sleep</code> 请求，当接收到这个请求时，在渲染成功 HTML 页面之前会先休眠五秒。</p>
<p>现在就可以真切的看出我们的 server 有多么的原始；真实的库将会以更简洁的方式处理多请求识别问题。</p>
<p>使用 <code>cargo run</code> 启动 server，并接着打开两个浏览器窗口：一个请求 <code>http://localhost:7878/</code> 而另一个请求 <code>http://localhost:7878/sleep</code>。如果像之前一样多次请求 <code>/</code>，会发现响应的比较快速。不过如果请求<code>/sleep</code> 之后在请求 <code>/</code>，就会看到 <code>/</code> 会等待直到 <code>sleep</code> 休眠完五秒之后才出现。</p>
<p>这里有多种办法来改变我们的 web server 使其避免所有请求都排在慢请求之后；我们将要实现的一个便是线程池。</p>
<a class="header" href="print.html#a使用线程池改善吞吐量" id="a使用线程池改善吞吐量"><h3>使用线程池改善吞吐量</h3></a>
<!--There seems to be some repetition throughout these thread pool sections, is
there any way to condense it? I've edited with this in mind, but am wary of
changing too much -->
<!-- Your edits that removed repetition are fine! /Carol -->
<p><strong>线程池</strong>（<em>thread pool</em>）是一组预先分配的等待或准备处理任务的线程。当程序收到一个新任务，线程池中的一个线程会被分配任务，这个线程会离开并处理任务。其余的线程则可用于处理在第一个线程处理任务的同时处理其他接收到的任务。当第一个线程处理完任务时，它会返回空闲线程池中等待处理新任务。线程池允许我们并发处理连接，增加 server 的吞吐量。</p>
<p>我们会将池中线程限制为较少的数量，以防拒绝服务（Denial of Service， DoS）攻击；如果程序为每一个接收的请求都新建一个线程，某人向 server 发起千万级的请求时会耗尽服务器的资源并导致所有请求的处理都被终止。</p>
<p>不同于分配无限的线程，线程池中将有固定数量的等待线程。当新进请求时，将请求发送到线程池中做处理。线程池会维护一个接收请求的队列。每一个线程会从队列中取出一个请求，处理请求，接着向对队列索取另一个请求。通过这种设计，则可以并发处理 <code>N</code> 个请求，其中 <code>N</code> 为线程数。如果每一个线程都在响应慢请求，之后的请求仍然会阻塞队列，不过相比之前增加了能处理的慢请求的数量。</p>
<p>这个设计仅仅是多种改善 web server 吞吐量的方法之一。其他可供探索的方法有 fork/join 模型和单线程异步 I/O 模型。如果你对这个主题感兴趣，则可以阅读更多关于其他解决方案的内容并尝试用 Rust 实现他们；对于一个像 Rust 这样的底层语言，所有这些方法都是可能的。</p>
<p>在开始之前，让我们讨论一下线程池应用看起来怎样。当尝试设计代码时，首先编写客户端接口确实有助于指导代码设计。以期望的调用方式来构建 API 代码的结构，接着在这个结构之内实现功能，而不是先实现功能再设计公有 API。</p>
<p>类似于第十二章项目中使用的测试驱动开发。这里将要使用编译器驱动开发（Compiler Driven Development）。我们将编写调用所期望的函数的代码，接着观察编译器错误告诉我们接下来需要修改什么使得代码可以工作。</p>
<a class="header" href="print.html#a为每一个请求分配线程的代码结构" id="a为每一个请求分配线程的代码结构"><h4>为每一个请求分配线程的代码结构</h4></a>
<p>首先，让我们探索一下为每一个连接都创建一个线程的代码看起来如何。这并不是最终方案，因为正如之前讲到的它会潜在的分配无限的线程，不过这是一个开始。示例 20-11 展示了 <code>main</code> 的改变，它在 <code>for</code> 循环中为每一个流分配了一个新线程进行处理：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">示例 20-11: 为每一个流新建一个线程</span></p>
<p>正如第十六章讲到的，<code>thread::spawn</code> 会创建一个新线程并在其中运行闭包中的代码。如果运行这段代码并在在浏览器中加载 <code>/sleep</code>，接着在另两个浏览器标签页中加载 <code>/</code>，确实会发现 <code>/</code> 请求不必等待 <code>/sleep</code> 结束。不过正如之前提到的，这最终会使系统崩溃因为我们无限制的创建新线程。</p>
<a class="header" href="print.html#a为有限数量的线程创建一个类似的接口" id="a为有限数量的线程创建一个类似的接口"><h4>为有限数量的线程创建一个类似的接口</h4></a>
<p>我们期望线程池以类似且熟悉的方式工作，以便从线程切换到线程池并不会对使用该 API 的代码做出较大的修改。示例 20-12 展示我们希望用来替换 <code>thread::spawn</code> 的 <code>ThreadPool</code> 结构体的假想接口：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# struct ThreadPool;
# impl ThreadPool {
#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }
#    fn execute&lt;F&gt;(&amp;self, f: F)
#        where F: FnOnce() + Send + 'static {}
# }
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">示例 20-12: 假想的 <code>ThreadPool</code> 接口</span></p>
<p>这里使用 <code>ThreadPool::new</code> 来创建一个新的线程池，它有一个可配置的线程数的参数，在这里是四。这样在 <code>for</code> 循环中，<code>pool.execute</code> 有着类似 <code>thread::spawn</code> 的接口，它获取一个线程池运行于每一个流的闭包。<code>pool.execute</code> 需要实现为获取闭包并传递给池中的线程运行。这段代码还不能编译，不过通过尝试编译器会指导我们如何修复它。</p>
<!-- Can you be more specific here about how pool.execute will work? -->
<!-- So clarified. I hope this helps with some of the future confusion as well
/Carol -->
<a class="header" href="print.html#a采用编译器驱动构建-threadpool-结构体" id="a采用编译器驱动构建-threadpool-结构体"><h4>采用编译器驱动构建 <code>ThreadPool</code> 结构体</h4></a>
<p>继续并对示例 20-12 中的 <em>src/main.rs</em> 做出修改，并利用来自 <code>cargo check</code> 的编译器错误来驱动开发。下面是我们得到的第一个错误：</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>好的，这告诉我们需要一个 <code>ThreadPool</code> 类型或模块，所以我们将构建一个。<code>ThreadPool</code> 的实现会与 web server 的特定工作相独立，所以让我们从 <code>hello</code> crate 切换到存放 <code>ThreadPool</code> 实现的新库 crate。这也意味着可以在任何工作中使用这个单独的线程池库，而不仅仅是处理网络请求。</p>
<p>创建 <em>src/lib.rs</em> 文件，它包含了目前可用的最简单的 <code>ThreadPool</code> 定义：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;
#}</code></pre></pre>
<p>接着创建一个新目录，<em>src/bin</em>，并将二进制 crate 根文件从 <em>src/main.rs</em> 移动到 <em>src/bin/main.rs</em>。这使得库 crate 成为 <em>hello</em> 目录的主要 crate；不过仍然可以使用 <code>cargo run</code> 运行 <em>src/bin/main.rs</em> 二进制文件。移动了 <em>main.rs</em> 文件之后，修改 <em>src/bin/main.rs</em> 文件开头加入如下代码来引入库 crate 并将 <code>ThreadPool</code> 引入作用域：</p>
<p><span class="filename">文件名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<p>这仍然不能工作，再次尝试运行来得到下一个需要解决的错误：</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<p>好的，这告诉我们下一步是为 <code>ThreadPool</code> 创建一个叫做 <code>new</code> 的关联函数。我们还知道 <code>new</code> 需要有一个参数可以接受 <code>4</code>，而且 <code>new</code> 应该返回 <code>ThreadPool</code> 实例。让我们实现拥有此特征的最小化 <code>new</code> 函数：</p>
<p><span class="filename">文件夹: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
#}</code></pre></pre>
<p>这里选择 <code>usize</code> 作为 <code>size</code> 参数的类型，因为我们知道为负的线程数没有意义。我们还知道将使用 4 作为线程集合的元素数量，这也就是使用 <code>usize</code> 类型的原因，如第三章 “整数类型” 部分所讲。</p>
<p>再次编译检查这段代码：</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<!--Can you say a few words on why we would need an execute method, what Rust
needs it for? Also why we need a closure/what indicated that we need a closure
here? -->
<!-- *Rust* doesn't need it, the thread pool functionality we're working on
implementing needs it. I've tried to clarify without getting too repetitive
with the "Creating a Similar Interface for a Finite Number of Threads" section
/Carol -->
<p>现在有了一个警告和一个错误。暂时先忽略警告，发生错误是因为并没有 <code>ThreadPool</code> 上的 <code>execute</code> 方法。回忆 “为有限数量的线程创建一个类似的接口” 部分我们决定线程池应该有与 <code>thread::spawn</code> 类似的接口，同时我们将实现 <code>execute</code> 函数来获取传递的闭包并将其传递给池中的空闲线程执行。</p>
<p>我们会在 <code>ThreadPool</code> 上定义 <code>execute</code> 函数来获取一个闭包参数。回忆第十三章的 “使用带有泛型和 <code>Fn</code> trait 的闭包” 部分，闭包作为参数时可以使用三个不同的 trait：<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>。我们需要决定这里应该使用哪种闭包。最终需要实现的类似于标准库的 <code>thread::spawn</code>，所以我们可以观察 <code>thread::spawn</code> 的签名在其参数中使用了何种 bound。查看文档会发现：</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>F</code> 是这里我们关心的参数；<code>T</code> 与返回值有关所以我们并不关心。考虑到 <code>spawn</code> 使用 <code>FnOnce</code> 作为 <code>F</code> 的 trait bound，这可能也是我们需要的，因为最终会将传递给 <code>execute</code> 的参数传给 <code>spawn</code>。因为处理请求的线程只会执行闭包一次，这也进一步确认了 <code>FnOnce</code> 是我们需要的 trait，这里符合 <code>FnOnce</code> 中 <code>Once</code> 的意思。</p>
<!-- Above -- why does that second reason mean FnOnce is the trait to use, can
you remind us? -->
<!-- Attempted, we're just pointing out that it's in the name Fn*Once* /Carol
-->
<p><code>F</code> 还有 trait bound <code>Send</code> 和生命周期绑定 <code>'static</code>，这对我们的情况也是有意义的：需要 <code>Send</code> 来将闭包从一个线程转移到另一个线程，而 <code>'static</code> 是因为并不知道线程会执行多久。让我们编写一个使用带有这些 bound 的泛型参数 <code>F</code> 的 <code>ThreadPool</code> 的 <code>execute</code> 方法：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
#}</code></pre></pre>
<p><code>FnOnce</code> trait 仍然需要之后的 <code>()</code>，因为这里的 <code>FnOnce</code> 代表一个没有参数也没有返回值的闭包。正如函数的定义，返回值类型可以从签名中省略，不过即便没有参数也需要括号。</p>
<p>这里再一次增加了 <code>execute</code> 方法的最小化实现，它没有做任何工作。再次进行检查：</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<p>现在就只有警告了！这意味着能够编译了！注意如果尝试 <code>cargo run</code> 运行程序并在浏览器中发起请求，仍会在浏览器中出现在本章开始时那样的错误。这个库实际上还没有调用传递给 <code>execute</code> 的闭包！</p>
<blockquote>
<p>一个你可能听说过的关于像 Haskell 和 Rust 这样有严格编译器的语言的说法是 “如果代码能够编译，它就能工作”。这是一个提醒大家的好时机，实际上这并不是普适的。我们的项目可以编译，不过它完全没有做任何工作！如果构建一个真实且功能完整的项目，则需花费大量的时间来开始编写单元测试来检查代码能否编译 <strong>并且</strong> 拥有期望的行为。</p>
</blockquote>
<a class="header" href="print.html#a在-new-中验证池中线程数量" id="a在-new-中验证池中线程数量"><h4>在 <code>new</code> 中验证池中线程数量</h4></a>
<p>这里仍然存在警告是因为其并没有对 <code>new</code> 和 <code>execute</code> 的参数做任何操作。让我们用期望的行为来实现这些函数。以考虑 <code>new</code> 作为开始。</p>
<p>之前选择使用无符号类型作为 <code>size</code> 参数的类型，因为线程数为负的线程池没有意义。然而，线程数为零的线程池同样没有意义，不过零是一个完全有效的 <code>u32</code> 值。让我们增加在返回 <code>ThreadPool</code> 实例之前检查 <code>size</code> 是否大于零的代码，并使用 <code>assert!</code> 宏在得到零时 panic，如示例 20-13 所示：</p>
<p>在返回 <code>ThreadPool</code> 之前检查 <code>size</code>  是否大于零，并使用 <code>assert!</code> 宏在得到零时 panic，如列表 20-13 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">示例 20-13: 实现 <code>ThreadPool::new</code> 在 <code>size</code> 为零时 panic</span></p>
<p>趁着这个机会我们用文档注释为 <code>ThreadPool</code> 增加了一些文档。注意这里遵循了良好的文档实践并增加了一个部分来提示函数会 panic 的情况，正如第十四章所讨论的。尝试运行 <code>cargo doc --open</code> 并点击 <code>ThreadPool</code> 结构体来查看生成的 <code>new</code> 的文档看起来如何！</p>
<p>相比像这里使用 <code>assert!</code> 宏，也可以让 <code>new</code> 像之前 I/O 项目中示例 12-9 中 <code>Config::new</code> 那样返回一个 <code>Result</code>，不过在这里我们选择创建一个没有任何线程的线程池应该是不可恢复的错误。如果你想做的更好，尝试编写一个采用如下签名的 <code>new</code> 版本来感受一下两者的区别：</p>
<pre><code class="language-rust ignore">fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<a class="header" href="print.html#a分配空间以储存线程" id="a分配空间以储存线程"><h4>分配空间以储存线程</h4></a>
<p>现在有了一个有效的线程池线程数，就可以实际创建这些线程并在返回之前将他们储存在 <code>ThreadPool</code> 结构体中。</p>
<p>这引出了另一个问题：如何 “储存” 一个线程？让我们再看看 <code>thread::spawn</code> 的签名：</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>spawn</code> 返回 <code>JoinHandle&lt;T&gt;</code>，其中 <code>T</code> 是闭包返回的类型。尝试使用 <code>JoinHandle</code> 来看看会发生什么。在我们的情况中，传递给线程池的闭包会处理连接并不返回任何值，所以 <code>T</code> 将会是单元类型 <code>()</code>。</p>
<p>示例 20-14 中的代码可以编译，不过实际上还并没有创建任何线程。我们改变了 <code>ThreadPool</code> 的定义来存放一个 <code>thread::JoinHandle&lt;()&gt;</code> 的 vector 实例，使用 <code>size</code> 容量来初始化，并设置一个 <code>for</code> 循环了来运行创建线程的代码，并返回包含这些线程的 <code>ThreadPool</code> 实例：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<p><span class="caption">示例 20-14: 为 <code>ThreadPool</code> 创建一个 vector 来存放线程</span></p>
<p>这里将 <code>std::thread</code> 引入库 crate 的作用域，因为使用了 <code>thread::JoinHandle</code> 作为 <code>ThreadPool</code> 中 vector 元素的类型。</p>
<p>在得到了有效的数量之后，<code>ThreadPool</code> 新建一个存放 <code>size</code> 个元素的 vector。本书还未使用过 <code>with_capacity</code>，它与 <code>Vec::new</code> 做了同样的工作，不过有一个重要的区别：它为 vector 预先分配空间。因为已经知道了 vector 中需要 <code>size</code> 个元素，预先进行分配比仅仅 <code>Vec::new</code> 要稍微有效率一些，因为 <code>Vec::new</code> 随着插入元素而重新改变大小。</p>
<p>如果再次运行 <code>cargo check</code>，会看到一些警告，不过应该可以编译成功。</p>
<a class="header" href="print.html#worker-结构体负责从-threadpool-中将代码传递给线程" id="worker-结构体负责从-threadpool-中将代码传递给线程"><h4><code>Worker</code> 结构体负责从 <code>ThreadPool</code> 中将代码传递给线程</h4></a>
<!-- I wasn't sure what this next paragraph was relevant to, can you connect it
up more clearly?-->
<!-- This is where we're actually getting into the meat of the implementation,
I've tried to make it clearer :( /Carol-->
<p>示例 20-14 的 <code>for</code> 循环中留下了一个关于创建线程的注释。如何实际创建线程呢？这是一个难题。标准库提供的创建线程的方法，<code>thread::spawn</code>，它期望获取一些一旦创建线程就应该执行的代码。然而，我们希望开始线程并使其等待稍后传递的代码。标准库的线程实现并没有包含这么做的方法；我们必须自己实现。</p>
<!-- Can you say how doing this refactoring will improve the code -- why don't
we want the pool to store threads directly? (I got that from the listing
caption because I wasn't sure what the end game was) -->
<!-- I hope the end game is now clearer in the previous paragraph: we *can't*
store the threads directly and get the behavior we want. /Carol -->
<p>我们将要实现的行为是创建线程并稍后发送代码，这会在 <code>ThreadPool</code> 和线程间引入一个新数据类型来管理这种新行为。这个数据结构称为 <code>Worker</code>：这是一个池实现中的常见概念。想象一下在餐馆厨房工作的员工：员工等待来自客户的订单，他们负责接受这些订单并完成它们。</p>
<!-- I was unclear on what a worker actually is here -- is this a
programming/Rust term, or just what we're calling the struct? Can you make it
clearer what the worker is and its responsibilities? -->
<!-- I've tried in the previous paragraph; it's a common term in job
queue/pooling implementations in programming in general but I think should make
sense in plain English with the real-life metaphor I've added /Carol -->
<p>不同于在线程池中储存一个 <code>JoinHandle&lt;()&gt;</code> 实例的 vector，我们会储存 <code>Worker</code> 结构体的实例。每一个 <code>Worker</code> 会储存一个单独的 <code>JoinHandle&lt;()&gt;</code> 实例。接着会在
<code>Worker</code> 上实现一个方法，它会获取需要允许代码的闭包并将其发送给已经运行的线程执行。我们还会赋予每一个 worker <code>id</code>，这样就可以在日志和调试中区别线程池中的不同 worker。</p>
<p>首先，让我们做出如此创建 <code>ThreadPool</code> 时所需的修改。在通过如下方式设置完 <code>Worker</code> 之后，我们会实现向线程发送闭包的代码：</p>
<ol>
<li>定义 <code>Worker</code> 结构体存放 <code>id</code> 和 <code>JoinHandle&lt;()&gt;</code></li>
<li>修改 <code>ThreadPool</code> 存放一个 <code>Worker</code> 实例的 vector</li>
<li>定义 <code>Worker::new</code> 函数，它获取一个 <code>id</code> 数字并返回一个带有 <code>id</code> 和用空闭包分配的线程的 <code>Worker</code> 实例</li>
<li>在 <code>ThreadPool::new</code> 中，使用 <code>for</code> 循环计数生成 <code>id</code>，使用这个 <code>id</code> 新建 <code>Worker</code>，并储存进 vector 中</li>
</ol>
<p>如果你渴望挑战，在查示例 20-15 中的代码之前尝试自己实现这些修改。</p>
<p>准备好了吗？示例 20-15 就是一个做出了这些修改的例子：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 20-15: 修改 <code>ThreadPool</code> 存放 <code>Worker</code> 实例而不是直接存放线程</span></p>
<p>这里将 <code>ThreadPool</code> 中字段名从 <code>threads</code> 改为 <code>workers</code>，因为它现在储存 <code>Worker</code> 而不是 <code>JoinHandle&lt;()&gt;</code>。使用 <code>for</code> 循环中的计数作为 <code>Worker::new</code> 的参数，并将每一个新建的 <code>Worker</code> 储存在叫做 <code>workers</code> 的 vector 中。</p>
<p><code>Worker</code> 结构体和其 <code>new</code> 函数是私有的，因为外部代码（比如 <em>src/bin/main.rs</em> 中的 server）并不需要知道关于 <code>ThreadPool</code> 中使用 <code>Worker</code> 结构体的实现细节。<code>Worker::new</code> 函数使用 <code>id</code> 参数并储存了使用一个空闭包创建的 <code>JoinHandle&lt;()&gt;</code>。</p>
<p>这段代码能够编译并用指定给 <code>ThreadPool::new</code> 的参数创建储存了一系列的 <code>Worker</code> 实例，不过 <strong>仍然</strong> 没有处理 <code>execute</code> 中得到的闭包。让我们聊聊接下来怎么做。</p>
<a class="header" href="print.html#a使用通道向线程发送请求" id="a使用通道向线程发送请求"><h4>使用通道向线程发送请求</h4></a>
<p>下一个需要解决的问题是传递给 <code>thread::spawn</code> 的闭包完全没有做任何工作。目前，我们在 <code>execute</code> 方法中获得期望执行的闭包，不过在创建 <code>ThreadPool</code> 的过程中创建每一个 <code>Worker</code> 时需要向 <code>thread::spawn</code> 传递一个闭包。</p>
<p>我们希望刚创建的 <code>Worker</code> 结构体能够从 <code>ThreadPool</code> 的队列中获取需要执行的代码，并发送到线程中执行他们。</p>
<p>在第十六章，我们学习了 <strong>通道</strong> —— 一个沟通两个线程的简单手段 —— 对于这个例子来说则是绝佳的。这里通道将充当任务队列的作用，<code>execute</code> 将通过 <code>ThreadPool</code> 向其中线程正在寻找工作的 <code>Worker</code> 实例发送任务。如下是这个计划：</p>
<ol>
<li><code>ThreadPool</code> 会创建一个通道并充当发送端。</li>
<li>每个 <code>Worker</code> 将会充当通道的接收端。</li>
<li>新建一个 <code>Job</code> 结构体来存放用于向通道中发送的闭包。</li>
<li><code>execute</code> 方法会在通道发送端发出期望执行的任务。</li>
<li>在线程中，<code>Worker</code> 会遍历通道的接收端并执行任何接收到的任务。</li>
</ol>
<p>让我们以在 <code>ThreadPool::new</code> 中创建通道并让 <code>ThreadPool</code> 实例充当发送端开始，如示例 20-16 所示。<code>Job</code> 是将在通道中发出的类型；目前它是一个没有任何内容的结构体：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
#
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
# impl Worker {
#     fn new(id: usize) -&gt; Worker {
#         let thread = thread::spawn(|| {});
#
#         Worker {
#             id,
#             thread,
#         }
#     }
# }
#}</code></pre></pre>
<p><span class="caption">示例 20-16: 修改 <code>ThreadPool</code> 来储存一个发送 <code>Job</code> 实例的通道发送端</span></p>
<p>在 <code>ThreadPool::new</code> 中，新建了一个通道，并接着让线程池在接收端等待。这段代码能够编译，不过仍有警告。</p>
<p>让我们尝试在线程池创建每个 worker 时将通道的接收端传递给他们。须知我们希望在 worker 所分配的线程中使用通道的接收端，所以将在闭包中引用 <code>receiver</code> 参数。示例 20-17 中展示的代码还不能编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-17: 将通道的接收端传递给 worker</span></p>
<p>这是一些小而直观的修改：将通道的接收端传递进了 <code>Worker::new</code>，并接着在闭包中使用它。</p>
<p>如果尝试 check 代码，会得到这个错误：</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>这段代码尝试将 <code>receiver</code> 传递给多个 <code>Worker</code> 实例。这是不行的，回忆第十六章：Rust 所提供的通道实现是多 <strong>生产者</strong>，单 <strong>消费者</strong> 的。这意味着不能简单的克隆通道的消费端来解决问题。即便可以，那也不是我们希望使用的技术；我们希望通过在所有的 worker 中共享单一 <code>receiver</code>，在线程间分发任务。</p>
<!-- Above - you may be able to tell I struggled to follow this explanation,
can you double check my edits and correct here? -->
<!-- Yep, the text we had here was nonsensical. The edits are fine! /Carol -->
<p>另外，从通道队列中取出任务涉及到修改 <code>receiver</code>，所以这些线程需要一个能安全的共享和修改 <code>receiver</code> 的方式，否则可能导致竞争状态（参考第十六章）。</p>
<p>回忆一下第十六章讨论的线程安全智能指针，为了在多个线程间共享所有权并允许线程修改其值，需要使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。<code>Arc</code> 使得多个 worker 拥有接收端，而 <code>Mutex</code> 则确保一次只有一个 worker 能从接收端得到任务。示例 20-18 展示了所需的修改：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

// --snip--

# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# struct Job;
#
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#            receiver;
#         });
#
#         Worker {
#             id,
#             thread,
#         }
    }
}
#}</code></pre></pre>
<p><span class="caption">示例 20-18: 使用 <code>Arc</code> 和 <code>Mutex</code> 在 worker 间共享通道的接收端</span></p>
<p>在 <code>ThreadPool::new</code> 中，将通道的接收端放入一个 <code>Arc</code> 和一个 <code>Mutex</code> 中。对于每一个新 worker，克隆 <code>Arc</code> 来增加引用计数，如此这些 worker 就可以共享接收端的所有权了。</p>
<p>通过这些修改，代码可以编译了！我们做到了！</p>
<a class="header" href="print.html#a实现-execute-方法" id="a实现-execute-方法"><h4>实现 <code>execute</code> 方法</h4></a>
<p>最后让我们实现 <code>ThreadPool</code> 上的 <code>execute</code> 方法。同时也要修改 <code>Job</code> 结构体：它将不再是结构体，<code>Job</code> 将是一个有着 <code>execute</code> 接收到的闭包类型的 trait 对象的类型别名。第十九章 “类型别名用来创建类型同义词” 部分提到过，类型别名允许将长的类型变短。观察示例 20-19：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// --snip--
# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# use std::sync::mpsc;
# struct Worker {}

type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
#}</code></pre></pre>
<p><span class="caption">示例 20-19: 为存放每一个闭包的 <code>Box</code> 创建一个 <code>Job</code> 类型别名，接着在通道中发出任务</span></p>
<p>在使用 <code>execute</code> 得到的闭包新建 <code>Job</code> 实例之后，将这些任务从通道的发送端发出。这里调用 <code>send</code> 上的 <code>unwrap</code>，因为发送可能会失败，这可能发生于例如停止了所有线程执行的情况，这意味着接收端停止接收新消息了。不过目前我们无法停止线程执行；只要线程池存在他们就会一直执行。使用 <code>unwrap</code> 是因为我们知道失败不可能发生，即便编译器不这么认为。</p>
<p>不过到此事情还没有结束！在 worker 中，传递给 <code>thread::spawn</code> 的闭包仍然还只是 <strong>引用</strong> 了通道的接收端。相反我们需要闭包一直循环，向通道的接收端请求任务，并在得到任务时执行他们。如示例 20-20 对 <code>Worker::new</code> 做出修改：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-20: 在 worker 线程中接收并执行任务</span></p>
<p>这里，首先在 <code>receiver</code> 上调用了 <code>lock</code> 来获取互斥器，接着 <code>unwrap</code> 在出现任何错误时 panic。如果互斥器处于一种叫做 <strong>被污染</strong>（<em>poisoned</em>）的状态时获取锁可能会失败，这可能发生于其他线程在持有锁时 panic 了且没有释放锁。在这种情况下，调用 <code>unwrap</code> 使其 panic 是正确的行为。请随意将 <code>unwrap</code> 改为包含有意义错误信息的 <code>expect</code>。</p>
<p>如果锁定了互斥器，接着调用 <code>recv</code> 从通道中接收 <code>Job</code>。最后的 <code>unwrap</code> 也绕过了一些错误，这可能发生于持有通道发送端的线程停止的情况，类似于如果接收端关闭时 <code>send</code> 方法如何返回 <code>Err</code> 一样。</p>
<p>调用 <code>recv</code> 会 <strong>阻塞</strong> 当前线程，所以如果还没有任务，其会等待直到有可用的任务。<code>Mutex&lt;T&gt;</code> 确保一次只有一个 <code>Worker</code> 线程尝试请求任务。</p>
<p>理论上这段代码应该能够编译。不幸的是，Rust 编译器仍不够完美，会给出如下错误：</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>这个错误非常的神秘，因为这个问题本身就很神秘。为了调用储存在 <code>Box&lt;T&gt;</code> （这正是 <code>Job</code> 别名的类型）中的 <code>FnOnce</code> 闭包，该闭包需要能将自己移动 <strong>出</strong> <code>Box&lt;T&gt;</code>，因为当调用这个闭包时，它获取 <code>self</code> 的所有权。通常来说，将值移动出 <code>Box&lt;T&gt;</code> 是不被允许的，因为 Rust 不知道 <code>Box&lt;T&gt;</code> 中的值将会有多大；回忆第十五章能够正常使用 <code>Box&lt;T&gt;</code> 是因为我们将未知大小的值储存进 <code>Box&lt;T&gt;</code> 从而得到已知大小的值。</p>
<p>第十七章曾见过，示例 17-15 中有使用了 <code>self: Box&lt;Self&gt;</code> 语法的方法，它允许方法获取储存在 <code>Box&lt;T&gt;</code> 中的 <code>Self</code> 值的所有权。这正是我们希望做的，然而不幸的是 Rust 不允许我们这么做：Rust 当闭包被调用时行为的那部分并没有使用 <code>self: Box&lt;Self&gt;</code> 实现。所以这里 Rust 也不知道它可以使用 <code>self: Box&lt;Self&gt;</code> 来获取闭包的所有权并将闭包移动出 <code>Box&lt;T&gt;</code>。</p>
<p>Rust 仍在努力改进提升编译器的过程中，不过将来示例 20-20 中的代码应该能够正常工作。有很多像你一样的人正在修复这个以及其他问题！当你结束了本书的阅读，我们希望看到你也成为他们中的一员。</p>
<p>不过目前让我们通过一个小技巧来绕过这个问题。可以显式的告诉 Rust 在这里我们可以使用 <code>self: Box&lt;Self&gt;</code> 来获取 <code>Box&lt;T&gt;</code> 中值的所有权，而一旦获取了闭包的所有权就可以调用它了。这涉及到定义一个新 trait，它带有一个在签名中使用 <code>self: Box&lt;Self&gt;</code> 的方法 <code>call_box</code>，为任何实现了 <code>FnOnce()</code> 的类型定义这个 trait，修改类型别名来使用这个新 trait，并修改 <code>Worker</code> 使用 <code>call_box</code> 方法。这些修改如示例 20-21 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-21: 新增一个 trait <code>FnBox</code> 来绕过当前 <code>Box&lt;FnOnce()&gt;</code> 的限制</span></p>
<p>首先，新建了一个叫做 <code>FnBox</code> 的 trait。这个 trait 有一个方法 <code>call_box</code>，它类似于其他 <code>Fn*</code> trait 中的 <code>call</code> 方法，除了它获取 <code>self: Box&lt;Self&gt;</code> 以便获取 <code>self</code> 的所有权并将值从 <code>Box&lt;T&gt;</code> 中移动出来。</p>
<p>接下来，为任何实现了 <code>FnOnce()</code> trait 的类型 <code>F</code> 实现 <code>FnBox</code> trait。这实际上意味着任何 <code>FnOnce()</code> 闭包都可以使用 <code>call_box</code> 方法。<code>call_box</code> 的实现使用 <code>(*self)()</code> 将闭包移动出 <code>Box&lt;T&gt;</code> 并调用此闭包。</p>
<p>现在我们需要 <code>Job</code> 类型别名是任何实现了新 trait <code>FnBox</code> 的 <code>Box</code>。这允许我们在得到 <code>Job</code> 值时使用 <code>Worker</code> 中的 <code>call_box</code>。为任何 <code>FnOnce()</code> 闭包都实现了 <code>FnBox</code> trait 意味着无需对实际在通道中发出的值做任何修改。</p>
<p>最后，对于 <code>Worker::new</code> 的线程中所运行的闭包，调用 <code>call_box</code> 而不是直接执行闭包。现在 Rust 就能够理解我们的行为是正确的了。</p>
<p>这是非常狡猾且复杂的手段。无需过分担心他们并不是非常有道理；总有一天，这一切将是毫无必要的。</p>
<p>通过这个技巧，线程池处于可以运行的状态了！执行 <code>cargo run</code> 并发起一些请求：</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
     Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>成功了！现在我们有了一个可以异步执行连接的线程池！它绝不会创建超过四个线程，所以当 server 收到大量请求时系统也不会负担过重。如果请求 <code>/sleep</code>，server 也能够通过另外一个线程处理其他请求。</p>
<p>在学习了第十八章的 <code>while let</code> 循环之后，你可能会好奇为何不能如此编写 worker 线程：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-22: 一个使用 <code>while let</code> 的 <code>Worker::new</code> 替代实现</span></p>
<p>这段代码可以编译和运行，但是并不会产生所期望的线程行为：一个慢请求仍然会导致其他请求等待执行。如此的原因有些微妙：<code>Mutex</code> 结构体没有公有 <code>unlock</code> 方法，因为锁的所有权依赖 <code>lock</code> 方法返回的 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 中 <code>MutexGuard&lt;T&gt;</code> 的生命周期。这允许借用检查器在编译时确保绝不会在没有持有锁的情况下访问由 <code>Mutex</code> 守护的资源，不过如果没有认真的思考 <code>MutexGuard&lt;T&gt;</code> 的生命周期的话，也可能会导致比预期更久的持有锁。因为 <code>while</code> 表达式中的值在整个块一直处于作用域中，<code>job.call_box()</code> 调用的过程中其仍然持有锁，这意味着其他 worker 不能接收任务。</p>
<p>相反通过使用 <code>loop</code> 并在循环块之内而不是之外获取锁和任务，<code>lock</code> 方法返回的 <code>MutexGuard</code> 在 <code>let job</code> 语句结束之后立刻就被丢弃了。这确保了 <code>recv</code> 调用过程中持有锁，而在 <code>job.call_box()</code> 调用前锁就被释放了，这就允许并发处理多个请求了。</p>
<a class="header" href="print.html#a优雅停机与清理" id="a优雅停机与清理"><h2>优雅停机与清理</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch20-03-graceful-shutdown-and-cleanup.md">ch20-03-graceful-shutdown-and-cleanup.md</a>
<br>
commit 1f0136399ba2f5540ecc301fab04bd36492e5554</p>
</blockquote>
<p>示例 20-21 中的代码如期通过使用线程池异步的响应请求。这里有一些警告说 <code>workers</code>、<code>id</code> 和 <code>thread</code> 字段没有直接被使用，这提醒了我们并没有清理所有的内容。当使用不那么优雅的 <span class="keystroke">ctrl-C</span> 终止主线程时，所有其他线程也会立刻停止，即便它们正处于处理请求的过程中。</p>
<p>现在我们要为 <code>ThreadPool</code> 实现 <code>Drop</code> trait 对线程池中的每一个线程调用 <code>join</code>，这样这些线程将会执行完他们的请求。接着会为 <code>ThreadPool</code> 实现一个告诉线程他们应该停止接收新请求并结束的方式。为了实践这些代码，修改 server 在优雅停机（graceful shutdown）之前只接受两个请求。</p>
<a class="header" href="print.html#a为-threadpool-实现-drop-trait" id="a为-threadpool-实现-drop-trait"><h3>为 <code>ThreadPool</code> 实现 <code>Drop</code> Trait</h3></a>
<p>现在开始为线程池实现 <code>Drop</code>。当线程池被丢弃时，应该 join 所有线程以确保他们完成其操作。示例 20-23 展示了 <code>Drop</code> 实现的第一次尝试；这些代码还不能够编译：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-23: 当线程池离开作用域时 join 每个线程</span></p>
<p>这里首先遍历线程池中的每个 <code>workers</code>。这里使用了 <code>&amp;mut</code> 因为 <code>self</code> 本身是一个可变引用而且也需要能够修改 <code>worker</code>。对于每一个线程，会打印出说明信息表明此特定 worker 正在关闭，接着在 worker 线程上调用 <code>join</code>。如果 <code>join</code> 调用失败，通过 <code>unwrap</code> 使得 panic 并进行不优雅的关闭。</p>
<p>如下是尝试编译代码时得到的错误：</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>这告诉我们并不能调用 <code>join</code>，因为只有每一个 <code>worker</code> 的可变借用，而 <code>join</code> 获取其参数的所有权。为了解决这个问题，需要一个方法将 <code>thread</code> 移动出拥有其所有权的 <code>Worker</code> 实例以便 <code>join</code> 可以消费这个线程。示例 17-15 中我们曾见过这么做的方法：如果 <code>Worker</code> 存放的是 <code>Option&lt;thread::JoinHandle&lt;()&gt;</code>，就可以在 <code>Option</code> 上调用 <code>take</code> 方法将值从 <code>Some</code> 成员中移动出来而对 <code>None</code> 成员不做处理。换句话说，正在运行的 <code>Worker</code> 的 <code>thread</code> 将是 <code>Some</code> 成员值，而当需要清理 worker 时，将 <code>Some</code> 替换为 <code>None</code>，这样 worker 就没有可以运行的线程了。</p>
<p>为此需要更新 <code>Worker</code> 的定义为如下：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<p>现在依靠编译器来找出其他需要修改的地方。check 代码会得到两个错误：</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>让我们修复第二个错误，它指向 <code>Worker::new</code> 结尾的代码；当新建 <code>Worker</code> 时需要将 <code>thread</code> 值封装进 <code>Some</code>。做出如下改变以修复问题：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>第一个错误位于 <code>Drop</code> 实现中。之前提到过要调用 <code>Option</code> 上的 <code>take</code> 将 <code>thread</code> 移动出 <code>worker</code>。如下改变会修复问题：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>如第十七章我们见过的，<code>Option</code> 上的 <code>take</code> 方法会取出 <code>Some</code> 而留下 <code>None</code>。使用 <code>if let</code> 解构 <code>Some</code> 并得到线程，接着在线程上调用 <code>join</code>。如果 worker 的线程已然是 <code>None</code>，就知道此时这个 worker 已经清理了其线程所以无需做任何操作。</p>
<a class="header" href="print.html#a向线程发送信号使其停止接收任务" id="a向线程发送信号使其停止接收任务"><h3>向线程发送信号使其停止接收任务</h3></a>
<p>有了这些修改，代码就能编译且没有任何警告。不过也有坏消息，这些代码还不能以我们期望的方式运行。问题的关键在于 <code>Worker</code> 中分配的线程所运行的闭包中的逻辑：调用 <code>join</code> 并不会关闭线程，因为他们一直 <code>loop</code> 来寻找任务。如果采用这个实现来尝试丢弃 <code>ThreadPool</code> ，则主线程会永远阻塞在等待第一个线程结束上。</p>
<p>为了修复这个问题，修改线程既监听是否有 <code>Job</code> 运行也要监听一个应该停止监听并退出无限循环的信号。所以通道将发送这个枚举的两个成员之一而不是 <code>Job</code> 实例：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Job;
enum Message {
    NewJob(Job),
    Terminate,
}
#}</code></pre></pre>
<p><code>Message</code> 枚举要么是存放了线程需要运行的 <code>Job</code> 的 <code>NewJob</code> 成员，要么是会导致线程退出循环并终止的 <code>Terminate</code> 成员。</p>
<p>同时需要修改通道来使用 <code>Message</code> 类型值而不是 <code>Job</code>，如示例 20-24 所示：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-24: 收发 <code>Message</code> 值并在 <code>Worker</code> 收到 <code>Message::Terminate</code> 时退出循环</span></p>
<p>为了适用 <code>Message</code> 枚举需要将两个地方的 <code>Job</code> 修改为 <code>Message</code>：<code>ThreadPool</code> 的定义和 <code>Worker::new</code> 的签名。<code>ThreadPool</code> 的 <code>execute</code> 方法需要发送封装进 <code>Message::NewJob</code> 成员的任务。然后，在 <code>Worker::new</code> 中当从通道接收 <code>Message</code> 时，当获取到 <code>NewJob</code>成员会处理任务而收到 <code>Terminate</code> 成员则会退出循环。</p>
<p>通过这些修改，代码再次能够编译并继续按照期望的行为运行。不过还是会得到一个警告，因为并没有创建任何 <code>Terminate</code> 成员的消息。如示例 20-25 所示修改 <code>Drop</code> 实现来修复此问题：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">示例 20-25：在对每个 worker 线程调用 <code>join</code> 之前向 worker 发送 <code>Message::Terminate</code></span></p>
<p>现在遍历了 worker 两次，一次向每个 worker 发送一个 <code>Terminate</code> 消息，一个调用每个 worker 线程上的  <code>join</code>。如果尝试在同一循环中发送消息并立即 join 线程，则无法保证当前迭代的 worker 是从通道收到终止消息的 worker。</p>
<p>为了更好的理解为什么需要两个分开的循环，想象一下只有两个 worker 的场景。如果在一个单独的循环中遍历每个 worker，在第一次迭代中向通道发出终止消息并对第一个 worker 线程调用 <code>join</code>。我们会一直等待第一个 worker 结束，不过它永远也不会结束因为第二个线程接收了终止消息。死锁！</p>
<p>为了避免此情况，首先在一个循环中向通道发出所有的 <code>Terminate</code> 消息，接着在另一个循环中 join 所有的线程。每个 worker 一旦收到终止消息即会停止从通道接收消息，意味着可以确保如果发送同 worker 数相同的终止消息，在 join 之前每个线程都会收到一个终止消息。</p>
<p>为了实践这些代码，如示例 20-26 所示修改 <code>main</code> 在优雅停机 server 之前只接受两个请求：</p>
<p><span class="filename">文件名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<p><span class="caption">示例 20-26: 在处理两个请求之后通过退出循环来停止 server</span></p>
<p>你不会希望真实世界的 web server 只处理两次请求就停机了，这只是为了展示优雅停机和清理处于正常工作状态。</p>
<p><code>take</code> 方法定义于 <code>Iterator</code> trait，这里限制循环最多头 2 次。<code>ThreadPool</code> 会在 <code>main</code> 的结尾离开作用域，而且还会看到 <code>drop</code> 实现的运行。</p>
<p>使用 <code>cargo run</code> 启动 server，并发起三个请求。第三个请求应该会失败，而终端的输出应该看起来像这样：</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>可能会出现不同顺序的 worker 和信息输出。可以从信息中看到服务是如何运行的： worker 0 和 worker 3 获取了头两个请求，接着在第三个请求时，我们停止接收连接。当 <code>ThreadPool</code> 在 <code>main</code> 的结尾离开作用域时，其 <code>Drop</code> 实现开始工作，线程池通知所有线程终止。每个 worker 在收到终止消息时会打印出一个信息，接着线程池调用 <code>join</code> 来终止每一个 worker 线程。</p>
<p>这个特定的运行过程中一个有趣的地方在于：注意我们向通道中发出终止消息，而在任何线程收到消息之前，就尝试 join worker 0 了。worker 0 还没有收到终止消息，所以主线程阻塞直到 worker 0 结束。与此同时，每一个线程都收到了终止消息。一旦 worker 0 结束，主线程就等待其他 worker 结束，此时他们都已经收到终止消息并能够停止了。</p>
<p>恭喜！现在我们完成了这个项目，也有了一个使用线程池异步响应请求的基础 web server。我们能对 server 执行优雅停机，它会清理线程池中的所有线程。如下是完整的代码参考：</p>
<p><span class="filename">文件名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
#}</code></pre></pre>
<p>这里还有很多可以做的事！如果你希望继续增强这个项目，如下是一些点子：</p>
<ul>
<li>为 <code>ThreadPool</code> 和其公有方法增加更多文档</li>
<li>为库的功能增加测试</li>
<li>将 <code>unwrap</code> 调用改为更健壮的错误处理</li>
<li>使用 <code>ThreadPool</code> 进行其他不同于处理网络请求的任务</li>
<li>在 crates.io 寻找一个线程池 crate 并使用它实现一个类似的 web server，将其 API 和鲁棒性与我们的实现做对比</li>
</ul>
<a class="header" href="print.html#a总结-19" id="a总结-19"><h2>总结</h2></a>
<p>好极了！你结束了本书的学习！由衷感谢你与我们一道加入这次 Rust 之旅。现在你已经准备好出发并实现自己的 Rust 项目并帮助他人了。请不要忘记我们的社区，这里有其他 Rustaceans 正乐于帮助你迎接 Rust 之路上的任何挑战。</p>
<a class="header" href="print.html#a附录" id="a附录"><h1>附录</h1></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-00.md">appendix-00.md</a>
<br>
commit 4f2dc564851dc04b271a2260c834643dfd86c724</p>
</blockquote>
<p>附录部分包含一些在你的Rust之旅中可能用到的参考资料。</p>
<a class="header" href="print.html#a附录a---关键字" id="a附录a---关键字"><h2>附录A - 关键字</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-01-keywords.md">appendix-01-keywords.md</a>
<br>
commit 32215c1d96c9046c0b553a05fa5ec3ede2e125c3</p>
</blockquote>
<p>下面的列表中是Rust正在使用或者以后会用关键字。因此，这些关键字不能被用作标识符，例如
函数、变量、参数、结构体、模块、crate、常量、宏、静态值、属性、类型、trait 或生命周期
的名字。</p>
<a class="header" href="print.html#a目前正在使用的关键字" id="a目前正在使用的关键字"><h3>目前正在使用的关键字</h3></a>
<ul>
<li><code>as</code> - 强制类型转换或者对使用<code>use</code>和<code>extern crate</code>声明引入的项目重命名</li>
<li><code>break</code> - 立刻退出循环</li>
<li><code>const</code> - 定义常量或者 <strong>不变原生指针</strong> (<em>constant raw pointers</em>)</li>
<li><code>continue</code> - 跳出本次循环，进入下一次循环</li>
<li><code>crate</code> - 引入一个外部 <strong>crate</strong> 或一个代表 <strong>crate</strong> 的宏变量</li>
<li><code>else</code> - 创建 <code>if</code> 和 <code>if let</code> 控制流的分支</li>
<li><code>enum</code> - 定义一个枚举</li>
<li><code>extern</code> - 引入一个外部 <strong>crate</strong> 、函数或变量</li>
<li><code>false</code> - 布尔值 <code>false</code></li>
<li><code>fn</code> - 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li>
<li><code>for</code> - 遍历一个迭代器或实现一个 <strong>trait</strong>或者指定一个具体的生命周期</li>
<li><code>if</code> - 基于条件表达式的结果分支</li>
<li><code>impl</code> - 实现一个方法或 <strong>trait</strong> 功能</li>
<li><code>in</code> - for循环语法的一部分</li>
<li><code>let</code> - 绑定一个变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 模式匹配</li>
<li><code>mod</code> - 定义一个模块</li>
<li><code>move</code> - 使闭包获取所有权</li>
<li><code>mut</code> - 表示一个可变绑定</li>
<li><code>pub</code> - 在结构体、<code>impl</code>块或模块中表示可以被外部使用</li>
<li><code>ref</code> - 绑定一个引用</li>
<li><code>return</code> - 从函数中返回</li>
<li><code>Self</code> - 实现一个 <strong>trait</strong> 类型的类型别名</li>
<li><code>self</code> - 表示方法本身或当前模块</li>
<li><code>static</code> - 表示全局变量或在整个程序执行期间保持其生命周期</li>
<li><code>struct</code> - 定义一个结构体</li>
<li><code>super</code> - 表示当前模块的父模块</li>
<li><code>trait</code> - 定义一个 <strong>trait</strong></li>
<li><code>true</code> - 布尔值 <code>true</code></li>
<li><code>type</code> - 定义一个类型别名或相关联的类型</li>
<li><code>unsafe</code> - 表示不安全的代码、函数、<strong>traits</strong> 或者方法实现</li>
<li><code>use</code> - 引入外部空间的符号</li>
<li><code>where</code> - 表示一个类型约束 <a href="ch13-01-closures.html#%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89%E6%B3%9B%E5%9E%8B%E5%92%8C-fn-trait-%E7%9A%84%E9%97%AD%E5%8C%85">[For example]</a></li>
<li><code>while</code> - 基于一个表达式的结果判断是否进行循环</li>
</ul>
<!-- we should make sure the definitions for each keyword are consistently
phrased, so for example for enum we say "defining an enumeration" but for fn we
passively call it a "function definition" -- perhaps a good medium would be
"define an enumeration" and "define a function"? Can you go through and make
those consistent? I've attempted it for a few, but am wary of changing meaning.
Also, you may decide to go the passive definition route, which is fine by me,
as long as it's consistent-->
<!-- I've tried, I'm not sure how to be active for keywords that are nouns
though. Please let me know if any still seem inconsistent /Carol -->
<a class="header" href="print.html#a未使用的保留字" id="a未使用的保留字"><h3>未使用的保留字</h3></a>
<p>这些关键字没有目前任何功能，但是它们是 Rust 未来会使用的保留字。</p>
<ul>
<li><code>abstract</code></li>
<li><code>alignof</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>offsetof</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>proc</code></li>
<li><code>pure</code></li>
<li><code>sizeof</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<a class="header" href="print.html#a附录b---运算符与符号" id="a附录b---运算符与符号"><h2>附录B - 运算符与符号</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-02-operators.md">appendix-02-operators.md</a>
<br />
commit d50521fc08e51892cdf1edf5e35f3847a42f9432</p>
</blockquote>
<p>该附录包含了 Rust 语法的词汇表，包括运算符以及其他的符号，这些符号以其自身或者在路径、泛型、trait bounds、宏、属性、注释、元组以及大括号的上下文中出现。</p>
<a class="header" href="print.html#a运算符" id="a运算符"><h3>运算符</h3></a>
<p>表B-1包含了 Rust 中的运算符、运算符如何出现在上下文中的示例、简短解释以及该运算符是否可重载。如果一个运算符是可重载的，则该运算符上用于重载的相关 trait 也会列出。</p>
<p><span  class="caption">表 B-1: 运算符</span></p>
<table><thead><tr><th> 运算符 </th><th> 示例 </th><th> 解释 </th><th> 是否可重载 </th></tr></thead><tbody>
<tr><td> <code>!</code> </td><td> <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code> </td><td> 宏扩展 </td><td>  </td></tr>
<tr><td> <code>!</code> </td><td> <code>!expr</code> </td><td> 按位非或逻辑非 </td><td> <code>Not</code> </td></tr>
<tr><td> <code>!=</code> </td><td> <code>var != expr</code> </td><td> 不等比较 </td><td> <code>PartialEq</code> </td></tr>
<tr><td> <code>%</code> </td><td> <code>expr % expr</code> </td><td> 算术取模 </td><td> <code>Rem</code> </td></tr>
<tr><td> <code>%=</code> </td><td> <code>var %= expr</code> </td><td> 算术取模与赋值 </td><td> <code>RemAssign</code> </td></tr>
<tr><td> <code>&amp;</code> </td><td> <code>&amp;expr</code>, <code>&amp;mut expr</code> </td><td> 借用 </td><td> </td></tr>
<tr><td> <code>&amp;</code> </td><td> <code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code> </td><td> 借用指针类型 </td><td>  </td></tr>
<tr><td> <code>&amp;</code> </td><td> <code>expr &amp; expr</code> </td><td> 按位与 </td><td> <code>BitAnd</code> </td></tr>
<tr><td> <code>&amp;=</code> </td><td> <code>var &amp;= expr</code> </td><td> 按位与与及赋值 </td><td> <code>BitAndAssign</code> </td></tr>
<tr><td> <code>&amp;&amp;</code> </td><td> <code>expr &amp;&amp; expr</code> </td><td> 逻辑与 </td><td>  </td></tr>
<tr><td> <code>*</code> </td><td> <code>expr * expr</code> </td><td> 算术乘法 </td><td> <code>Mul</code> </td></tr>
<tr><td> <code>*=</code> </td><td> <code>var *= expr</code> </td><td> 算术乘法与赋值 </td><td> <code>MulAssign</code> </td></tr>
<tr><td> <code>*</code> </td><td> <code>*expr</code> </td><td> 解引用 </td><td> </td></tr>
<tr><td> <code>*</code> </td><td> <code>*const type</code>, <code>*mut type</code> </td><td> 原生指针 </td><td> </td></tr>
<tr><td> <code>+</code> </td><td> <code>trait + trait</code>, <code>'a + trait</code> </td><td> 复合类型限制 </td><td> </td></tr>
<tr><td> <code>+</code> </td><td> <code>expr + expr</code> </td><td> 算术加法 </td><td> <code>Add</code> </td></tr>
<tr><td> <code>+=</code> </td><td> <code>var += expr</code> </td><td> 算术加法与赋值 </td><td> <code>AddAssign</code> </td></tr>
<tr><td> <code>,</code> </td><td> <code>expr, expr</code> </td><td> 参数以及元素分隔符 </td><td> </td></tr>
<tr><td> <code>-</code> </td><td> <code>- expr</code> </td><td> 算术取负 </td><td> <code>Neg</code> </td></tr>
<tr><td> <code>-</code> </td><td> <code>expr - expr</code> </td><td> 算术减法</td><td> <code>Sub</code> </td></tr>
<tr><td> <code>-=</code> </td><td> <code>var -= expr</code> </td><td> 算术减法与赋值 </td><td> <code>SubAssign</code> </td></tr>
<tr><td> <code>-&gt;</code> </td><td> <code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code> </td><td> 函数与闭包，返回类型 </td><td> </td></tr>
<tr><td> <code>.</code> </td><td> <code>expr.ident</code> </td><td> 成员访问 </td><td> </td></tr>
<tr><td> <code>..</code> </td><td> <code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code> </td><td> 右排除范围 </td><td> </td></tr>
<tr><td> <code>..</code> </td><td> <code>..expr</code> </td><td> 结构体更新语法 </td><td> </td></tr>
<tr><td> <code>..</code> </td><td> <code>variant(x, ..)</code>, <code>struct_type { x, .. }</code> </td><td> “与剩余部分”的模式绑定 </td><td> </td></tr>
<tr><td> <code>...</code> </td><td> <code>expr...expr</code> </td><td> 模式: 范围包含模式 </td><td> </td></tr>
<tr><td> <code>/</code> </td><td> <code>expr / expr</code> </td><td> 算术除法 </td><td> <code>Div</code> </td></tr>
<tr><td> <code>/=</code> </td><td> <code>var /= expr</code> </td><td> 算术除法与赋值 </td><td> <code>DivAssign</code> </td></tr>
<tr><td> <code>:</code> </td><td> <code>pat: type</code>, <code>ident: type</code> </td><td> 约束 </td><td> </td></tr>
<tr><td> <code>:</code> </td><td> <code>ident: expr</code> </td><td> 结构体字段初始化 </td><td> </td></tr>
<tr><td> <code>:</code> </td><td> <code>'a: loop {...}</code> </td><td> 循环标志 </td><td> </td></tr>
<tr><td> <code>;</code> </td><td> <code>expr;</code> </td><td> 语句和语句结束符 </td><td> </td></tr>
<tr><td> <code>;</code> </td><td> <code>[...; len]</code> </td><td> 固定大小数组语法的部分 </td><td> </td></tr>
<tr><td> <code>&lt;&lt;</code> </td><td> <code>expr &lt;&lt; expr</code> </td><td>左移 </td><td> <code>Shl</code> </td></tr>
<tr><td> <code>&lt;&lt;=</code> </td><td> <code>var &lt;&lt;= expr</code> </td><td> 左移与赋值</td><td> <code>ShlAssign</code> </td></tr>
<tr><td> <code>&lt;</code> </td><td> <code>expr &lt; expr</code> </td><td> 小于比较 </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&lt;=</code> </td><td> <code>expr &lt;= expr</code> </td><td> 小于等于比较 </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>=</code> </td><td> <code>var = expr</code>, <code>ident = type</code> </td><td> 赋值/等值 </td><td> </td></tr>
<tr><td> <code>==</code> </td><td> <code>expr == expr</code> </td><td> 等于比较 </td><td> <code>PartialEq</code> </td></tr>
<tr><td> <code>=&gt;</code> </td><td> <code>pat =&gt; expr</code> </td><td> 匹配准备语法的部分 </td><td> </td></tr>
<tr><td> <code>&gt;</code> </td><td> <code>expr &gt; expr</code> </td><td> 大于比较 </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&gt;=</code> </td><td> <code>expr &gt;= expr</code> </td><td> 大于等于比较 </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&gt;&gt;</code> </td><td> <code>expr &gt;&gt; expr</code> </td><td> 右移 </td><td> <code>Shr</code> </td></tr>
<tr><td> <code>&gt;&gt;=</code> </td><td> <code>var &gt;&gt;= expr</code> </td><td> 右移与赋值 </td><td> <code>ShrAssign</code> </td></tr>
<tr><td> <code>@</code> </td><td> <code>ident @ pat</code> </td><td> 模式绑定 </td><td> </td></tr>
<tr><td> <code>^</code> </td><td> <code>expr ^ expr</code> </td><td> 按位异或 </td><td> <code>BitXor</code> </td></tr>
<tr><td> <code>^=</code> </td><td> <code>var ^= expr</code> </td><td> 按位异或与赋值 </td><td> <code>BitXorAssign</code> </td></tr>
<tr><td> <code>|</code> </td><td> <code>pat | pat</code> </td><td> 模式选择 </td><td> </td></tr>
<tr><td> <code>|</code> </td><td> <code>expr | expr</code> </td><td> 按位或 </td><td> <code>BitOr</code> </td></tr>
<tr><td> <code>|=</code> </td><td> <code>var |= expr</code> </td><td> 按位或与赋值 </td><td> <code>BitOrAssign</code> </td></tr>
<tr><td> <code>||</code> </td><td> <code>expr || expr</code> </td><td> 逻辑或 </td><td> </td></tr>
<tr><td> <code>?</code> </td><td> <code>expr?</code> </td><td> 错误传播 </td><td> </td></tr>
</tbody></table>
<a class="header" href="print.html#a非运算符符号" id="a非运算符符号"><h3>非运算符符号</h3></a>
<p>下面的列表中包含了所有和运算符不一样功能的非字符符号；也就是说，他们并不像函数调用或方法调用一样表现。</p>
<p>表 B-2 展示了以其自身出现以及出现在合法其他各个地方的符号。</p>
<p><span  class="caption">表 B-2：独立语法</span></p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>'ident</code> </td><td> 命名生命周期或循环标签 </td></tr>
<tr><td> <code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, 等 </td><td> 指定类型的数值常量 </td></tr>
<tr><td> <code>&quot;...&quot;</code> </td><td> 字符串常量 </td></tr>
<tr><td> <code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc. </td><td> 原生字符串常量, 未处理的遗漏字符 </td></tr>
<tr><td> <code>b&quot;...&quot;</code> </td><td> 字节字符串; 构造一个 <code>[u8]</code> 类型而非字符串 </td></tr>
<tr><td> <code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, 等 </td><td> 原生字节字符串常量，原生字节和字节结合的字符串 </td></tr>
<tr><td> <code>'...'</code> </td><td> 字符常量 </td></tr>
<tr><td> <code>b'...'</code> </td><td> ASCII码字节常量 </td></tr>
<tr><td> <code>|...| expr</code> </td><td> 结束 </td></tr>
<tr><td> <code>!</code> </td><td> 对一个离散函数来说最后总是空类型 </td></tr>
<tr><td> <code>_</code> </td><td> “忽略”模式绑定， 也用于整数常量的可读性 </td></tr>
</tbody></table>
<p><span  class="caption">表 B-3： 路径相关语法</span></p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>ident::ident</code> </td><td> 命名空间路径 </td></tr>
<tr><td> <code>::path</code> </td><td> 与crate根相关的路径（如一个明确的绝对路径） </td></tr>
<tr><td> <code>self::path</code> </td><td> 当前模块相关路径（如一个明确相关路径）</td></tr>
<tr><td> <code>super::path</code> </td><td> 父模块相关路径 </td></tr>
<tr><td> <code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code> </td><td> 相关常量、函数以及类型 </td></tr>
<tr><td> <code>&lt;type&gt;::...</code> </td><td> 不可以被直接命名的相关项类型（如 <code>&lt;&amp;T&gt;::...</code>，<code>&lt;[T]&gt;::...</code>， 等） </td></tr>
<tr><td> <code>trait::method(...)</code> </td><td> 通过命名定义的 trait 来消除方法调用的二义性 </td></tr>
<tr><td> <code>type::method(...)</code> </td><td> 通过命名定义的类型来消除方法调用的二义性 </td></tr>
<tr><td> <code>&lt;type as trait&gt;::method(...)</code> </td><td> 通过命名 trait 和类型来消除方法调用的二义性 </td></tr>
</tbody></table>
<p>表 B-4 展示了出现在泛型类型参数上下文中的符号。</p>
<p><span  class="caption">表 B-4：泛型</span></p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>path&lt;...&gt;</code> </td><td> 为一个类型中的泛型指定具体参数（如 <code>Vec&lt;u8&gt;</code>） </td></tr>
<tr><td> <code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code> </td><td> 为一个泛型、函数或表达式中的方法指定具体参数，通常指 <a href="https://matematikaadit.github.io/posts/rust-turbofish.html">turbofish</a> （如 <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>）</td></tr>
<tr><td> <code>fn ident&lt;...&gt; ...</code> </td><td> 泛型函数定义 </td></tr>
<tr><td> <code>struct ident&lt;...&gt; ...</code> </td><td> 泛型结构体定义 </td></tr>
<tr><td> <code>enum ident&lt;...&gt; ...</code> </td><td> 泛型枚举定义 </td></tr>
<tr><td> <code>impl&lt;...&gt; ...</code> </td><td> 定义泛型实现 </td></tr>
<tr><td> <code>for&lt;...&gt; type</code> </td><td> 高级生命周期限制 </td></tr>
<tr><td> <code>type&lt;ident=type&gt;</code> </td><td> 泛型，其一个或多个相关类型必须被指定为特定类型（如 <code>Iterator&lt;Item=T&gt;</code>）</td></tr>
</tbody></table>
<p>表 B-5 展示了出现在使用 trait bounds 约束泛型参数上下文中的符号。</p>
<p><span  class="caption">表 B-5: Trait Bound 约束</span></p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>T: U</code> </td><td> 泛型参数 <code>T</code> 约束于实现了 <code>U</code> 的类型 </td></tr>
<tr><td> <code>T: 'a</code> </td><td> 泛型 <code>T</code> 的生命周期必须长于 <code>'a</code>（意味着该类型不能传递包含生命周期短于 <code>'a</code> 的任何引用）</td></tr>
<tr><td> <code>T : 'static</code> </td><td> 泛型 <code>T</code> 包含了除 <code>'static</code> 之外的非借用引用 </td></tr>
<tr><td> <code>'b: 'a</code> </td><td> 泛型 <code>'b</code> 生命周期必须长于泛型 <code>'a</code> </td></tr>
<tr><td> <code>T: ?Sized</code> </td><td> 使用一个不定大小的泛型类型 </td></tr>
<tr><td> <code>'a + trait</code>, <code>trait + trait</code> </td><td> 复合类型限制 </td></tr>
</tbody></table>
<p>表 B-6 展示了在调用或定义宏以及在其上指定属性时的上下文中出现的符号。</p>
<p><span  class="caption">表 B-6: 宏与属性</span></p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>#[meta]</code> </td><td> 外部属性 </td></tr>
<tr><td> <code>#![meta]</code> </td><td> 内部属性 </td></tr>
<tr><td> <code>$ident</code> </td><td> 宏替换 </td></tr>
<tr><td> <code>$ident:kind</code> </td><td> 宏捕获 </td></tr>
<tr><td> <code>$(…)…</code> </td><td> 宏重复 </td></tr>
</tbody></table>
<p>表 B-7 展示了写注释的符号。</p>
<p><span  class="caption">表 B-7: 注释</span></p>
<table><thead><tr><th> 符号 </th><th> 注释 </th></tr></thead><tbody>
<tr><td> <code>//</code> </td><td> 行注释 </td></tr>
<tr><td> <code>//!</code> </td><td> 内部行文档注释 </td></tr>
<tr><td> <code>///</code> </td><td> 外部行文档注释 </td></tr>
<tr><td> <code>/*...*/</code> </td><td> 块注释 </td></tr>
<tr><td> <code>/*!...*/</code> </td><td> 内部块文档注释 </td></tr>
<tr><td> <code>/**...*/</code> </td><td> 外部块文档注释 </td></tr>
</tbody></table>
<p>表 B-8 展示了出现在使用元组时上下文中的符号。</p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>()</code> </td><td> 空元祖（亦称单元）， 用于常量或类型中 </td></tr>
<tr><td> <code>(expr)</code> </td><td> 括号表达式 </td></tr>
<tr><td> <code>(expr,)</code> </td><td> 单一元素元组表达式 </td></tr>
<tr><td> <code>(type,)</code> </td><td> 单一元素元组类型 </td></tr>
<tr><td> <code>(expr, ...)</code> </td><td> 元组表达式 </td></tr>
<tr><td> <code>(type, ...)</code> </td><td> 元组类型 </td></tr>
<tr><td> <code>expr(expr, ...)</code> </td><td> 函数调用表达式； 也用于初始化元组结构体 <code>struct</code> 以及元组枚举 <code>enum</code> 变体 </td></tr>
<tr><td> <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code> </td><td> 宏调用 </td></tr>
<tr><td> <code>expr.0</code>, <code>expr.1</code>, etc. </td><td> 元组索引 </td></tr>
</tbody></table>
<p>表 B-9 使用大括号的符号。</p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>{...}</code> </td><td> 块表达式 </td></tr>
<tr><td> <code>Type {...}</code> </td><td> <code>struct</code>  </td></tr>
</tbody></table>
<p>表 B-10 展示了使用方括号的符号。</p>
<p><span  class="caption">表 B-10: 方括号</span></p>
<table><thead><tr><th> 符号 </th><th> 解释 </th></tr></thead><tbody>
<tr><td> <code>[...]</code> </td><td> 数组 </td></tr>
<tr><td> <code>[expr; len]</code> </td><td> 复制了 <code>len</code>个 <code>expr</code>的数组 </td></tr>
<tr><td> <code>[type; len]</code> </td><td> 包含 <code>len</code>个 <code>type</code> 类型的数组</td></tr>
<tr><td> <code>expr[expr]</code> </td><td> 集合索引。 重载（<code>Index</code>, <code>IndexMut</code>） </td></tr>
<tr><td> <code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code> </td><td> 集合索引，使用 <code>Range</code>，<code>RangeFrom</code>，<code>RangeTo</code> 或 <code>RangeFull</code> 作为索引来代替集合切片 </td></tr>
</tbody></table>
<a class="header" href="print.html#a附录c---可派生的-trait" id="a附录c---可派生的-trait"><h2>附录C - 可派生的 trait</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-03-derivable-traits.md">appendix-03-derivable-traits.md</a>
<br />
commit 32215c1d96c9046c0b553a05fa5ec3ede2e125c3</p>
</blockquote>
<p>在本书的各个部分中，我们讨论了可应用于结构体和枚举的 <code>derive</code> 属性。<code>derive</code> 属性生成的代码在使用 <code>derive</code> 语法注释的类型之上实现了带有默认实现的 trait 。</p>
<p>在该附录中，我们提供标准库中所有可以使用 <code>derive</code> 的 trait 的参考。每部分都包含：</p>
<ul>
<li>该 trait 将会派生什么样的操作符和方法</li>
<li>由 <code>derive</code> 提供什么样的 trait 实现</li>
<li>由什么来实现类型的 trait</li>
<li>是否允许实现该 trait 的条件</li>
<li>需要 trait 操作的例子</li>
</ul>
<p>与 <code>derive</code> 属性提供的行为相比如果你需要与之不同的行为，请查阅标准库文档以获取每个 trait 的详情，来手动实现它们。</p>
<p>在类型上无法使用 <code>derive</code> 实现标准库的其余 trait。这些 trait 没有合理的默认行为, 因此，你可以以一种尝试完成的合理方式实现它们。</p>
<p>一个无法被派生的 trait 的例子是为最终用户处理格式化的 <code>Display</code> 。你应该时常考虑使用合适的方法来为最终用户显示一个类型。最终用户应该看到类型的什么部分？他们会找出相关部分吗？对他们来说，最相互关联的数据格式是什么样的？Rust 编译器没有这样的洞察力，因此，无法为你提供合适的默认行为。</p>
<p>本附录所提供的可派生 trait 列表并不全面：库可以为它们自己的 trait 实现 <code>derive</code> , 让可以使用 <code>derive</code> 的 trait 列表真诚的开放。实现 <code>derive</code> 涉及使用程序化宏，这在附录D中有介绍。</p>
<a class="header" href="print.html#a编程人员输出的-debug" id="a编程人员输出的-debug"><h2>编程人员输出的 <code>Debug</code></h2></a>
<p><code>Debug</code> trait 在格式化字符串中使调试格式化，你可以在 <code>{}</code> 占位符里面加上 <code>:?</code> 显示它。</p>
<p><code>Debug</code> trait 允许你以调试目的来打印一个类型的实例，因此，使用类型的你以及其他的编程人员可以让程序在执行时在指定点上显示一个实例。</p>
<p>例如，在使用 <code>assert_eq!</code> 宏时，Debug` trait 是必须的。如果等式断言失败，这个宏就把给定实例的值作为参数打印出来，因此，编程人员可以看到两个实例为什么不相等。</p>
<a class="header" href="print.html#a等值比较的-partialeq-和-eq" id="a等值比较的-partialeq-和-eq"><h2>等值比较的 <code>PartialEq</code> 和 <code>Eq</code></h2></a>
<p><code>PartialEq</code> trait 可以比较一个类型的实例以检查是否相等，并且可以使用 <code>==</code> 和 <code>!=</code> 操作符。</p>
<p>派生的 <code>PartialEq</code> 实现了 <code>eq</code> 方法。当 <code>PartialEq</code> 在结构体上派生时，只有<em>所有</em>的字段都相等时两个实例才相等，同时只要有字段不相等则两个实例就不相等。当在枚举上派生时，每一个变体(variant)都和它自身相等，且和其他变体都不相等。</p>
<p>例如，当使用 <code>assert_eq!</code> 宏时，需要比较比较一个类型的两个实例是否相等，则 <code>PartialEq</code> trait 是必须的。</p>
<p><code>Eq</code> trait 没有方法。其目的是为每一个注解类型的值作标志，其值等于其自身。 <code>Eq</code> trait 只能应用于那些实现了 <code>PartialEq</code> 的类型，但并非所有实现了 <code>PartialEq</code> 的类型可以实现 <code>Eq</code>。浮点类型就是一个例子：浮点数状态的实现，两个非数字（<code>NaN</code>，not-a-number）值是互不相等的。</p>
<p>例如，对于一个 <code>HashMap&lt;K, V&gt;</code> 中的 key 来说， <code>Eq</code> 是必须的，这样 <code>HashMap&lt;K, V&gt;</code> 就可以知道两个 key 是否一样了。</p>
<a class="header" href="print.html#a次序比较的-partialord-和-ord" id="a次序比较的-partialord-和-ord"><h2>次序比较的 <code>PartialOrd</code> 和 <code>Ord</code></h2></a>
<p><code>PartialOrd</code> trait 可以基于排序的目的而比较一个类型的实例。实现了 <code>PartialOrd</code> 的类型可以使用 <code>&lt;</code>、 <code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 操作符。但只能在同时实现了 <code>PartialEq</code> 的类型上使用 <code>PartialOrd</code>。</p>
<p>派生 <code>PartialOrd</code> 实现了 <code>partial_cmp</code> 方法，其返回一个 <code>Option&lt;Ordering&gt;</code> ，但当给定值无法产生顺序时将返回 <code>None</code>。尽管大多数类型的值都可以比较，但一个无法产生顺序的例子是：浮点类型的非数字值（<code>NaN</code>，not-a-number）。当在浮点数上调用 <code>partial_cmp</code> 时，<code>NaN</code> 的浮点数将返回 <code>None</code>。</p>
<p>当在结构体上派生时，<code>PartialOrd</code> 以在结构体定义中字段出现的顺序比较每个字段的值来比较两个实例。当在枚举上派生时，认为在枚举定义中声明较早的枚举变体小于其后的变体。</p>
<p>例如，对于来自于 <code>rand</code> carte 中的 <code>gen_range</code> 方法来说，当在一个大值和小值指定的范围内生成一个随机值时，<code>PartialOrd</code> trait 是必须的。</p>
<p><code>Ord</code> trait 也让你明白在一个带注解类型上的任意两个值存在有效顺序。<code>Ord</code> trait 实现了 <code>cmp</code> 方法，它返回一个 <code>Ordering</code> 而不是 <code>Option&lt;Ordering&gt;</code>，因为总存在一个合法的顺序。只可以在实现了 <code>PartialOrd</code> 和 <code>Eq</code>（ <code>Eq</code> 依赖 <code>PartialEq</code> ）的类型上使用 <code>Ord</code> trait 。当在结构体或枚举上派生时， <code>cmp</code> 和以 <code>PartialOrd</code> 派生实现的 <code>partial_cmp</code> 表现一致。</p>
<p>例如，当在 <code>BTreeSet&lt;T&gt;</code> （一种基于有序值存储数据的数据结构）上存值时，<code>Ord</code> 是必须的。</p>
<a class="header" href="print.html#a复制值的-clone-和-copy" id="a复制值的-clone-和-copy"><h2>复制值的 <code>Clone</code> 和 <code>Copy</code></h2></a>
<p><code>Clone</code> trait 可以明确地创建一个值的深拷贝（ deep copy ），复制过程可能包含任意代码的执行以及堆上数据的复制。查阅第四章“变量和数据的交互方式：移动”以获取有关 <code>Clone</code> 的更多信息。</p>
<p>派生 <code>Clone</code> 实现了 <code>clone</code> 方法，其为整个的类型实现时，在类型的每一部分上调用了 <code>clone</code> 方法。这意味着类型中所有字段或值也必须实现 <code>Clone</code> 来派生 <code>Clone</code> 。</p>
<p>例如，当在一个切片上调用 <code>to_vec</code> 方法时，<code>Clone</code> 是必须的。切片并不拥有其所包含实例的类型，但是从 <code>to_vec</code> 中返回的 vector 需要拥有其实例，因此，<code>to_vec</code> 在每个元素上调用 <code>clone</code>。因此，存储在切片中的类型必须实现 <code>Clone</code>。</p>
<p><code>Copy</code> trait 允许你通过只拷贝存储在栈上的位来复制值而不需要其他代码。查阅第四章“只在栈上的数据：拷贝”的部分来获取有关 <code>Copy</code> 的更多信息。</p>
<p><code>Copy</code> trait 并未定义任何方法来阻止编程人员重写这些方法或违反无代码可执行的假设。所以，所有的编程人员可以假设复制一个值非常快。</p>
<p>可以在类型内部全部实现 <code>Copy</code> trait 的任意类型上派生 <code>Copy</code>。 但只可以在那些同时实现了 <code>Clone</code> 的类型上使用 <code>Copy</code> trait ，因为一个实现 <code>Copy</code> 的类型在尝试实现 <code>Clone</code> 时执行和 <code>Copy</code> 相同的任务。</p>
<p><code>Copy</code> trait 很少使用；实现 <code>Copy</code> 的类型是可以优化的，这意味着你无需调用 <code>clone</code>，这让代码更简洁。</p>
<p>使用 <code>Clone</code> 实现 <code>Copy</code> 也是有可能的，但代码可能会稍慢或是要使用 <code>clone</code> 替代。</p>
<a class="header" href="print.html#a固定大小的值到值映射的-hash" id="a固定大小的值到值映射的-hash"><h2>固定大小的值到值映射的 <code>Hash</code></h2></a>
<p><code>Hash</code> trait 可以实例化一个任意大小的类型，并且能够用哈希（hash）函数将该实例映射到一个固定大小的值上。派生 <code>Hash</code> 实现了 <code>hash</code> 方法。<code>hash</code> 方法的派生实现结合了在类型的每部分调用 <code>hash</code> 的结果，这意味着所有的字段或值也必须将 <code>Hash</code> 实现为派生 <code>Hash</code>。</p>
<p>例如，在 <code>HashMap&lt;K, V&gt;</code> 的 key 上存储有效数据时，<code>Hash</code> 是必须的。</p>
<a class="header" href="print.html#a默认值的-default" id="a默认值的-default"><h2>默认值的 <code>Default</code></h2></a>
<p><code>Default</code> trait 使你创建一个类型的默认值。 派生 <code>Default</code> 实现了 <code>default</code> 函数。<code>default</code> 函数的派生实现调用了类型每部分的 <code>default</code> 函数，这意味着类型中所有的字段或值也必须把 <code>Default</code> 实现为派生 <code>Default</code> 。</p>
<p><code>Default::default</code> 函数通常结合结构体更新语法一起使用，这在第五章的“使用结构体更新语法从其他实例中创建实例”部分有讨论。可以自定义一个结构体的一小部分字段而剩余字段则使用 <code>..Default::default()</code> 设置为默认值。</p>
<p>例如，当你在 <code>Option&lt;T&gt;</code> 实例上使用 <code>unwrap_or_default</code> 方法时，<code>Default</code> trait是必须的。如果 <code>Option&lt;T&gt;</code> 是 <code>None</code>的话, <code>unwrap_or_default</code> 方法将返回存储在 <code>Option&lt;T&gt;</code> 中 <code>T</code> 类型的 <code>Default::default</code> 的结果。</p>
<a class="header" href="print.html#a附录d---宏" id="a附录d---宏"><h2>附录D - 宏</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-04-macros.md">appendix-04-macros.md</a>
<br>
commit 32215c1d96c9046c0b553a05fa5ec3ede2e125c3</p>
</blockquote>
<p>我们已经在本书中像 <em>println!</em> 这样使用过宏了，但还没完全探索什么是宏以及它是如何工作的。本附录以如下方式解释宏：</p>
<ul>
<li>什么是宏以及与函数有何区别</li>
<li>如何定义一个声明式宏（ declarative macro ）来进行元编程（metaprogramming）</li>
<li>如何定义一个过程式宏（ procedural macro ）来自定义 <code>derive</code> traits</li>
</ul>
<p>因为在 Rust 里宏仍在开发中，该附录会介绍宏的细节。宏已经改变了，在不久的将来，和语言的其他部分以及从 Rust 1.0 至今的标准库相比，将会以更快的速率改变，因此，和本书其他部分相比，本部分更有可能变得过时。由于 Rust 的稳定性保证，该处的代码将会在后续版本中继续可运行，但可能会以更优的性能或更容易的方式来写那些在此次发布版中无法实现的宏。当你尝试实现该附录任何功能时，请记住这一点。</p>
<a class="header" href="print.html#a宏和函数的区别" id="a宏和函数的区别"><h3>宏和函数的区别</h3></a>
<p>从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的<em>元编程</em>。在附录C中，探讨了 <code>derive</code> 属性，其生成各种 trait 的实现。我们也在本书中使用过 <code>println!</code> 宏和 <code>vec!</code> 宏。所有的这些宏 <em>扩展开</em> 来以生成比你手写更多的代码。</p>
<p>元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数的角色。但宏有一些函数所没有的附加能力。</p>
<p>一个函数标签必须声明函数参数个数和类型。而宏只接受一个可变参数：用一个参数调用 <code>println!(&quot;hello&quot;)</code> 或用两个参数调用 <code>println!(&quot;hello {}&quot;, name)</code> 。而且，宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。因为函数是在运行时被调用，同时 trait 需要在运行时实现，所以函数无法像宏这样。</p>
<p>实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂，因为你正在为写 Rust 代码而写代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。</p>
<p>宏和函数的另一个区别是：宏定义无法像函数定义那样出现在模块命名空间中。当使用外部包（ external crate ）时，为了防止无法预料的名字冲突，在导入外部包的同时也必须明确地用 <code>#[macro_use]</code> 注解将宏导入到项目中。下面的例子将所有定义在 <code>serde</code> 包中的宏导入到当前包中：</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate serde;
</code></pre>
<p>如果 <code>extern crate</code> 能够将宏默认导入而无需使用明确的注解，则会阻止你使用同时定义相同宏名的两个包。在练习中，这样的冲突并不经常遇到，但使用的包越多，越有可能遇到。</p>
<p>宏和函数最重要的区别是：在一个文件中，必须在调用宏<code>之前</code>定义或导入宏，然而却可以在任意地方定义或调用函数。</p>
<a class="header" href="print.html#a通用元编程的声明式宏-macro_rules" id="a通用元编程的声明式宏-macro_rules"><h3>通用元编程的声明式宏 <code>macro_rules!</code></h3></a>
<p>在 Rust 中，最广泛使用的宏形式是 <em>declarative macros</em> 。通常也指 <em>macros by example</em> 、<em><code>macro_rules!</code> macros</em> 或简单的 <em>macros</em> 。在其核心中，声明式宏使你可以写一些和 Rust 的 <code>match</code> 表达式类似的代码。正如在第六章讨论的那样，<code>match</code> 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。宏也将一个值和包含相关代码的模式进行比较；此种情况下，该值是 Rust 源代码传递给宏的常量，而模式则与源代码结构进行比较，同时每个模式的相关代码成为传递给宏的代码<!-- 这部分翻译自己不太满意-->。所有的这些都在编译时发生。</p>
<p>可以使用 <code>macro_rules!</code> 来定义宏。让我们通过查看 <code>vec!</code> 宏定义来探索如何使用 <code>macro_rules!</code> 结构。第八章讲述了如何使用 <code>vec!</code> 宏来生成一个给定值的 vector。例如，下面的宏用三个整数创建一个 vector `：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;u32&gt; = vec![1, 2, 3];
#}</code></pre></pre>
<p>也可以使用 <code>vec!</code> 宏来构造两个整数的 vector 或五个字符串切片的 vector 。但却无法使用函数做相同的事情，因为我们无法预先知道参数值的数量和类型。</p>
<p>在示例 D-1 中来看一个 <code>vec!</code> 稍微简化的定义。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#}</code></pre></pre>
<p><span class="caption">示例 D-1: <code>vec!</code> 宏定义的一个简化版本</span></p>
<blockquote>
<p>注意：标准库中实际定义的 <code>vec!</code> 包括预分配适当量的内存。这部分为代码优化，为了让示例简化，此处并没有包含在内。</p>
</blockquote>
<p>无论何时导入定义了宏的包，<code>#[macro_export]</code> 注解说明宏应该是可用的。 如果没有 <code>#[macro_export]</code> 注解，即使凭借包使用 <code>#[macro_use]</code> 注解，该宏也不会导入进来，</p>
<p>接着使用 <code>macro_rules!</code> 进行了宏定义，且所定义的宏并<em>不带</em>感叹号。名字后跟大括号表示宏定义体，在该例中是 <code>vec</code> 。</p>
<p><code>vec!</code> 宏的结构和 <code>match</code> 表达式的结构类似。此处有一个单边模式 <code>( $( $x:expr ),* )</code> ，后跟 <code>=&gt;</code> 以及和模式相关的代码块。如果模式匹配，该相关代码块将被执行。假设这只是这个宏中的模式，且只有一个有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。<!-- 此处 arm, one arm 并未找到合适的翻译--></p>
<p>宏定义中有效模式语法和在第十八章提及的模式语法是不同的，因为宏模式所匹配的是 Rust 代码结构而不是值。回过头来检查下示例 D-1 中模式片段什么意思。对于全部的宏模式语法，请查阅<a href="https://github.com/rust-lang/book/blob/master/reference/macros.html">参考</a>。</p>
<p>首先，一对括号包含了全部模式。接下来是后跟一对括号的美元符号（ <code>$</code> ），其通过替代代码捕获了符合括号内模式的值。<code>$()</code> 内则是 <code>$x:expr</code> ，其匹配 Rust 的任意表达式或给定 <code>$x</code> 名字的表达式。</p>
<p><code>$()</code> 之后的逗号说明一个逗号分隔符可以有选择的出现代码之后，这段代码与在 <code>$()</code> 中所捕获的代码相匹配。紧随逗号之后的 <code>*</code> 说明该模式匹配零个或多个 <code>*</code> 之前的任何模式。</p>
<p>当以 <code>vec![1, 2, 3];</code> 调用宏时，<code>$x</code> 模式与三个表达式 <code>1</code>、<code>2</code> 和 <code>3</code> 进行了三次匹配。</p>
<p>现在让我们来看看这个出现在与此单边模式相关的代码块中的模式：在 <code>$()*</code> 部分中所生成的 <code>temp_vec.push()</code> 为在匹配到模式中的 <code>$()</code> 每一部分而生成。<code>$x</code> 由每个与之相匹配的表达式所替换。当以 <code>vec![1, 2, 3];</code> 调用该宏时，替换该宏调用所生成的代码会是下面这样：</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>我们已经定义了一个宏，其可以接收任意数量和类型的参数，同时可以生成能够创建包含指定元素的 vector 的代码。</p>
<p>鉴于大多数 Rust 程序员<em>使用</em>宏而不是<em>写</em>宏，此处不再深入探讨 <code>macro_rules!</code> 。请查阅在线文档或其他资源，如 <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a> 来更多地了解如何写宏。</p>
<a class="header" href="print.html#a自定义-derive-的过程式宏" id="a自定义-derive-的过程式宏"><h3>自定义 <code>derive</code> 的过程式宏</h3></a>
<p>第二种形式的宏叫做<em>过程式宏</em>（ <em>procedural macros</em> ），因为它们更像函数（一种过程类型）。过程式宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。在书写部分附录时，只能定义过程式宏来使你在一个通过 <code>derive</code> 注解来指定 trait 名的类型上实现 trait 。</p>
<p>我们会创建一个 <code>hello_macro</code> 包，该包定义了一个关联到 <code>hello_macro</code> 函数并以 <code>HelloMacro</code> 为名的trait。并非让包的用户为其每一个类型实现<code>HelloMacro</code> trait，我们将会提供一个过程式宏以便用户可以使用 <code>#[derive(HelloMacro)]</code> 注解他们的类型来得到 <code>hello_macro</code> 函数的默认实现。该函数的默认实现会打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 为定义了 trait 的类型名。换言之，我们会创建一个包，让使用该包的程序员能够写类似示例 D-2 中的代码。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_macro;
#[macro_use]
extern crate hello_macro_derive;

use hello_macro::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">示例 D-2: 包用户所写的能够使用过程式宏的代码</span></p>
<p>运行该代码将会打印 <code>Hello, Macro! My name is Pancakes!</code> 第一步是像下面这样新建一个库：</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<p>接下来，会定义 <code>HelloMacro</code> trait 以及其关联函数：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait HelloMacro {
    fn hello_macro();
}
#}</code></pre></pre>
<p>现在有了一个包含函数的 trait 。此时，包用户可以实现该 trait 以达到其期望的功能，像这样：</p>
<pre><code class="language-rust ignore">extern crate hello_macro;

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>然而，他们需要为每一个他们想使用 <code>hello_macro</code> 的类型编写实现的代码块。我们希望为其节约这些工作。</p>
<p>另外，我们也无法为 <code>hello_macro</code> 函数提供一个能够打印实现了该 trait 的类型的名字的默认实现：Rust 没有反射的能力，因此其无法在运行时获取类型名。我们需要一个在运行时生成代码的宏。</p>
<p>下一步是定义过程式宏。在编写该附录时，过程式宏必须在包内。该限制后面可能被取消。构造包和包中宏的惯例如下：对于一个 <code>foo</code> 的包来说，一个自定义的派生过程式宏的包被称为 <code>foo_derive</code> 。在 <code>hello_macro</code> 项目中新建名为 <code>hello_macro_derive</code> 的包。</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<p>由于两个包紧密相关，因此在 <code>hello_macro</code> 包的目录下创建过程式宏的包。如果改变在 <code>hello_macro</code> 中定义的 trait ，同时也必须改变在 <code>hello_macro_derive</code> 中实现的过程式宏。这两个包需要分别发布，编程人员如果使用这些包，则需要同时添加这两个依赖并导入到代码中。我们也可以只用 <code>hello_macro</code> 包而将 <code>hello_macro_derive</code> 作为一个依赖，并重新导出过程式宏的代码。但我们组织项目的方式使编程人员使用 <code>hello_macro</code> 成为可能，即使他们无需 <code>derive</code> 的功能。</p>
<p>需要将 <code>hello_macro_derive</code> 声明为一个过程式宏的包。同时也需要 <code>syn</code> 和 <code>quote</code> 包中的功能，正如注释中所说，需要将其加到依赖中。为 <code>hello_macro_derive</code> 将下面的代码加入到 <em>Cargo.toml</em> 文件中。</p>
<p><span class="filename">文件名: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<p>为定义一个过程式宏，请将示例 D-3 中的代码放在 <code>hello_macro_derive</code> 包的 <em>src/lib.rs</em> 文件里面。注意这段代码在我们添加 <code>impl_hello_macro</code> 函数的定义之前是无法编译的。</p>
<p><span class="filename">文件名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_macro(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<p><span class="caption">示例 D-3: 大多数过程式宏处理 Rust 代码的代码</span></p>
<p>注意在 D-3 中分离函数的方式，这将和你几乎所见到或创建的每一个过程式宏都一样，因为这让编写一个过程式宏更加方便。在 <code>impl_hello_macro</code> 被调用的地方所选择做的什么依赖于该过程式宏的目的而有所不同。</p>
<p>现在，我们已经介绍了三个包：<code>proc_macro</code> 、 <a href="https://crates.io/crates/syn"><code>syn</code></a> 和 <a href="https://crates.io/crates/quote"><code>quote</code></a> 。Rust 自带 <code>proc_macro</code>  ，因此无需将其加到 <em>Cargo.toml</em> 文件的依赖中。<code>proc_macro</code> 可以将 Rust 代码转换为相应的字符串。<code>syn</code> 则将字符串中的 Rust 代码解析成为一个可以操作的数据结构。<code>quote</code> 则将 <code>syn</code> 解析的数据结构反过来传入到 Rust 代码中。这些包让解析我们所要处理的有序 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作。</p>
<p>当用户在一个类型上指定 <code>#[derive(HelloMacro)]</code> 时，<code>hello_macro_derive</code>  函数将会被调用。
原因在于我们已经使用 <code>proc_macro_derive</code> 及其指定名称对 <code>hello_macro_derive</code> 函数进行了注解：<code>HelloMacro</code> ，其匹配到 trait 名，这是大多数过程式宏的方便之处。</p>
<p>该函数首先将来自 <code>TokenStream</code> 的 <code>输入</code> 转换为一个名为 <code>to_string</code> 的 <code>String</code> 类型。该 <code>String</code> 代表 派生 <code>HelloMacro</code> Rust 代码的字符串。在示例 D-2 的例子中，<code>s</code> 是 <code>String</code> 类型的 <code>struct Pancakes;</code> 值，这是因为我们加上了 <code>#[derive(HelloMacro)]</code> 注解。</p>
<blockquote>
<p>注意：编写本附录时，只可以将 <code>TokenStream</code> 转换为字符串，将来会提供更丰富的API。</p>
</blockquote>
<p>现在需要将 <code>String</code> 类型的 Rust 代码 解析为一个数据结构中，随后便可以与之交互并操作该数据结构。这正是 <code>syn</code> 所做的。<code>syn</code> 中的 <code>parse_derive_input</code> 函数以一个 <code>String</code> 作为参数并返回一个 表示解析出 Rust 代码的 <code>DeriveInput</code> 结构体。 下面的代码 展示了从字符串 <code>struct Pancakes;</code> 中解析出来的 <code>DeriveInput</code> 结构体的相关部分。</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<p>该结构体的字段展示了我们解析的 Rust 代码是一个元组结构体，其 <code>ident</code> （ identifier，表示名字）为 <code>Pancakes</code> 。该结构体里面有更多字段描述了所有有序 Rust 代码，查阅 <a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>syn</code>
documentation for <code>DeriveInput</code></a> 以获取更多信息。</p>
<p>此时，尚未定义 <code>impl_hello_macro</code> 函数，其用于构建所要包含在内的 Rust 新代码。但在定义之前，要注意 <code>hello_macro_derive</code> 函数的最后一部分使用了 <code>quote</code> 包中的 <code>parse</code> 函数，该函数将 <code>impl_hello_macro</code> 的输出返回给 <code>TokenStream</code> 。所返回的 <code>TokenStream</code> 会被加到我们的包用户所写的代码中，因此，当用户编译他们的包时，他们会获取到我们所提供的额外功能。</p>
<p>你也注意到，当调用 <code>parse_derive_input</code> 或 <code>parse</code> 失败时，我们调用 <code>unwrap</code> 来抛出异常。在过程式宏中，有必要错误上抛异常，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code> ，以此来符合过程式宏的 API 。我们已经选择用 <code>unwrap</code> 来简化了这个例子；在生产中的代码里，你应该通过 <code>panic!</code> 或 <code>expect</code> 来提供关于发生何种错误的更加明确的错误信息。</p>
<p>现在我们有了将注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>String</code> 和 <code>DeriveInput</code> 实例的代码，让我们来创建在注解类型上实现 <code>HelloMacro</code> trait 的代码。</p>
<p><span class="filename">文件名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<p>我们得到一个包含以 <code>ast.ident</code> 作为注解类型名字（标识符）的 <code>Ident</code> 结构体实例。示例 D-2 中的代码说明 <code>name</code> 会是 <code>Ident(&quot;Pancakes&quot;)</code> 。</p>
<p><code>quote!</code> 宏让我们编写我们想要返回的代码，并可以将其传入进 <code>quote::Tokens</code> 。这个宏也提供了一些非常酷的模板机制；我们可以写 <code>#name</code> ，然后 <code>quote!</code> 会以 名为 <code>name</code> 的变量值来替换它。你甚至可以做些与这个正则宏任务类似的重复事情。查阅 <a href="https://docs.rs/quote">the <code>quote</code> crate’s
docs</a> 来获取详尽的介绍。</p>
<p>我们期望我们的过程式宏能够为通过 <code>#name</code> 获取到的用户注解类型生成 <code>HelloMacro</code> trait 的实现。该 trait 的实现有一个函数 <code>hello_macro</code> ，其函数体包括了我们期望提供的功能：打印 <code>Hello, Macro! My name is</code> 和注解的类型名。</p>
<p>此处所使用的 <code>stringify!</code> 为 Rust 内置宏。其接收一个 Rust 表达式，如 <code>1 + 2</code> ， 然后在编译时将表达式转换为一个字符串常量，如 <code>&quot;1 + 2&quot;</code> 。这与 <code>format!</code> 或 <code>println!</code> 是不同的，它计算表达式并将结果转换为 <code>String</code> 。有一种可能的情况是，所输入的 <code>#name</code> 可能是一个需要打印的表达式，因此我们用 <code>stringify!</code> 。 <code>stringify!</code> 编译时也保留了一份将 <code>#name</code> 转换为字符串之后的内存分配。</p>
<p>此时，<code>cargo build</code> 应该都能成功编译 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 。我们将这些 crate 连接到示例 D-2 的代码中来看看过程式宏的行为。在 <em>projects</em> 目录下用 <code>cargo new pancakes</code> 命令新建一个二进制项目。需要将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 作为依赖加到 <code>pancakes</code> 包的 <em>Cargo.toml</em>  文件中去。如果你正将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href="https://crates.io/"><em>https://crates.io/</em></a> 上，其应为正规依赖；如果不是，则可以像下面这样将其指定为 <code>path</code> 依赖：</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>把示例 D-2 中的代码放在 <em>src/main.rs</em> ，然后执行 <code>cargo run</code> ： 其应该打印 <code>Hello, Macro! My name is Pancakes!</code> 。从过程式宏中实现的 <code>HelloMacro</code> trait 被包括在内，但并不包含 <code>pancakes</code> 的包，需要实现它。<code>#[derive(HelloMacro)]</code> 添加了该 trait 的实现。<!-- 中间句子翻译不是太好 --></p>
<a class="header" href="print.html#a宏的前景" id="a宏的前景"><h3>宏的前景</h3></a>
<p>在将来，Rust 仍会扩展声明式宏和过程式宏。Rust会通过 <code>macro</code> 使用一个更好的声明式宏系统，以及为较之 <code>derive</code> 的更强大的任务增加更多的过程式宏类型。在本书出版时，这些系统仍然在开发中，请查阅 Rust 在线文档以获取最新信息。</p>
<a class="header" href="print.html#a附录e---本书翻译" id="a附录e---本书翻译"><h2>附录E - 本书翻译</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-05-translation.md">appendix-05-translation.md</a>
<br />
commit 9c3756a33e6c1aa07a762ffa853fcdfcffb48ddc</p>
</blockquote>
<p>一些非英语语言的资源。多数仍在翻译中；查阅<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">翻译标签</a>来帮助我们或使我们知道新的翻译！</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/hngnaig/rust-lang-book/tree/vi-VN">Tiếng việt</a></li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/iDeBugger/rust-book-ru">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/hazama-yuinyan/book">日本語</a></li>
<li><a href="https://github.com/quadrifoglio/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
</ul>
<a class="header" href="print.html#f---最新功能" id="f---最新功能"><h2>F - 最新功能</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/appendix-06-newest-features.md">appendix-06-newest-features.md</a>
<br />
commit b64de01431cdf1020ad3358d2f83e46af68a39ed</p>
</blockquote>
<p>自从本书的主要部分完成之后，该附录文档中的特性已经加到 Rust 的稳定版中。</p>
<a class="header" href="print.html#a字段初始化缩写" id="a字段初始化缩写"><h3>字段初始化缩写</h3></a>
<p>我们可以通过具名字段来初始化一个数据结构（结构体、枚举、联合体），如将 <code>fieldname: fieldname</code> 缩写为 <code>fieldname</code> 。这可以以更少的重复代码来完成一个复杂的初始化语法。</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let name = String::from(&quot;Peter&quot;);
    let age = 27;

    // Using full syntax:
    let peter = Person { name: name, age: age };

    let name = String::from(&quot;Portia&quot;);
    let age = 27;

    // Using field init shorthand:
    let portia = Person { name, age };

    println!(&quot;{:?}&quot;, portia);
}
</code></pre></pre>
<a class="header" href="print.html#a从循环中返回-loop-" id="a从循环中返回-loop-"><h2>从循环中返回（ loop ）</h2></a>
<p><code>loop</code> 的用法之一是重试一个可以操作，比如检查线程是否完成其任务。然而可能需要将该操作的结果传到其他部分代码。如果加上 <code>break</code> 表达式来停止循环，则会从循环中断中返回：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<a class="header" href="print.html#use-声明中的内置组" id="use-声明中的内置组"><h2><code>use</code> 声明中的内置组</h2></a>
<p>如果有一个包含许多不同子模块的复杂模块树，然后需要从每个子模块中引入几个特性，那么将所有导入模块放在同一声明中来保持代码清洁同时避免根模块名重复将会非常有用。</p>
<p><code>use</code> 声明所支持的嵌套在这些情况下对你有帮助：简单的导入和全局导入。例如，下面的代码片段导入了 <code>bar</code> 、 <code>Foo</code> 、 <code>baz</code> 中所有项和 <code>Bar</code> ：</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_imports, dead_code)]
#
# mod foo {
#     pub mod bar {
#         pub type Foo = ();
#     }
#     pub mod baz {
#         pub mod quux {
#             pub type Bar = ();
#         }
#     }
# }
#
use foo::{
    bar::{self, Foo},
    baz::{*, quux::Bar},
};
#
# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#a范围包含" id="a范围包含"><h2>范围包含</h2></a>
<p>先前，当在表达式中使用范围（ <code>..</code> 或 <code>...</code> ）时，其必须使用排除上界的 <code>..</code> ，而在模式中，则要使用包含上界的 <code>...</code> 。而现在，<code>..=</code> 可作为语法用于表达式或范围上下文件中的包含范围中。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for i in 0 ..= 10 {
        match i {
            0 ..= 5 =&gt; println!(&quot;{}: low&quot;, i),
            6 ..= 10 =&gt; println!(&quot;{}: high&quot;, i),
            _ =&gt; println!(&quot;{}: out of range&quot;, i),
        }
    }
}
</code></pre></pre>
<p><code>...</code> 语法也可用在匹配语法中，但不能用于表达式中，而 <code>..=</code> 则二者皆可。</p>
<a class="header" href="print.html#a128-字节的整数" id="a128-字节的整数"><h2>128 字节的整数</h2></a>
<p>Rust 1.26.0 添加了 128 字节的整数基本类型：</p>
<ul>
<li><code>u128</code>: 一个在 [0, 2^128 - 1] 范围内的 128 字节的无符号整数</li>
<li><code>i128</code>: 一个在 [-(2^127), 2^127 - 1] 范围内的有符号整数</li>
</ul>
<p>这俩基本类型由 LLVM 支持高效地实现。即使在不支持 128 字节整数的平台上，它们都是可用的，且可像其他整数类型那样使用。</p>
<p>这俩基本类型在那些需要高效使用大整数的算法中非常有用，如某些加密算法。</p>
<a class="header" href="print.html#g---rust-是如何开发的与-nightly-rust" id="g---rust-是如何开发的与-nightly-rust"><h2>G - Rust 是如何开发的与 “Nightly Rust”</h2></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
